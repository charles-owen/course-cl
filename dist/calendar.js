(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Calendar"] = factory();
	else
		root["Calendar"] = factory();
})(window, function() {
return (window["webpackJsonp_name_"] = window["webpackJsonp_name_"] || []).push([["Calendar"],{

/***/ "./node_modules/css-loader/index.js!./node_modules/fullcalendar/dist/fullcalendar.css":
/*!***********************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/fullcalendar/dist/fullcalendar.css ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*!\n * FullCalendar v3.9.0\n * Docs & License: https://fullcalendar.io/\n * (c) 2018 Adam Shaw\n */\n.fc {\n  direction: ltr;\n  text-align: left; }\n\n.fc-rtl {\n  text-align: right; }\n\nbody .fc {\n  /* extra precedence to overcome jqui */\n  font-size: 1em; }\n\n/* Colors\n--------------------------------------------------------------------------------------------------*/\n.fc-highlight {\n  /* when user is selecting cells */\n  background: #bce8f1;\n  opacity: .3; }\n\n.fc-bgevent {\n  /* default look for background events */\n  background: #8fdf82;\n  opacity: .3; }\n\n.fc-nonbusiness {\n  /* default look for non-business-hours areas */\n  /* will inherit .fc-bgevent's styles */\n  background: #d7d7d7; }\n\n/* Buttons (styled <button> tags, normalized to work cross-browser)\n--------------------------------------------------------------------------------------------------*/\n.fc button {\n  /* force height to include the border and padding */\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  /* dimensions */\n  margin: 0;\n  height: 2.1em;\n  padding: 0 .6em;\n  /* text & cursor */\n  font-size: 1em;\n  /* normalize */\n  white-space: nowrap;\n  cursor: pointer; }\n\n/* Firefox has an annoying inner border */\n.fc button::-moz-focus-inner {\n  margin: 0;\n  padding: 0; }\n\n.fc-state-default {\n  /* non-theme */\n  border: 1px solid; }\n\n.fc-state-default.fc-corner-left {\n  /* non-theme */\n  border-top-left-radius: 4px;\n  border-bottom-left-radius: 4px; }\n\n.fc-state-default.fc-corner-right {\n  /* non-theme */\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px; }\n\n/* icons in buttons */\n.fc button .fc-icon {\n  /* non-theme */\n  position: relative;\n  top: -0.05em;\n  /* seems to be a good adjustment across browsers */\n  margin: 0 .2em;\n  vertical-align: middle; }\n\n/*\n  button states\n  borrowed from twitter bootstrap (http://twitter.github.com/bootstrap/)\n*/\n.fc-state-default {\n  background-color: #f5f5f5;\n  background-image: -moz-linear-gradient(top, #ffffff, #e6e6e6);\n  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#ffffff), to(#e6e6e6));\n  background-image: -webkit-linear-gradient(top, #ffffff, #e6e6e6);\n  background-image: -o-linear-gradient(top, #ffffff, #e6e6e6);\n  background-image: linear-gradient(to bottom, #ffffff, #e6e6e6);\n  background-repeat: repeat-x;\n  border-color: #e6e6e6 #e6e6e6 #bfbfbf;\n  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\n  color: #333;\n  text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); }\n\n.fc-state-hover,\n.fc-state-down,\n.fc-state-active,\n.fc-state-disabled {\n  color: #333333;\n  background-color: #e6e6e6; }\n\n.fc-state-hover {\n  color: #333333;\n  text-decoration: none;\n  background-position: 0 -15px;\n  -webkit-transition: background-position 0.1s linear;\n  -moz-transition: background-position 0.1s linear;\n  -o-transition: background-position 0.1s linear;\n  transition: background-position 0.1s linear; }\n\n.fc-state-down,\n.fc-state-active {\n  background-color: #cccccc;\n  background-image: none;\n  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05); }\n\n.fc-state-disabled {\n  cursor: default;\n  background-image: none;\n  opacity: 0.65;\n  box-shadow: none; }\n\n/* Buttons Groups\n--------------------------------------------------------------------------------------------------*/\n.fc-button-group {\n  display: inline-block; }\n\n/*\nevery button that is not first in a button group should scootch over one pixel and cover the\nprevious button's border...\n*/\n.fc .fc-button-group > * {\n  /* extra precedence b/c buttons have margin set to zero */\n  float: left;\n  margin: 0 0 0 -1px; }\n\n.fc .fc-button-group > :first-child {\n  /* same */\n  margin-left: 0; }\n\n/* Popover\n--------------------------------------------------------------------------------------------------*/\n.fc-popover {\n  position: absolute;\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); }\n\n.fc-popover .fc-header {\n  /* TODO: be more consistent with fc-head/fc-body */\n  padding: 2px 4px; }\n\n.fc-popover .fc-header .fc-title {\n  margin: 0 2px; }\n\n.fc-popover .fc-header .fc-close {\n  cursor: pointer; }\n\n.fc-ltr .fc-popover .fc-header .fc-title,\n.fc-rtl .fc-popover .fc-header .fc-close {\n  float: left; }\n\n.fc-rtl .fc-popover .fc-header .fc-title,\n.fc-ltr .fc-popover .fc-header .fc-close {\n  float: right; }\n\n/* Misc Reusable Components\n--------------------------------------------------------------------------------------------------*/\n.fc-divider {\n  border-style: solid;\n  border-width: 1px; }\n\nhr.fc-divider {\n  height: 0;\n  margin: 0;\n  padding: 0 0 2px;\n  /* height is unreliable across browsers, so use padding */\n  border-width: 1px 0; }\n\n.fc-clear {\n  clear: both; }\n\n.fc-bg,\n.fc-bgevent-skeleton,\n.fc-highlight-skeleton,\n.fc-helper-skeleton {\n  /* these element should always cling to top-left/right corners */\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0; }\n\n.fc-bg {\n  bottom: 0;\n  /* strech bg to bottom edge */ }\n\n.fc-bg table {\n  height: 100%;\n  /* strech bg to bottom edge */ }\n\n/* Tables\n--------------------------------------------------------------------------------------------------*/\n.fc table {\n  width: 100%;\n  box-sizing: border-box;\n  /* fix scrollbar issue in firefox */\n  table-layout: fixed;\n  border-collapse: collapse;\n  border-spacing: 0;\n  font-size: 1em;\n  /* normalize cross-browser */ }\n\n.fc th {\n  text-align: center; }\n\n.fc th,\n.fc td {\n  border-style: solid;\n  border-width: 1px;\n  padding: 0;\n  vertical-align: top; }\n\n.fc td.fc-today {\n  border-style: double;\n  /* overcome neighboring borders */ }\n\n/* Internal Nav Links\n--------------------------------------------------------------------------------------------------*/\na[data-goto] {\n  cursor: pointer; }\n\na[data-goto]:hover {\n  text-decoration: underline; }\n\n/* Fake Table Rows\n--------------------------------------------------------------------------------------------------*/\n.fc .fc-row {\n  /* extra precedence to overcome themes w/ .ui-widget-content forcing a 1px border */\n  /* no visible border by default. but make available if need be (scrollbar width compensation) */\n  border-style: solid;\n  border-width: 0; }\n\n.fc-row table {\n  /* don't put left/right border on anything within a fake row.\n     the outer tbody will worry about this */\n  border-left: 0 hidden transparent;\n  border-right: 0 hidden transparent;\n  /* no bottom borders on rows */\n  border-bottom: 0 hidden transparent; }\n\n.fc-row:first-child table {\n  border-top: 0 hidden transparent;\n  /* no top border on first row */ }\n\n/* Day Row (used within the header and the DayGrid)\n--------------------------------------------------------------------------------------------------*/\n.fc-row {\n  position: relative; }\n\n.fc-row .fc-bg {\n  z-index: 1; }\n\n/* highlighting cells & background event skeleton */\n.fc-row .fc-bgevent-skeleton,\n.fc-row .fc-highlight-skeleton {\n  bottom: 0;\n  /* stretch skeleton to bottom of row */ }\n\n.fc-row .fc-bgevent-skeleton table,\n.fc-row .fc-highlight-skeleton table {\n  height: 100%;\n  /* stretch skeleton to bottom of row */ }\n\n.fc-row .fc-highlight-skeleton td,\n.fc-row .fc-bgevent-skeleton td {\n  border-color: transparent; }\n\n.fc-row .fc-bgevent-skeleton {\n  z-index: 2; }\n\n.fc-row .fc-highlight-skeleton {\n  z-index: 3; }\n\n/*\nrow content (which contains day/week numbers and events) as well as \"helper\" (which contains\ntemporary rendered events).\n*/\n.fc-row .fc-content-skeleton {\n  position: relative;\n  z-index: 4;\n  padding-bottom: 2px;\n  /* matches the space above the events */ }\n\n.fc-row .fc-helper-skeleton {\n  z-index: 5; }\n\n.fc .fc-row .fc-content-skeleton table,\n.fc .fc-row .fc-content-skeleton td,\n.fc .fc-row .fc-helper-skeleton td {\n  /* see-through to the background below */\n  /* extra precedence to prevent theme-provided backgrounds */\n  background: none;\n  /* in case <td>s are globally styled */\n  border-color: transparent; }\n\n.fc-row .fc-content-skeleton td,\n.fc-row .fc-helper-skeleton td {\n  /* don't put a border between events and/or the day number */\n  border-bottom: 0; }\n\n.fc-row .fc-content-skeleton tbody td,\n.fc-row .fc-helper-skeleton tbody td {\n  /* don't put a border between event cells */\n  border-top: 0; }\n\n/* Scrolling Container\n--------------------------------------------------------------------------------------------------*/\n.fc-scroller {\n  -webkit-overflow-scrolling: touch; }\n\n/* TODO: move to agenda/basic */\n.fc-scroller > .fc-day-grid,\n.fc-scroller > .fc-time-grid {\n  position: relative;\n  /* re-scope all positions */\n  width: 100%;\n  /* hack to force re-sizing this inner element when scrollbars appear/disappear */ }\n\n/* Global Event Styles\n--------------------------------------------------------------------------------------------------*/\n.fc-event {\n  position: relative;\n  /* for resize handle and other inner positioning */\n  display: block;\n  /* make the <a> tag block */\n  font-size: .85em;\n  line-height: 1.3;\n  border-radius: 3px;\n  border: 1px solid #3a87ad;\n  /* default BORDER color */ }\n\n.fc-event,\n.fc-event-dot {\n  background-color: #3a87ad;\n  /* default BACKGROUND color */ }\n\n.fc-event,\n.fc-event:hover {\n  color: #fff;\n  /* default TEXT color */\n  text-decoration: none;\n  /* if <a> has an href */ }\n\n.fc-event[href],\n.fc-event.fc-draggable {\n  cursor: pointer;\n  /* give events with links and draggable events a hand mouse pointer */ }\n\n.fc-not-allowed,\n.fc-not-allowed .fc-event {\n  /* to override an event's custom cursor */\n  cursor: not-allowed; }\n\n.fc-event .fc-bg {\n  /* the generic .fc-bg already does position */\n  z-index: 1;\n  background: #fff;\n  opacity: .25; }\n\n.fc-event .fc-content {\n  position: relative;\n  z-index: 2; }\n\n/* resizer (cursor AND touch devices) */\n.fc-event .fc-resizer {\n  position: absolute;\n  z-index: 4; }\n\n/* resizer (touch devices) */\n.fc-event .fc-resizer {\n  display: none; }\n\n.fc-event.fc-allow-mouse-resize .fc-resizer,\n.fc-event.fc-selected .fc-resizer {\n  /* only show when hovering or selected (with touch) */\n  display: block; }\n\n/* hit area */\n.fc-event.fc-selected .fc-resizer:before {\n  /* 40x40 touch area */\n  content: \"\";\n  position: absolute;\n  z-index: 9999;\n  /* user of this util can scope within a lower z-index */\n  top: 50%;\n  left: 50%;\n  width: 40px;\n  height: 40px;\n  margin-left: -20px;\n  margin-top: -20px; }\n\n/* Event Selection (only for touch devices)\n--------------------------------------------------------------------------------------------------*/\n.fc-event.fc-selected {\n  z-index: 9999 !important;\n  /* overcomes inline z-index */\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); }\n\n.fc-event.fc-selected.fc-dragging {\n  box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3); }\n\n/* Horizontal Events\n--------------------------------------------------------------------------------------------------*/\n/* bigger touch area when selected */\n.fc-h-event.fc-selected:before {\n  content: \"\";\n  position: absolute;\n  z-index: 3;\n  /* below resizers */\n  top: -10px;\n  bottom: -10px;\n  left: 0;\n  right: 0; }\n\n/* events that are continuing to/from another week. kill rounded corners and butt up against edge */\n.fc-ltr .fc-h-event.fc-not-start,\n.fc-rtl .fc-h-event.fc-not-end {\n  margin-left: 0;\n  border-left-width: 0;\n  padding-left: 1px;\n  /* replace the border with padding */\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0; }\n\n.fc-ltr .fc-h-event.fc-not-end,\n.fc-rtl .fc-h-event.fc-not-start {\n  margin-right: 0;\n  border-right-width: 0;\n  padding-right: 1px;\n  /* replace the border with padding */\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0; }\n\n/* resizer (cursor AND touch devices) */\n/* left resizer  */\n.fc-ltr .fc-h-event .fc-start-resizer,\n.fc-rtl .fc-h-event .fc-end-resizer {\n  cursor: w-resize;\n  left: -1px;\n  /* overcome border */ }\n\n/* right resizer */\n.fc-ltr .fc-h-event .fc-end-resizer,\n.fc-rtl .fc-h-event .fc-start-resizer {\n  cursor: e-resize;\n  right: -1px;\n  /* overcome border */ }\n\n/* resizer (mouse devices) */\n.fc-h-event.fc-allow-mouse-resize .fc-resizer {\n  width: 7px;\n  top: -1px;\n  /* overcome top border */\n  bottom: -1px;\n  /* overcome bottom border */ }\n\n/* resizer (touch devices) */\n.fc-h-event.fc-selected .fc-resizer {\n  /* 8x8 little dot */\n  border-radius: 4px;\n  border-width: 1px;\n  width: 6px;\n  height: 6px;\n  border-style: solid;\n  border-color: inherit;\n  background: #fff;\n  /* vertically center */\n  top: 50%;\n  margin-top: -4px; }\n\n/* left resizer  */\n.fc-ltr .fc-h-event.fc-selected .fc-start-resizer,\n.fc-rtl .fc-h-event.fc-selected .fc-end-resizer {\n  margin-left: -4px;\n  /* centers the 8x8 dot on the left edge */ }\n\n/* right resizer */\n.fc-ltr .fc-h-event.fc-selected .fc-end-resizer,\n.fc-rtl .fc-h-event.fc-selected .fc-start-resizer {\n  margin-right: -4px;\n  /* centers the 8x8 dot on the right edge */ }\n\n/* DayGrid events\n----------------------------------------------------------------------------------------------------\nWe use the full \"fc-day-grid-event\" class instead of using descendants because the event won't\nbe a descendant of the grid when it is being dragged.\n*/\n.fc-day-grid-event {\n  margin: 1px 2px 0;\n  /* spacing between events and edges */\n  padding: 0 1px; }\n\ntr:first-child > td > .fc-day-grid-event {\n  margin-top: 2px;\n  /* a little bit more space before the first event */ }\n\n.fc-day-grid-event.fc-selected:after {\n  content: \"\";\n  position: absolute;\n  z-index: 1;\n  /* same z-index as fc-bg, behind text */\n  /* overcome the borders */\n  top: -1px;\n  right: -1px;\n  bottom: -1px;\n  left: -1px;\n  /* darkening effect */\n  background: #000;\n  opacity: .25; }\n\n.fc-day-grid-event .fc-content {\n  /* force events to be one-line tall */\n  white-space: nowrap;\n  overflow: hidden; }\n\n.fc-day-grid-event .fc-time {\n  font-weight: bold; }\n\n/* resizer (cursor devices) */\n/* left resizer  */\n.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer,\n.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer {\n  margin-left: -2px;\n  /* to the day cell's edge */ }\n\n/* right resizer */\n.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer,\n.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer {\n  margin-right: -2px;\n  /* to the day cell's edge */ }\n\n/* Event Limiting\n--------------------------------------------------------------------------------------------------*/\n/* \"more\" link that represents hidden events */\na.fc-more {\n  margin: 1px 3px;\n  font-size: .85em;\n  cursor: pointer;\n  text-decoration: none; }\n\na.fc-more:hover {\n  text-decoration: underline; }\n\n.fc-limited {\n  /* rows and cells that are hidden because of a \"more\" link */\n  display: none; }\n\n/* popover that appears when \"more\" link is clicked */\n.fc-day-grid .fc-row {\n  z-index: 1;\n  /* make the \"more\" popover one higher than this */ }\n\n.fc-more-popover {\n  z-index: 2;\n  width: 220px; }\n\n.fc-more-popover .fc-event-container {\n  padding: 10px; }\n\n/* Now Indicator\n--------------------------------------------------------------------------------------------------*/\n.fc-now-indicator {\n  position: absolute;\n  border: 0 solid red; }\n\n/* Utilities\n--------------------------------------------------------------------------------------------------*/\n.fc-unselectable {\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-touch-callout: none;\n  -webkit-tap-highlight-color: transparent; }\n\n/*\nTODO: more distinction between this file and common.css\n*/\n/* Colors\n--------------------------------------------------------------------------------------------------*/\n.fc-unthemed th,\n.fc-unthemed td,\n.fc-unthemed thead,\n.fc-unthemed tbody,\n.fc-unthemed .fc-divider,\n.fc-unthemed .fc-row,\n.fc-unthemed .fc-content,\n.fc-unthemed .fc-popover,\n.fc-unthemed .fc-list-view,\n.fc-unthemed .fc-list-heading td {\n  border-color: #ddd; }\n\n.fc-unthemed .fc-popover {\n  background-color: #fff; }\n\n.fc-unthemed .fc-divider,\n.fc-unthemed .fc-popover .fc-header,\n.fc-unthemed .fc-list-heading td {\n  background: #eee; }\n\n.fc-unthemed .fc-popover .fc-header .fc-close {\n  color: #666; }\n\n.fc-unthemed td.fc-today {\n  background: #fcf8e3; }\n\n.fc-unthemed .fc-disabled-day {\n  background: #d7d7d7;\n  opacity: .3; }\n\n/* Icons (inline elements with styled text that mock arrow icons)\n--------------------------------------------------------------------------------------------------*/\n.fc-icon {\n  display: inline-block;\n  height: 1em;\n  line-height: 1em;\n  font-size: 1em;\n  text-align: center;\n  overflow: hidden;\n  font-family: \"Courier New\", Courier, monospace;\n  /* don't allow browser text-selection */\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none; }\n\n/*\nAcceptable font-family overrides for individual icons:\n  \"Arial\", sans-serif\n  \"Times New Roman\", serif\n\nNOTE: use percentage font sizes or else old IE chokes\n*/\n.fc-icon:after {\n  position: relative; }\n\n.fc-icon-left-single-arrow:after {\n  content: \"\\2039\";\n  font-weight: bold;\n  font-size: 200%;\n  top: -7%; }\n\n.fc-icon-right-single-arrow:after {\n  content: \"\\203A\";\n  font-weight: bold;\n  font-size: 200%;\n  top: -7%; }\n\n.fc-icon-left-double-arrow:after {\n  content: \"\\AB\";\n  font-size: 160%;\n  top: -7%; }\n\n.fc-icon-right-double-arrow:after {\n  content: \"\\BB\";\n  font-size: 160%;\n  top: -7%; }\n\n.fc-icon-left-triangle:after {\n  content: \"\\25C4\";\n  font-size: 125%;\n  top: 3%; }\n\n.fc-icon-right-triangle:after {\n  content: \"\\25BA\";\n  font-size: 125%;\n  top: 3%; }\n\n.fc-icon-down-triangle:after {\n  content: \"\\25BC\";\n  font-size: 125%;\n  top: 2%; }\n\n.fc-icon-x:after {\n  content: \"\\D7\";\n  font-size: 200%;\n  top: 6%; }\n\n/* Popover\n--------------------------------------------------------------------------------------------------*/\n.fc-unthemed .fc-popover {\n  border-width: 1px;\n  border-style: solid; }\n\n.fc-unthemed .fc-popover .fc-header .fc-close {\n  font-size: .9em;\n  margin-top: 2px; }\n\n/* List View\n--------------------------------------------------------------------------------------------------*/\n.fc-unthemed .fc-list-item:hover td {\n  background-color: #f5f5f5; }\n\n/* Colors\n--------------------------------------------------------------------------------------------------*/\n.ui-widget .fc-disabled-day {\n  background-image: none; }\n\n/* Popover\n--------------------------------------------------------------------------------------------------*/\n.fc-popover > .ui-widget-header + .ui-widget-content {\n  border-top: 0;\n  /* where they meet, let the header have the border */ }\n\n/* Global Event Styles\n--------------------------------------------------------------------------------------------------*/\n.ui-widget .fc-event {\n  /* overpower jqui's styles on <a> tags. TODO: more DRY */\n  color: #fff;\n  /* default TEXT color */\n  text-decoration: none;\n  /* if <a> has an href */\n  /* undo ui-widget-header bold */\n  font-weight: normal; }\n\n/* TimeGrid axis running down the side (for both the all-day area and the slot area)\n--------------------------------------------------------------------------------------------------*/\n.ui-widget td.fc-axis {\n  font-weight: normal;\n  /* overcome bold */ }\n\n/* TimeGrid Slats (lines that run horizontally)\n--------------------------------------------------------------------------------------------------*/\n.fc-time-grid .fc-slats .ui-widget-content {\n  background: none;\n  /* see through to fc-bg */ }\n\n.fc.fc-bootstrap3 a {\n  text-decoration: none; }\n\n.fc.fc-bootstrap3 a[data-goto]:hover {\n  text-decoration: underline; }\n\n.fc-bootstrap3 hr.fc-divider {\n  border-color: inherit; }\n\n.fc-bootstrap3 .fc-today.alert {\n  border-radius: 0; }\n\n/* Popover\n--------------------------------------------------------------------------------------------------*/\n.fc-bootstrap3 .fc-popover .panel-body {\n  padding: 0; }\n\n/* TimeGrid Slats (lines that run horizontally)\n--------------------------------------------------------------------------------------------------*/\n.fc-bootstrap3 .fc-time-grid .fc-slats table {\n  /* some themes have background color. see through to slats */\n  background: none; }\n\n.fc.fc-bootstrap4 a {\n  text-decoration: none; }\n\n.fc.fc-bootstrap4 a[data-goto]:hover {\n  text-decoration: underline; }\n\n.fc-bootstrap4 hr.fc-divider {\n  border-color: inherit; }\n\n.fc-bootstrap4 .fc-today.alert {\n  border-radius: 0; }\n\n.fc-bootstrap4 a.fc-event:not([href]):not([tabindex]) {\n  color: #fff; }\n\n.fc-bootstrap4 .fc-popover.card {\n  position: absolute; }\n\n/* Popover\n--------------------------------------------------------------------------------------------------*/\n.fc-bootstrap4 .fc-popover .card-body {\n  padding: 0; }\n\n/* TimeGrid Slats (lines that run horizontally)\n--------------------------------------------------------------------------------------------------*/\n.fc-bootstrap4 .fc-time-grid .fc-slats table {\n  /* some themes have background color. see through to slats */\n  background: none; }\n\n/* Toolbar\n--------------------------------------------------------------------------------------------------*/\n.fc-toolbar {\n  text-align: center; }\n\n.fc-toolbar.fc-header-toolbar {\n  margin-bottom: 1em; }\n\n.fc-toolbar.fc-footer-toolbar {\n  margin-top: 1em; }\n\n.fc-toolbar .fc-left {\n  float: left; }\n\n.fc-toolbar .fc-right {\n  float: right; }\n\n.fc-toolbar .fc-center {\n  display: inline-block; }\n\n/* the things within each left/right/center section */\n.fc .fc-toolbar > * > * {\n  /* extra precedence to override button border margins */\n  float: left;\n  margin-left: .75em; }\n\n/* the first thing within each left/center/right section */\n.fc .fc-toolbar > * > :first-child {\n  /* extra precedence to override button border margins */\n  margin-left: 0; }\n\n/* title text */\n.fc-toolbar h2 {\n  margin: 0; }\n\n/* button layering (for border precedence) */\n.fc-toolbar button {\n  position: relative; }\n\n.fc-toolbar .fc-state-hover,\n.fc-toolbar .ui-state-hover {\n  z-index: 2; }\n\n.fc-toolbar .fc-state-down {\n  z-index: 3; }\n\n.fc-toolbar .fc-state-active,\n.fc-toolbar .ui-state-active {\n  z-index: 4; }\n\n.fc-toolbar button:focus {\n  z-index: 5; }\n\n/* View Structure\n--------------------------------------------------------------------------------------------------*/\n/* undo twitter bootstrap's box-sizing rules. normalizes positioning techniques */\n/* don't do this for the toolbar because we'll want bootstrap to style those buttons as some pt */\n.fc-view-container *,\n.fc-view-container *:before,\n.fc-view-container *:after {\n  -webkit-box-sizing: content-box;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box; }\n\n.fc-view,\n.fc-view > table {\n  /* so dragged elements can be above the view's main element */\n  position: relative;\n  z-index: 1; }\n\n/* BasicView\n--------------------------------------------------------------------------------------------------*/\n/* day row structure */\n.fc-basicWeek-view .fc-content-skeleton,\n.fc-basicDay-view .fc-content-skeleton {\n  /* there may be week numbers in these views, so no padding-top */\n  padding-bottom: 1em;\n  /* ensure a space at bottom of cell for user selecting/clicking */ }\n\n.fc-basic-view .fc-body .fc-row {\n  min-height: 4em;\n  /* ensure that all rows are at least this tall */ }\n\n/* a \"rigid\" row will take up a constant amount of height because content-skeleton is absolute */\n.fc-row.fc-rigid {\n  overflow: hidden; }\n\n.fc-row.fc-rigid .fc-content-skeleton {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0; }\n\n/* week and day number styling */\n.fc-day-top.fc-other-month {\n  opacity: 0.3; }\n\n.fc-basic-view .fc-week-number,\n.fc-basic-view .fc-day-number {\n  padding: 2px; }\n\n.fc-basic-view th.fc-week-number,\n.fc-basic-view th.fc-day-number {\n  padding: 0 2px;\n  /* column headers can't have as much v space */ }\n\n.fc-ltr .fc-basic-view .fc-day-top .fc-day-number {\n  float: right; }\n\n.fc-rtl .fc-basic-view .fc-day-top .fc-day-number {\n  float: left; }\n\n.fc-ltr .fc-basic-view .fc-day-top .fc-week-number {\n  float: left;\n  border-radius: 0 0 3px 0; }\n\n.fc-rtl .fc-basic-view .fc-day-top .fc-week-number {\n  float: right;\n  border-radius: 0 0 0 3px; }\n\n.fc-basic-view .fc-day-top .fc-week-number {\n  min-width: 1.5em;\n  text-align: center;\n  background-color: #f2f2f2;\n  color: #808080; }\n\n/* when week/day number have own column */\n.fc-basic-view td.fc-week-number {\n  text-align: center; }\n\n.fc-basic-view td.fc-week-number > * {\n  /* work around the way we do column resizing and ensure a minimum width */\n  display: inline-block;\n  min-width: 1.25em; }\n\n/* AgendaView all-day area\n--------------------------------------------------------------------------------------------------*/\n.fc-agenda-view .fc-day-grid {\n  position: relative;\n  z-index: 2;\n  /* so the \"more..\" popover will be over the time grid */ }\n\n.fc-agenda-view .fc-day-grid .fc-row {\n  min-height: 3em;\n  /* all-day section will never get shorter than this */ }\n\n.fc-agenda-view .fc-day-grid .fc-row .fc-content-skeleton {\n  padding-bottom: 1em;\n  /* give space underneath events for clicking/selecting days */ }\n\n/* TimeGrid axis running down the side (for both the all-day area and the slot area)\n--------------------------------------------------------------------------------------------------*/\n.fc .fc-axis {\n  /* .fc to overcome default cell styles */\n  vertical-align: middle;\n  padding: 0 4px;\n  white-space: nowrap; }\n\n.fc-ltr .fc-axis {\n  text-align: right; }\n\n.fc-rtl .fc-axis {\n  text-align: left; }\n\n/* TimeGrid Structure\n--------------------------------------------------------------------------------------------------*/\n.fc-time-grid-container,\n.fc-time-grid {\n  /* so slats/bg/content/etc positions get scoped within here */\n  position: relative;\n  z-index: 1; }\n\n.fc-time-grid {\n  min-height: 100%;\n  /* so if height setting is 'auto', .fc-bg stretches to fill height */ }\n\n.fc-time-grid table {\n  /* don't put outer borders on slats/bg/content/etc */\n  border: 0 hidden transparent; }\n\n.fc-time-grid > .fc-bg {\n  z-index: 1; }\n\n.fc-time-grid .fc-slats,\n.fc-time-grid > hr {\n  /* the <hr> AgendaView injects when grid is shorter than scroller */\n  position: relative;\n  z-index: 2; }\n\n.fc-time-grid .fc-content-col {\n  position: relative;\n  /* because now-indicator lives directly inside */ }\n\n.fc-time-grid .fc-content-skeleton {\n  position: absolute;\n  z-index: 3;\n  top: 0;\n  left: 0;\n  right: 0; }\n\n/* divs within a cell within the fc-content-skeleton */\n.fc-time-grid .fc-business-container {\n  position: relative;\n  z-index: 1; }\n\n.fc-time-grid .fc-bgevent-container {\n  position: relative;\n  z-index: 2; }\n\n.fc-time-grid .fc-highlight-container {\n  position: relative;\n  z-index: 3; }\n\n.fc-time-grid .fc-event-container {\n  position: relative;\n  z-index: 4; }\n\n.fc-time-grid .fc-now-indicator-line {\n  z-index: 5; }\n\n.fc-time-grid .fc-helper-container {\n  /* also is fc-event-container */\n  position: relative;\n  z-index: 6; }\n\n/* TimeGrid Slats (lines that run horizontally)\n--------------------------------------------------------------------------------------------------*/\n.fc-time-grid .fc-slats td {\n  height: 1.5em;\n  border-bottom: 0;\n  /* each cell is responsible for its top border */ }\n\n.fc-time-grid .fc-slats .fc-minor td {\n  border-top-style: dotted; }\n\n/* TimeGrid Highlighting Slots\n--------------------------------------------------------------------------------------------------*/\n.fc-time-grid .fc-highlight-container {\n  /* a div within a cell within the fc-highlight-skeleton */\n  position: relative;\n  /* scopes the left/right of the fc-highlight to be in the column */ }\n\n.fc-time-grid .fc-highlight {\n  position: absolute;\n  left: 0;\n  right: 0;\n  /* top and bottom will be in by JS */ }\n\n/* TimeGrid Event Containment\n--------------------------------------------------------------------------------------------------*/\n.fc-ltr .fc-time-grid .fc-event-container {\n  /* space on the sides of events for LTR (default) */\n  margin: 0 2.5% 0 2px; }\n\n.fc-rtl .fc-time-grid .fc-event-container {\n  /* space on the sides of events for RTL */\n  margin: 0 2px 0 2.5%; }\n\n.fc-time-grid .fc-event,\n.fc-time-grid .fc-bgevent {\n  position: absolute;\n  z-index: 1;\n  /* scope inner z-index's */ }\n\n.fc-time-grid .fc-bgevent {\n  /* background events always span full width */\n  left: 0;\n  right: 0; }\n\n/* Generic Vertical Event\n--------------------------------------------------------------------------------------------------*/\n.fc-v-event.fc-not-start {\n  /* events that are continuing from another day */\n  /* replace space made by the top border with padding */\n  border-top-width: 0;\n  padding-top: 1px;\n  /* remove top rounded corners */\n  border-top-left-radius: 0;\n  border-top-right-radius: 0; }\n\n.fc-v-event.fc-not-end {\n  /* replace space made by the top border with padding */\n  border-bottom-width: 0;\n  padding-bottom: 1px;\n  /* remove bottom rounded corners */\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0; }\n\n/* TimeGrid Event Styling\n----------------------------------------------------------------------------------------------------\nWe use the full \"fc-time-grid-event\" class instead of using descendants because the event won't\nbe a descendant of the grid when it is being dragged.\n*/\n.fc-time-grid-event {\n  overflow: hidden;\n  /* don't let the bg flow over rounded corners */ }\n\n.fc-time-grid-event.fc-selected {\n  /* need to allow touch resizers to extend outside event's bounding box */\n  /* common fc-selected styles hide the fc-bg, so don't need this anyway */\n  overflow: visible; }\n\n.fc-time-grid-event.fc-selected .fc-bg {\n  display: none;\n  /* hide semi-white background, to appear darker */ }\n\n.fc-time-grid-event .fc-content {\n  overflow: hidden;\n  /* for when .fc-selected */ }\n\n.fc-time-grid-event .fc-time,\n.fc-time-grid-event .fc-title {\n  padding: 0 1px; }\n\n.fc-time-grid-event .fc-time {\n  font-size: .85em;\n  white-space: nowrap; }\n\n/* short mode, where time and title are on the same line */\n.fc-time-grid-event.fc-short .fc-content {\n  /* don't wrap to second line (now that contents will be inline) */\n  white-space: nowrap; }\n\n.fc-time-grid-event.fc-short .fc-time,\n.fc-time-grid-event.fc-short .fc-title {\n  /* put the time and title on the same line */\n  display: inline-block;\n  vertical-align: top; }\n\n.fc-time-grid-event.fc-short .fc-time span {\n  display: none;\n  /* don't display the full time text... */ }\n\n.fc-time-grid-event.fc-short .fc-time:before {\n  content: attr(data-start);\n  /* ...instead, display only the start time */ }\n\n.fc-time-grid-event.fc-short .fc-time:after {\n  content: \"\\A0-\\A0\";\n  /* seperate with a dash, wrapped in nbsp's */ }\n\n.fc-time-grid-event.fc-short .fc-title {\n  font-size: .85em;\n  /* make the title text the same size as the time */\n  padding: 0;\n  /* undo padding from above */ }\n\n/* resizer (cursor device) */\n.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer {\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 8px;\n  overflow: hidden;\n  line-height: 8px;\n  font-size: 11px;\n  font-family: monospace;\n  text-align: center;\n  cursor: s-resize; }\n\n.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer:after {\n  content: \"=\"; }\n\n/* resizer (touch device) */\n.fc-time-grid-event.fc-selected .fc-resizer {\n  /* 10x10 dot */\n  border-radius: 5px;\n  border-width: 1px;\n  width: 8px;\n  height: 8px;\n  border-style: solid;\n  border-color: inherit;\n  background: #fff;\n  /* horizontally center */\n  left: 50%;\n  margin-left: -5px;\n  /* center on the bottom edge */\n  bottom: -5px; }\n\n/* Now Indicator\n--------------------------------------------------------------------------------------------------*/\n.fc-time-grid .fc-now-indicator-line {\n  border-top-width: 1px;\n  left: 0;\n  right: 0; }\n\n/* arrow on axis */\n.fc-time-grid .fc-now-indicator-arrow {\n  margin-top: -5px;\n  /* vertically center on top coordinate */ }\n\n.fc-ltr .fc-time-grid .fc-now-indicator-arrow {\n  left: 0;\n  /* triangle pointing right... */\n  border-width: 5px 0 5px 6px;\n  border-top-color: transparent;\n  border-bottom-color: transparent; }\n\n.fc-rtl .fc-time-grid .fc-now-indicator-arrow {\n  right: 0;\n  /* triangle pointing left... */\n  border-width: 5px 6px 5px 0;\n  border-top-color: transparent;\n  border-bottom-color: transparent; }\n\n/* List View\n--------------------------------------------------------------------------------------------------*/\n/* possibly reusable */\n.fc-event-dot {\n  display: inline-block;\n  width: 10px;\n  height: 10px;\n  border-radius: 5px; }\n\n/* view wrapper */\n.fc-rtl .fc-list-view {\n  direction: rtl;\n  /* unlike core views, leverage browser RTL */ }\n\n.fc-list-view {\n  border-width: 1px;\n  border-style: solid; }\n\n/* table resets */\n.fc .fc-list-table {\n  table-layout: auto;\n  /* for shrinkwrapping cell content */ }\n\n.fc-list-table td {\n  border-width: 1px 0 0;\n  padding: 8px 14px; }\n\n.fc-list-table tr:first-child td {\n  border-top-width: 0; }\n\n/* day headings with the list */\n.fc-list-heading {\n  border-bottom-width: 1px; }\n\n.fc-list-heading td {\n  font-weight: bold; }\n\n.fc-ltr .fc-list-heading-main {\n  float: left; }\n\n.fc-ltr .fc-list-heading-alt {\n  float: right; }\n\n.fc-rtl .fc-list-heading-main {\n  float: right; }\n\n.fc-rtl .fc-list-heading-alt {\n  float: left; }\n\n/* event list items */\n.fc-list-item.fc-has-url {\n  cursor: pointer;\n  /* whole row will be clickable */ }\n\n.fc-list-item-marker,\n.fc-list-item-time {\n  white-space: nowrap;\n  width: 1px; }\n\n/* make the dot closer to the event title */\n.fc-ltr .fc-list-item-marker {\n  padding-right: 0; }\n\n.fc-rtl .fc-list-item-marker {\n  padding-left: 0; }\n\n.fc-list-item-title a {\n  /* every event title cell has an <a> tag */\n  text-decoration: none;\n  color: inherit; }\n\n.fc-list-item-title a[href]:hover {\n  /* hover effect only on titles with hrefs */\n  text-decoration: underline; }\n\n/* message when no events */\n.fc-list-empty-wrap2 {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0; }\n\n.fc-list-empty-wrap1 {\n  width: 100%;\n  height: 100%;\n  display: table; }\n\n.fc-list-empty {\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center; }\n\n.fc-unthemed .fc-list-empty {\n  /* theme will provide own background */\n  background-color: #eee; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/lib/loader.js?sourceMap!./vendor/cl/course/js/Calendar/_calendar.scss":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/resolve-url-loader!./node_modules/sass-loader/lib/loader.js?sourceMap!./vendor/cl/course/js/Calendar/_calendar.scss ***!
  \********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports
exports.i(__webpack_require__(/*! -!../../../../../node_modules/css-loader!fullcalendar/dist/fullcalendar.css */ "./node_modules/css-loader/index.js!./node_modules/fullcalendar/dist/fullcalendar.css"), "");

// module
exports.push([module.i, "div.cl-calendar {\n  display: none;\n  margin: 1em auto 1em auto;\n  background-color: #e8f7f3;\n  padding: 4px 4px 4px 4px;\n}\n\ndiv.cl-calendar a.fc-event {\n  background-color: #005500;\n  color: white;\n  font-size: 0.7em;\n}\n\ndiv.cl-calendar a.fc-event,\ndiv.cl-calendar a.fc-event:visited,\ndiv.cl-calendar a.fc-event:link {\n  color: white;\n  text-decoration: none;\n}\n\ndiv.cl-calendar a.fc-event:hover {\n  color: #ffcccc;\n}\n\ndiv.cl-calendar .fc-unthemed .fc-today {\n  background-color: #aaffaa;\n}\n\ndiv.cl-calendar h2 {\n  border: 0;\n}\n\ndiv.cl-calendar table {\n  -moz-box-shadow: none;\n  -webkit-box-shadow: none;\n  box-shadow: none;\n  border: none;\n  margin: 0;\n}\n\ndiv.cl-calendar table td,\ndiv.cl-calendar table th {\n  padding: 0;\n  border: 1px solid #ddd;\n}\n\ndiv.cl-calendar table tr:first-child th {\n  text-align: center;\n  padding: 0;\n}\n\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/fullcalendar/dist/fullcalendar.js":
/*!********************************************************!*\
  !*** ./node_modules/fullcalendar/dist/fullcalendar.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * FullCalendar v3.9.0
 * Docs & License: https://fullcalendar.io/
 * (c) 2018 Adam Shaw
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));
	else {}
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 236);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports) {

/*
derived from:
https://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js

only include the helpers we need, to keep down filesize
*/
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p]; };
exports.__extends = function (d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
    if (scrollbarWidths.left) {
        rowEls.css({
            'border-left-width': 1,
            'margin-left': scrollbarWidths.left - 1
        });
    }
    if (scrollbarWidths.right) {
        rowEls.css({
            'border-right-width': 1,
            'margin-right': scrollbarWidths.right - 1
        });
    }
}
exports.compensateScroll = compensateScroll;
// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
    rowEls.css({
        'margin-left': '',
        'margin-right': '',
        'border-left-width': '',
        'border-right-width': ''
    });
}
exports.uncompensateScroll = uncompensateScroll;
// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
    $('body').addClass('fc-not-allowed');
}
exports.disableCursor = disableCursor;
// Returns the mouse cursor to its original look
function enableCursor() {
    $('body').removeClass('fc-not-allowed');
}
exports.enableCursor = enableCursor;
// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {
    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
    var flexEls = []; // elements that are allowed to expand. array of DOM nodes
    var flexOffsets = []; // amount of vertical space it takes up
    var flexHeights = []; // actual css height
    var usedHeight = 0;
    undistributeHeight(els); // give all elements their natural height
    // find elements that are below the recommended height (expandable).
    // important to query for heights in a single first pass (to avoid reflow oscillation).
    els.each(function (i, el) {
        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = $(el).outerHeight(true);
        if (naturalOffset < minOffset) {
            flexEls.push(el);
            flexOffsets.push(naturalOffset);
            flexHeights.push($(el).height());
        }
        else {
            // this element stretches past recommended height (non-expandable). mark the space as occupied.
            usedHeight += naturalOffset;
        }
    });
    // readjust the recommended height to only consider the height available to non-maxed-out rows.
    if (shouldRedistribute) {
        availableHeight -= usedHeight;
        minOffset1 = Math.floor(availableHeight / flexEls.length);
        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
    }
    // assign heights to all expandable elements
    $(flexEls).each(function (i, el) {
        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = flexOffsets[i];
        var naturalHeight = flexHeights[i];
        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding
        if (naturalOffset < minOffset) {
            $(el).height(newHeight);
        }
    });
}
exports.distributeHeight = distributeHeight;
// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
    els.height('');
}
exports.undistributeHeight = undistributeHeight;
// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
    var maxInnerWidth = 0;
    els.find('> *').each(function (i, innerEl) {
        var innerWidth = $(innerEl).outerWidth();
        if (innerWidth > maxInnerWidth) {
            maxInnerWidth = innerWidth;
        }
    });
    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance
    els.width(maxInnerWidth);
    return maxInnerWidth;
}
exports.matchCellWidths = matchCellWidths;
// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
    var both = outerEl.add(innerEl);
    var diff;
    // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
    both.css({
        position: 'relative',
        left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
    });
    diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
    both.css({ position: '', left: '' }); // undo hack
    return diff;
}
exports.subtractInnerElHeight = subtractInnerElHeight;
/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/
// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
    var position = el.css('position');
    var scrollParent = el.parents().filter(function () {
        var parent = $(this);
        return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));
    }).eq(0);
    return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}
exports.getScrollParent = getScrollParent;
// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
    var offset = el.offset();
    var left = offset.left - (origin ? origin.left : 0);
    var top = offset.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.outerWidth(),
        top: top,
        bottom: top + el.outerHeight()
    };
}
exports.getOuterRect = getOuterRect;
// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
    var offset = el.offset();
    var scrollbarWidths = getScrollbarWidths(el);
    var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el[0].clientWidth,
        top: top,
        bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
    };
}
exports.getClientRect = getClientRect;
// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
    var offset = el.offset(); // just outside of border, margin not included
    var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
        (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
        (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.width(),
        top: top,
        bottom: top + el.height()
    };
}
exports.getContentRect = getContentRect;
// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
    var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
    var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
    var widths;
    leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
    bottomWidth = sanitizeScrollbarWidth(bottomWidth);
    widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };
    if (getIsLeftRtlScrollbars() && el.css('direction') === 'rtl') {
        widths.left = leftRightWidth;
    }
    else {
        widths.right = leftRightWidth;
    }
    return widths;
}
exports.getScrollbarWidths = getScrollbarWidths;
// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {
    width = Math.max(0, width); // no negatives
    width = Math.round(width);
    return width;
}
// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side
var _isLeftRtlScrollbars = null;
function getIsLeftRtlScrollbars() {
    if (_isLeftRtlScrollbars === null) {
        _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
    }
    return _isLeftRtlScrollbars;
}
function computeIsLeftRtlScrollbars() {
    var el = $('<div><div/></div>')
        .css({
        position: 'absolute',
        top: -1000,
        left: 0,
        border: 0,
        padding: 0,
        overflow: 'scroll',
        direction: 'rtl'
    })
        .appendTo('body');
    var innerEl = el.children();
    var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
    el.remove();
    return res;
}
// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
    return parseFloat(el.css(prop)) || 0;
}
/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
    return ev.which === 1 && !ev.ctrlKey;
}
exports.isPrimaryMouseButton = isPrimaryMouseButton;
function getEvX(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageX;
    }
    return ev.pageX;
}
exports.getEvX = getEvX;
function getEvY(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageY;
    }
    return ev.pageY;
}
exports.getEvY = getEvY;
function getEvIsTouch(ev) {
    return /^touch/.test(ev.type);
}
exports.getEvIsTouch = getEvIsTouch;
function preventSelection(el) {
    el.addClass('fc-unselectable')
        .on('selectstart', preventDefault);
}
exports.preventSelection = preventSelection;
function allowSelection(el) {
    el.removeClass('fc-unselectable')
        .off('selectstart', preventDefault);
}
exports.allowSelection = allowSelection;
// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
    ev.preventDefault();
}
exports.preventDefault = preventDefault;
/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/
// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
    var res = {
        left: Math.max(rect1.left, rect2.left),
        right: Math.min(rect1.right, rect2.right),
        top: Math.max(rect1.top, rect2.top),
        bottom: Math.min(rect1.bottom, rect2.bottom)
    };
    if (res.left < res.right && res.top < res.bottom) {
        return res;
    }
    return false;
}
exports.intersectRects = intersectRects;
// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
    return {
        left: Math.min(Math.max(point.left, rect.left), rect.right),
        top: Math.min(Math.max(point.top, rect.top), rect.bottom)
    };
}
exports.constrainPoint = constrainPoint;
// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
    return {
        left: (rect.left + rect.right) / 2,
        top: (rect.top + rect.bottom) / 2
    };
}
exports.getRectCenter = getRectCenter;
// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
    return {
        left: point1.left - point2.left,
        top: point1.top - point2.top
    };
}
exports.diffPoints = diffPoints;
/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/
function parseFieldSpecs(input) {
    var specs = [];
    var tokens = [];
    var i;
    var token;
    if (typeof input === 'string') {
        tokens = input.split(/\s*,\s*/);
    }
    else if (typeof input === 'function') {
        tokens = [input];
    }
    else if ($.isArray(input)) {
        tokens = input;
    }
    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        if (typeof token === 'string') {
            specs.push(token.charAt(0) === '-' ?
                { field: token.substring(1), order: -1 } :
                { field: token, order: 1 });
        }
        else if (typeof token === 'function') {
            specs.push({ func: token });
        }
    }
    return specs;
}
exports.parseFieldSpecs = parseFieldSpecs;
function compareByFieldSpecs(obj1, obj2, fieldSpecs, obj1fallback, obj2fallback) {
    var i;
    var cmp;
    for (i = 0; i < fieldSpecs.length; i++) {
        cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i], obj1fallback, obj2fallback);
        if (cmp) {
            return cmp;
        }
    }
    return 0;
}
exports.compareByFieldSpecs = compareByFieldSpecs;
function compareByFieldSpec(obj1, obj2, fieldSpec, obj1fallback, obj2fallback) {
    if (fieldSpec.func) {
        return fieldSpec.func(obj1, obj2);
    }
    var val1 = obj1[fieldSpec.field];
    var val2 = obj2[fieldSpec.field];
    if (val1 == null && obj1fallback) {
        val1 = obj1fallback[fieldSpec.field];
    }
    if (val2 == null && obj2fallback) {
        val2 = obj2fallback[fieldSpec.field];
    }
    return flexibleCompare(val1, val2) * (fieldSpec.order || 1);
}
exports.compareByFieldSpec = compareByFieldSpec;
function flexibleCompare(a, b) {
    if (!a && !b) {
        return 0;
    }
    if (b == null) {
        return -1;
    }
    if (a == null) {
        return 1;
    }
    if ($.type(a) === 'string' || $.type(b) === 'string') {
        return String(a).localeCompare(String(b));
    }
    return a - b;
}
exports.flexibleCompare = flexibleCompare;
/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/
exports.dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
exports.unitsDesc = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // descending
// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
        ms: a.time() - b.time() // time-of-day from day start. disregards timezone
    });
}
exports.diffDayTime = diffDayTime;
// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
    });
}
exports.diffDay = diffDay;
// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
    return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true
    unit);
}
exports.diffByUnit = diffByUnit;
// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeGreatestUnit(start, end) {
    var i;
    var unit;
    var val;
    for (i = 0; i < exports.unitsDesc.length; i++) {
        unit = exports.unitsDesc[i];
        val = computeRangeAs(unit, start, end);
        if (val >= 1 && isInt(val)) {
            break;
        }
    }
    return unit; // will be "milliseconds" if nothing else matches
}
exports.computeGreatestUnit = computeGreatestUnit;
// like computeGreatestUnit, but has special abilities to interpret the source input for clues
function computeDurationGreatestUnit(duration, durationInput) {
    var unit = computeGreatestUnit(duration);
    // prevent days:7 from being interpreted as a week
    if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
        unit = 'day';
    }
    return unit;
}
exports.computeDurationGreatestUnit = computeDurationGreatestUnit;
// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {
    if (end != null) {
        return end.diff(start, unit, true);
    }
    else if (moment.isDuration(start)) {
        return start.as(unit);
    }
    else {
        return start.end.diff(start.start, unit, true);
    }
}
// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
    var months;
    if (durationHasTime(dur)) {
        return (end - start) / dur;
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return end.diff(start, 'months', true) / months;
    }
    return end.diff(start, 'days', true) / dur.asDays();
}
exports.divideRangeByDuration = divideRangeByDuration;
// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
    var months1;
    var months2;
    if (durationHasTime(dur1) || durationHasTime(dur2)) {
        return dur1 / dur2;
    }
    months1 = dur1.asMonths();
    months2 = dur2.asMonths();
    if (Math.abs(months1) >= 1 && isInt(months1) &&
        Math.abs(months2) >= 1 && isInt(months2)) {
        return months1 / months2;
    }
    return dur1.asDays() / dur2.asDays();
}
exports.divideDurationByDuration = divideDurationByDuration;
// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
    var months;
    if (durationHasTime(dur)) {
        return moment.duration(dur * n);
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return moment.duration({ months: months * n });
    }
    return moment.duration({ days: dur.asDays() * n });
}
exports.multiplyDuration = multiplyDuration;
// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
    return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}
exports.durationHasTime = durationHasTime;
function isNativeDate(input) {
    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}
exports.isNativeDate = isNativeDate;
// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
    return typeof str === 'string' &&
        /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}
exports.isTimeString = isTimeString;
/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/
function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.log) {
        return console.log.apply(console, args);
    }
}
exports.log = log;
function warn() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.warn) {
        return console.warn.apply(console, args);
    }
    else {
        return log.apply(null, args);
    }
}
exports.warn = warn;
/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/
var hasOwnPropMethod = {}.hasOwnProperty;
// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
    var dest = {};
    var i;
    var name;
    var complexObjs;
    var j;
    var val;
    var props;
    if (complexProps) {
        for (i = 0; i < complexProps.length; i++) {
            name = complexProps[i];
            complexObjs = [];
            // collect the trailing object values, stopping when a non-object is discovered
            for (j = propObjs.length - 1; j >= 0; j--) {
                val = propObjs[j][name];
                if (typeof val === 'object') {
                    complexObjs.unshift(val);
                }
                else if (val !== undefined) {
                    dest[name] = val; // if there were no objects, this value will be used
                    break;
                }
            }
            // if the trailing values were objects, use the merged value
            if (complexObjs.length) {
                dest[name] = mergeProps(complexObjs);
            }
        }
    }
    // copy values into the destination, going from last to first
    for (i = propObjs.length - 1; i >= 0; i--) {
        props = propObjs[i];
        for (name in props) {
            if (!(name in dest)) {
                dest[name] = props[name];
            }
        }
    }
    return dest;
}
exports.mergeProps = mergeProps;
function copyOwnProps(src, dest) {
    for (var name_1 in src) {
        if (hasOwnProp(src, name_1)) {
            dest[name_1] = src[name_1];
        }
    }
}
exports.copyOwnProps = copyOwnProps;
function hasOwnProp(obj, name) {
    return hasOwnPropMethod.call(obj, name);
}
exports.hasOwnProp = hasOwnProp;
function applyAll(functions, thisObj, args) {
    if ($.isFunction(functions)) {
        functions = [functions];
    }
    if (functions) {
        var i = void 0;
        var ret = void 0;
        for (i = 0; i < functions.length; i++) {
            ret = functions[i].apply(thisObj, args) || ret;
        }
        return ret;
    }
}
exports.applyAll = applyAll;
function removeMatching(array, testFunc) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (testFunc(array[i])) {
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeMatching = removeMatching;
function removeExact(array, exactVal) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (array[i] === exactVal) {
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeExact = removeExact;
function isArraysEqual(a0, a1) {
    var len = a0.length;
    var i;
    if (len == null || len !== a1.length) {
        return false;
    }
    for (i = 0; i < len; i++) {
        if (a0[i] !== a1[i]) {
            return false;
        }
    }
    return true;
}
exports.isArraysEqual = isArraysEqual;
function firstDefined() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        if (args[i] !== undefined) {
            return args[i];
        }
    }
}
exports.firstDefined = firstDefined;
function htmlEscape(s) {
    return (s + '').replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/'/g, '&#039;')
        .replace(/"/g, '&quot;')
        .replace(/\n/g, '<br />');
}
exports.htmlEscape = htmlEscape;
function stripHtmlEntities(text) {
    return text.replace(/&.*?;/g, '');
}
exports.stripHtmlEntities = stripHtmlEntities;
// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
    var statements = [];
    $.each(cssProps, function (name, val) {
        if (val != null) {
            statements.push(name + ':' + val);
        }
    });
    return statements.join(';');
}
exports.cssToStr = cssToStr;
// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
    var parts = [];
    $.each(attrs, function (name, val) {
        if (val != null) {
            parts.push(name + '="' + htmlEscape(val) + '"');
        }
    });
    return parts.join(' ');
}
exports.attrsToStr = attrsToStr;
function capitaliseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.capitaliseFirstLetter = capitaliseFirstLetter;
function compareNumbers(a, b) {
    return a - b;
}
exports.compareNumbers = compareNumbers;
function isInt(n) {
    return n % 1 === 0;
}
exports.isInt = isInt;
// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
    var method = obj[methodName];
    return function () {
        return method.apply(obj, arguments);
    };
}
exports.proxy = proxy;
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
    if (immediate === void 0) { immediate = false; }
    var timeout;
    var args;
    var context;
    var timestamp;
    var result;
    var later = function () {
        var last = +new Date() - timestamp;
        if (last < wait) {
            timeout = setTimeout(later, wait - last);
        }
        else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                context = args = null;
            }
        }
    };
    return function () {
        context = this;
        args = arguments;
        timestamp = +new Date();
        var callNow = immediate && !timeout;
        if (!timeout) {
            timeout = setTimeout(later, wait);
        }
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
}
exports.debounce = debounce;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var moment_ext_1 = __webpack_require__(10);
var UnzonedRange = /** @class */ (function () {
    function UnzonedRange(startInput, endInput) {
        // TODO: move these into footprint.
        // Especially, doesn't make sense for null startMs/endMs.
        this.isStart = true;
        this.isEnd = true;
        if (moment.isMoment(startInput)) {
            startInput = startInput.clone().stripZone();
        }
        if (moment.isMoment(endInput)) {
            endInput = endInput.clone().stripZone();
        }
        if (startInput) {
            this.startMs = startInput.valueOf();
        }
        if (endInput) {
            this.endMs = endInput.valueOf();
        }
    }
    /*
    SIDEEFFECT: will mutate eventRanges.
    Will return a new array result.
    Only works for non-open-ended ranges.
    */
    UnzonedRange.invertRanges = function (ranges, constraintRange) {
        var invertedRanges = [];
        var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range
        var i;
        var dateRange;
        // ranges need to be in order. required for our date-walking algorithm
        ranges.sort(compareUnzonedRanges);
        for (i = 0; i < ranges.length; i++) {
            dateRange = ranges[i];
            // add the span of time before the event (if there is any)
            if (dateRange.startMs > startMs) {
                invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));
            }
            if (dateRange.endMs > startMs) {
                startMs = dateRange.endMs;
            }
        }
        // add the span of time after the last event (if there is any)
        if (startMs < constraintRange.endMs) {
            invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));
        }
        return invertedRanges;
    };
    UnzonedRange.prototype.intersect = function (otherRange) {
        var startMs = this.startMs;
        var endMs = this.endMs;
        var newRange = null;
        if (otherRange.startMs != null) {
            if (startMs == null) {
                startMs = otherRange.startMs;
            }
            else {
                startMs = Math.max(startMs, otherRange.startMs);
            }
        }
        if (otherRange.endMs != null) {
            if (endMs == null) {
                endMs = otherRange.endMs;
            }
            else {
                endMs = Math.min(endMs, otherRange.endMs);
            }
        }
        if (startMs == null || endMs == null || startMs < endMs) {
            newRange = new UnzonedRange(startMs, endMs);
            newRange.isStart = this.isStart && startMs === this.startMs;
            newRange.isEnd = this.isEnd && endMs === this.endMs;
        }
        return newRange;
    };
    UnzonedRange.prototype.intersectsWith = function (otherRange) {
        return (this.endMs == null || otherRange.startMs == null || this.endMs > otherRange.startMs) &&
            (this.startMs == null || otherRange.endMs == null || this.startMs < otherRange.endMs);
    };
    UnzonedRange.prototype.containsRange = function (innerRange) {
        return (this.startMs == null || (innerRange.startMs != null && innerRange.startMs >= this.startMs)) &&
            (this.endMs == null || (innerRange.endMs != null && innerRange.endMs <= this.endMs));
    };
    // `date` can be a moment, a Date, or a millisecond time.
    UnzonedRange.prototype.containsDate = function (date) {
        var ms = date.valueOf();
        return (this.startMs == null || ms >= this.startMs) &&
            (this.endMs == null || ms < this.endMs);
    };
    // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).
    // `date` can be a moment, a Date, or a millisecond time.
    // Returns a MS-time.
    UnzonedRange.prototype.constrainDate = function (date) {
        var ms = date.valueOf();
        if (this.startMs != null && ms < this.startMs) {
            ms = this.startMs;
        }
        if (this.endMs != null && ms >= this.endMs) {
            ms = this.endMs - 1;
        }
        return ms;
    };
    UnzonedRange.prototype.equals = function (otherRange) {
        return this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;
    };
    UnzonedRange.prototype.clone = function () {
        var range = new UnzonedRange(this.startMs, this.endMs);
        range.isStart = this.isStart;
        range.isEnd = this.isEnd;
        return range;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getStart = function () {
        if (this.startMs != null) {
            return moment_ext_1.default.utc(this.startMs).stripZone();
        }
        return null;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getEnd = function () {
        if (this.endMs != null) {
            return moment_ext_1.default.utc(this.endMs).stripZone();
        }
        return null;
    };
    UnzonedRange.prototype.as = function (unit) {
        return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);
    };
    return UnzonedRange;
}());
exports.default = UnzonedRange;
/*
Only works for non-open-ended ranges.
*/
function compareUnzonedRanges(range1, range2) {
    return range1.startMs - range2.startMs; // earlier ranges go first
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var ParsableModelMixin_1 = __webpack_require__(208);
var Class_1 = __webpack_require__(33);
var EventDefParser_1 = __webpack_require__(49);
var EventSource = /** @class */ (function (_super) {
    tslib_1.__extends(EventSource, _super);
    // can we do away with calendar? at least for the abstract?
    // useful for buildEventDef
    function EventSource(calendar) {
        var _this = _super.call(this) || this;
        _this.calendar = calendar;
        _this.className = [];
        _this.uid = String(EventSource.uuid++);
        return _this;
    }
    /*
    rawInput can be any data type!
    */
    EventSource.parse = function (rawInput, calendar) {
        var source = new this(calendar);
        if (typeof rawInput === 'object') {
            if (source.applyProps(rawInput)) {
                return source;
            }
        }
        return false;
    };
    EventSource.normalizeId = function (id) {
        if (id) {
            return String(id);
        }
        return null;
    };
    EventSource.prototype.fetch = function (start, end, timezone) {
        // subclasses must implement. must return a promise.
    };
    EventSource.prototype.removeEventDefsById = function (eventDefId) {
        // optional for subclasses to implement
    };
    EventSource.prototype.removeAllEventDefs = function () {
        // optional for subclasses to implement
    };
    /*
    For compairing/matching
    */
    EventSource.prototype.getPrimitive = function (otherSource) {
        // subclasses must implement
    };
    EventSource.prototype.parseEventDefs = function (rawEventDefs) {
        var i;
        var eventDef;
        var eventDefs = [];
        for (i = 0; i < rawEventDefs.length; i++) {
            eventDef = this.parseEventDef(rawEventDefs[i]);
            if (eventDef) {
                eventDefs.push(eventDef);
            }
        }
        return eventDefs;
    };
    EventSource.prototype.parseEventDef = function (rawInput) {
        var calendarTransform = this.calendar.opt('eventDataTransform');
        var sourceTransform = this.eventDataTransform;
        if (calendarTransform) {
            rawInput = calendarTransform(rawInput, this.calendar);
        }
        if (sourceTransform) {
            rawInput = sourceTransform(rawInput, this.calendar);
        }
        return EventDefParser_1.default.parse(rawInput, this);
    };
    EventSource.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventSource.normalizeId(rawProps.id);
        }
        // TODO: converge with EventDef
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        else if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    EventSource.uuid = 0;
    EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    return EventSource;
}(Class_1.default));
exports.default = EventSource;
ParsableModelMixin_1.default.mixInto(EventSource);
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
EventSource.defineStandardProps({
    // manually process...
    id: false,
    className: false,
    // automatically transfer...
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    rendering: true,
    overlap: true,
    constraint: true,
    allDayDefault: true,
    eventDataTransform: true
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.

USAGE:
  import { default as ListenerMixin, ListenerInterface } from './ListenerMixin'
in class:
  listenTo: ListenerInterface['listenTo']
  stopListeningTo: ListenerInterface['stopListeningTo']
after class:
  ListenerMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var Mixin_1 = __webpack_require__(14);
var guid = 0;
var ListenerMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ListenerMixin, _super);
    function ListenerMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
    The `callback` will be called with the `this` context of the object that .listenTo is being called on.
    Can be called:
      .listenTo(other, eventName, callback)
    OR
      .listenTo(other, {
        eventName1: callback1,
        eventName2: callback2
      })
    */
    ListenerMixin.prototype.listenTo = function (other, arg, callback) {
        if (typeof arg === 'object') {
            for (var eventName in arg) {
                if (arg.hasOwnProperty(eventName)) {
                    this.listenTo(other, eventName, arg[eventName]);
                }
            }
        }
        else if (typeof arg === 'string') {
            other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
            $.proxy(callback, this) // always use `this` context
            // the usually-undesired jQuery guid behavior doesn't matter,
            // because we always unbind via namespace
            );
        }
    };
    /*
    Causes the current object to stop listening to events on the `other` object.
    `eventName` is optional. If omitted, will stop listening to ALL events on `other`.
    */
    ListenerMixin.prototype.stopListeningTo = function (other, eventName) {
        other.off((eventName || '') + '.' + this.getListenerNamespace());
    };
    /*
    Returns a string, unique to this object, to be used for event namespacing
    */
    ListenerMixin.prototype.getListenerNamespace = function () {
        if (this.listenerId == null) {
            this.listenerId = guid++;
        }
        return '_listener' + this.listenerId;
    };
    return ListenerMixin;
}(Mixin_1.default));
exports.default = ListenerMixin;


/***/ }),
/* 8 */,
/* 9 */,
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
exports.newMomentProto = newMomentProto;
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods
exports.oldMomentProto = oldMomentProto;
// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');
/*
Call this if you want Moment's original format method to be used
*/
function oldMomentFormat(mom, formatStr) {
    return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}
exports.oldMomentFormat = oldMomentFormat;
// Creating
// -------------------------------------------------------------------------------------------------
// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
var momentExt = function () {
    return makeMoment(arguments);
};
exports.default = momentExt;
// Sames as momentExt, but forces the resulting moment to be in the UTC timezone.
momentExt.utc = function () {
    var mom = makeMoment(arguments, true);
    // Force it into UTC because makeMoment doesn't guarantee it
    // (if given a pre-existing moment for example)
    if (mom.hasTime()) {
        mom.utc();
    }
    return mom;
};
// Same as momentExt, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
momentExt.parseZone = function () {
    return makeMoment(arguments, true, true);
};
// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
    if (parseAsUTC === void 0) { parseAsUTC = false; }
    if (parseZone === void 0) { parseZone = false; }
    var input = args[0];
    var isSingleString = args.length === 1 && typeof input === 'string';
    var isAmbigTime;
    var isAmbigZone;
    var ambigMatch;
    var mom;
    if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {
        mom = moment.apply(null, args);
    }
    else {
        isAmbigTime = false;
        isAmbigZone = false;
        if (isSingleString) {
            if (ambigDateOfMonthRegex.test(input)) {
                // accept strings like '2014-05', but convert to the first of the month
                input += '-01';
                args = [input]; // for when we pass it on to moment's constructor
                isAmbigTime = true;
                isAmbigZone = true;
            }
            else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
                isAmbigTime = !ambigMatch[5]; // no time part?
                isAmbigZone = true;
            }
        }
        else if ($.isArray(input)) {
            // arrays have no timezone information, so assume ambiguous zone
            isAmbigZone = true;
        }
        // otherwise, probably a string with a format
        if (parseAsUTC || isAmbigTime) {
            mom = moment.utc.apply(moment, args);
        }
        else {
            mom = moment.apply(null, args);
        }
        if (isAmbigTime) {
            mom._ambigTime = true;
            mom._ambigZone = true; // ambiguous time always means ambiguous zone
        }
        else if (parseZone) {
            if (isAmbigZone) {
                mom._ambigZone = true;
            }
            else if (isSingleString) {
                mom.utcOffset(input); // if not a valid zone, will assign UTC
            }
        }
    }
    mom._fullCalendar = true; // flag for extended functionality
    return mom;
}
// Week Number
// -------------------------------------------------------------------------------------------------
// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function (input) {
    var weekCalc = this._locale._fullCalendar_weekCalc;
    if (input == null && typeof weekCalc === 'function') {
        return weekCalc(this);
    }
    else if (weekCalc === 'ISO') {
        return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
    }
    return oldMomentProto.week.apply(this, arguments); // local getter/setter
};
// Time-of-day
// -------------------------------------------------------------------------------------------------
// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function (time) {
    // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
    // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
    if (!this._fullCalendar) {
        return oldMomentProto.time.apply(this, arguments);
    }
    if (time == null) {
        return moment.duration({
            hours: this.hours(),
            minutes: this.minutes(),
            seconds: this.seconds(),
            milliseconds: this.milliseconds()
        });
    }
    else {
        this._ambigTime = false; // mark that the moment now has a time
        if (!moment.isDuration(time) && !moment.isMoment(time)) {
            time = moment.duration(time);
        }
        // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
        // Only for Duration times, not Moment times.
        var dayHours = 0;
        if (moment.isDuration(time)) {
            dayHours = Math.floor(time.asDays()) * 24;
        }
        // We need to set the individual fields.
        // Can't use startOf('day') then add duration. In case of DST at start of day.
        return this.hours(dayHours + time.hours())
            .minutes(time.minutes())
            .seconds(time.seconds())
            .milliseconds(time.milliseconds());
    }
};
// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function () {
    if (!this._ambigTime) {
        this.utc(true); // keepLocalTime=true (for keeping *date* value)
        // set time to zero
        this.set({
            hours: 0,
            minutes: 0,
            seconds: 0,
            ms: 0
        });
        // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears all ambig flags.
        this._ambigTime = true;
        this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
    }
    return this; // for chaining
};
// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function () {
    return !this._ambigTime;
};
// Timezone
// -------------------------------------------------------------------------------------------------
// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function () {
    var wasAmbigTime;
    if (!this._ambigZone) {
        wasAmbigTime = this._ambigTime;
        this.utc(true); // keepLocalTime=true (for keeping date and time values)
        // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
        this._ambigTime = wasAmbigTime || false;
        // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears the ambig flags.
        this._ambigZone = true;
    }
    return this; // for chaining
};
// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function () {
    return !this._ambigZone;
};
// implicitly marks a zone
newMomentProto.local = function (keepLocalTime) {
    // for when converting from ambiguously-zoned to local,
    // keep the time values when converting from UTC -> local
    oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this; // for chaining
};
// implicitly marks a zone
newMomentProto.utc = function (keepLocalTime) {
    oldMomentProto.utc.call(this, keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this;
};
// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function (tzo) {
    if (tzo != null) {
        // these assignments needs to happen before the original zone method is called.
        // I forget why, something to do with a browser crash.
        this._ambigTime = false;
        this._ambigZone = false;
    }
    return oldMomentProto.utcOffset.apply(this, arguments);
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
  import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'
in class:
  on: EmitterInterface['on']
  one: EmitterInterface['one']
  off: EmitterInterface['off']
  trigger: EmitterInterface['trigger']
  triggerWith: EmitterInterface['triggerWith']
  hasHandlers: EmitterInterface['hasHandlers']
after class:
  EmitterMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var Mixin_1 = __webpack_require__(14);
var EmitterMixin = /** @class */ (function (_super) {
    tslib_1.__extends(EmitterMixin, _super);
    function EmitterMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // jQuery-ification via $(this) allows a non-DOM object to have
    // the same event handling capabilities (including namespaces).
    EmitterMixin.prototype.on = function (types, handler) {
        $(this).on(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype.one = function (types, handler) {
        $(this).one(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype._prepareIntercept = function (handler) {
        // handlers are always called with an "event" object as their first param.
        // sneak the `this` context and arguments into the extra parameter object
        // and forward them on to the original handler.
        var intercept = function (ev, extra) {
            return handler.apply(extra.context || this, extra.args || []);
        };
        // mimick jQuery's internal "proxy" system (risky, I know)
        // causing all functions with the same .guid to appear to be the same.
        // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
        // this is needed for calling .off with the original non-intercept handler.
        if (!handler.guid) {
            handler.guid = $.guid++;
        }
        intercept.guid = handler.guid;
        return intercept;
    };
    EmitterMixin.prototype.off = function (types, handler) {
        $(this).off(types, handler);
        return this; // for chaining
    };
    EmitterMixin.prototype.trigger = function (types) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // pass in "extra" info to the intercept
        $(this).triggerHandler(types, { args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.triggerWith = function (types, context, args) {
        // `triggerHandler` is less reliant on the DOM compared to `trigger`.
        // pass in "extra" info to the intercept.
        $(this).triggerHandler(types, { context: context, args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.hasHandlers = function (type) {
        var hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/
        return hash && hash[type] && hash[type].length > 0;
    };
    return EmitterMixin;
}(Mixin_1.default));
exports.default = EmitterMixin;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
/*
Meant to be immutable
*/
var ComponentFootprint = /** @class */ (function () {
    function ComponentFootprint(unzonedRange, isAllDay) {
        this.isAllDay = false; // component can choose to ignore this
        this.unzonedRange = unzonedRange;
        this.isAllDay = isAllDay;
    }
    /*
    Only works for non-open-ended ranges.
    */
    ComponentFootprint.prototype.toLegacy = function (calendar) {
        return {
            start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),
            end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)
        };
    };
    return ComponentFootprint;
}());
exports.default = ComponentFootprint;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var EventDef_1 = __webpack_require__(34);
var EventInstance_1 = __webpack_require__(209);
var EventDateProfile_1 = __webpack_require__(17);
var SingleEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(SingleEventDef, _super);
    function SingleEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Will receive start/end params, but will be ignored.
    */
    SingleEventDef.prototype.buildInstances = function () {
        return [this.buildInstance()];
    };
    SingleEventDef.prototype.buildInstance = function () {
        return new EventInstance_1.default(this, // definition
        this.dateProfile);
    };
    SingleEventDef.prototype.isAllDay = function () {
        return this.dateProfile.isAllDay();
    };
    SingleEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        def.dateProfile = this.dateProfile;
        return def;
    };
    SingleEventDef.prototype.rezone = function () {
        var calendar = this.source.calendar;
        var dateProfile = this.dateProfile;
        this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);
    };
    /*
    NOTE: if super-method fails, should still attempt to apply
    */
    SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure
        if (dateProfile) {
            this.dateProfile = dateProfile;
            // make sure `date` shows up in the legacy event objects as-is
            if (rawProps.date != null) {
                this.miscProps.date = rawProps.date;
            }
            return superSuccess;
        }
        else {
            return false;
        }
    };
    return SingleEventDef;
}(EventDef_1.default));
exports.default = SingleEventDef;
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
SingleEventDef.defineStandardProps({
    start: false,
    date: false,
    end: false,
    allDay: false
});


/***/ }),
/* 14 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Mixin = /** @class */ (function () {
    function Mixin() {
    }
    Mixin.mixInto = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            if (!destClass.prototype[name]) {
                destClass.prototype[name] = _this.prototype[name];
            }
        });
    };
    /*
    will override existing methods
    TODO: remove! not used anymore
    */
    Mixin.mixOver = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            destClass.prototype[name] = _this.prototype[name];
        });
    };
    return Mixin;
}());
exports.default = Mixin;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Interaction = /** @class */ (function () {
    function Interaction(component) {
        this.view = component._getView();
        this.component = component;
    }
    Interaction.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    Interaction.prototype.end = function () {
        // subclasses can implement
    };
    return Interaction;
}());
exports.default = Interaction;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.version = '3.9.0';
// When introducing internal API incompatibilities (where fullcalendar plugins would break),
// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
// and the below integer should be incremented.
exports.internalApiVersion = 12;
var util_1 = __webpack_require__(4);
exports.applyAll = util_1.applyAll;
exports.debounce = util_1.debounce;
exports.isInt = util_1.isInt;
exports.htmlEscape = util_1.htmlEscape;
exports.cssToStr = util_1.cssToStr;
exports.proxy = util_1.proxy;
exports.capitaliseFirstLetter = util_1.capitaliseFirstLetter;
exports.getOuterRect = util_1.getOuterRect;
exports.getClientRect = util_1.getClientRect;
exports.getContentRect = util_1.getContentRect;
exports.getScrollbarWidths = util_1.getScrollbarWidths;
exports.preventDefault = util_1.preventDefault;
exports.parseFieldSpecs = util_1.parseFieldSpecs;
exports.compareByFieldSpecs = util_1.compareByFieldSpecs;
exports.compareByFieldSpec = util_1.compareByFieldSpec;
exports.flexibleCompare = util_1.flexibleCompare;
exports.computeGreatestUnit = util_1.computeGreatestUnit;
exports.divideRangeByDuration = util_1.divideRangeByDuration;
exports.divideDurationByDuration = util_1.divideDurationByDuration;
exports.multiplyDuration = util_1.multiplyDuration;
exports.durationHasTime = util_1.durationHasTime;
exports.log = util_1.log;
exports.warn = util_1.warn;
exports.removeExact = util_1.removeExact;
exports.intersectRects = util_1.intersectRects;
var date_formatting_1 = __webpack_require__(47);
exports.formatDate = date_formatting_1.formatDate;
exports.formatRange = date_formatting_1.formatRange;
exports.queryMostGranularFormatUnit = date_formatting_1.queryMostGranularFormatUnit;
var locale_1 = __webpack_require__(31);
exports.datepickerLocale = locale_1.datepickerLocale;
exports.locale = locale_1.locale;
var moment_ext_1 = __webpack_require__(10);
exports.moment = moment_ext_1.default;
var EmitterMixin_1 = __webpack_require__(11);
exports.EmitterMixin = EmitterMixin_1.default;
var ListenerMixin_1 = __webpack_require__(7);
exports.ListenerMixin = ListenerMixin_1.default;
var Model_1 = __webpack_require__(48);
exports.Model = Model_1.default;
var Constraints_1 = __webpack_require__(207);
exports.Constraints = Constraints_1.default;
var UnzonedRange_1 = __webpack_require__(5);
exports.UnzonedRange = UnzonedRange_1.default;
var ComponentFootprint_1 = __webpack_require__(12);
exports.ComponentFootprint = ComponentFootprint_1.default;
var BusinessHourGenerator_1 = __webpack_require__(212);
exports.BusinessHourGenerator = BusinessHourGenerator_1.default;
var EventDef_1 = __webpack_require__(34);
exports.EventDef = EventDef_1.default;
var EventDefMutation_1 = __webpack_require__(37);
exports.EventDefMutation = EventDefMutation_1.default;
var EventSourceParser_1 = __webpack_require__(38);
exports.EventSourceParser = EventSourceParser_1.default;
var EventSource_1 = __webpack_require__(6);
exports.EventSource = EventSource_1.default;
var ThemeRegistry_1 = __webpack_require__(51);
exports.defineThemeSystem = ThemeRegistry_1.defineThemeSystem;
var EventInstanceGroup_1 = __webpack_require__(18);
exports.EventInstanceGroup = EventInstanceGroup_1.default;
var ArrayEventSource_1 = __webpack_require__(52);
exports.ArrayEventSource = ArrayEventSource_1.default;
var FuncEventSource_1 = __webpack_require__(215);
exports.FuncEventSource = FuncEventSource_1.default;
var JsonFeedEventSource_1 = __webpack_require__(216);
exports.JsonFeedEventSource = JsonFeedEventSource_1.default;
var EventFootprint_1 = __webpack_require__(36);
exports.EventFootprint = EventFootprint_1.default;
var Class_1 = __webpack_require__(33);
exports.Class = Class_1.default;
var Mixin_1 = __webpack_require__(14);
exports.Mixin = Mixin_1.default;
var CoordCache_1 = __webpack_require__(53);
exports.CoordCache = CoordCache_1.default;
var DragListener_1 = __webpack_require__(54);
exports.DragListener = DragListener_1.default;
var Promise_1 = __webpack_require__(20);
exports.Promise = Promise_1.default;
var TaskQueue_1 = __webpack_require__(217);
exports.TaskQueue = TaskQueue_1.default;
var RenderQueue_1 = __webpack_require__(218);
exports.RenderQueue = RenderQueue_1.default;
var Scroller_1 = __webpack_require__(39);
exports.Scroller = Scroller_1.default;
var Theme_1 = __webpack_require__(19);
exports.Theme = Theme_1.default;
var DateComponent_1 = __webpack_require__(219);
exports.DateComponent = DateComponent_1.default;
var InteractiveDateComponent_1 = __webpack_require__(40);
exports.InteractiveDateComponent = InteractiveDateComponent_1.default;
var Calendar_1 = __webpack_require__(220);
exports.Calendar = Calendar_1.default;
var View_1 = __webpack_require__(41);
exports.View = View_1.default;
var ViewRegistry_1 = __webpack_require__(22);
exports.defineView = ViewRegistry_1.defineView;
exports.getViewConfig = ViewRegistry_1.getViewConfig;
var DayTableMixin_1 = __webpack_require__(55);
exports.DayTableMixin = DayTableMixin_1.default;
var BusinessHourRenderer_1 = __webpack_require__(56);
exports.BusinessHourRenderer = BusinessHourRenderer_1.default;
var EventRenderer_1 = __webpack_require__(42);
exports.EventRenderer = EventRenderer_1.default;
var FillRenderer_1 = __webpack_require__(57);
exports.FillRenderer = FillRenderer_1.default;
var HelperRenderer_1 = __webpack_require__(58);
exports.HelperRenderer = HelperRenderer_1.default;
var ExternalDropping_1 = __webpack_require__(222);
exports.ExternalDropping = ExternalDropping_1.default;
var EventResizing_1 = __webpack_require__(223);
exports.EventResizing = EventResizing_1.default;
var EventPointing_1 = __webpack_require__(59);
exports.EventPointing = EventPointing_1.default;
var EventDragging_1 = __webpack_require__(224);
exports.EventDragging = EventDragging_1.default;
var DateSelecting_1 = __webpack_require__(225);
exports.DateSelecting = DateSelecting_1.default;
var StandardInteractionsMixin_1 = __webpack_require__(60);
exports.StandardInteractionsMixin = StandardInteractionsMixin_1.default;
var AgendaView_1 = __webpack_require__(226);
exports.AgendaView = AgendaView_1.default;
var TimeGrid_1 = __webpack_require__(227);
exports.TimeGrid = TimeGrid_1.default;
var DayGrid_1 = __webpack_require__(61);
exports.DayGrid = DayGrid_1.default;
var BasicView_1 = __webpack_require__(62);
exports.BasicView = BasicView_1.default;
var MonthView_1 = __webpack_require__(229);
exports.MonthView = MonthView_1.default;
var ListView_1 = __webpack_require__(230);
exports.ListView = ListView_1.default;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(5);
/*
Meant to be immutable
*/
var EventDateProfile = /** @class */ (function () {
    function EventDateProfile(start, end, calendar) {
        this.start = start;
        this.end = end || null;
        this.unzonedRange = this.buildUnzonedRange(calendar);
    }
    /*
    Needs an EventSource object
    */
    EventDateProfile.parse = function (rawProps, source) {
        var startInput = rawProps.start || rawProps.date;
        var endInput = rawProps.end;
        if (!startInput) {
            return false;
        }
        var calendar = source.calendar;
        var start = calendar.moment(startInput);
        var end = endInput ? calendar.moment(endInput) : null;
        var forcedAllDay = rawProps.allDay;
        var forceEventDuration = calendar.opt('forceEventDuration');
        if (!start.isValid()) {
            return false;
        }
        if (end && (!end.isValid() || !end.isAfter(start))) {
            end = null;
        }
        if (forcedAllDay == null) {
            forcedAllDay = source.allDayDefault;
            if (forcedAllDay == null) {
                forcedAllDay = calendar.opt('allDayDefault');
            }
        }
        if (forcedAllDay === true) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else if (forcedAllDay === false) {
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        if (!end && forceEventDuration) {
            end = calendar.getDefaultEventEnd(!start.hasTime(), start);
        }
        return new EventDateProfile(start, end, calendar);
    };
    EventDateProfile.isStandardProp = function (propName) {
        return propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';
    };
    EventDateProfile.prototype.isAllDay = function () {
        return !(this.start.hasTime() || (this.end && this.end.hasTime()));
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.buildUnzonedRange = function (calendar) {
        var startMs = this.start.clone().stripZone().valueOf();
        var endMs = this.getEnd(calendar).stripZone().valueOf();
        return new UnzonedRange_1.default(startMs, endMs);
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.getEnd = function (calendar) {
        return this.end ?
            this.end.clone() :
            // derive the end from the start and allDay. compute allDay if necessary
            calendar.getDefaultEventEnd(this.isAllDay(), this.start);
    };
    return EventDateProfile;
}());
exports.default = EventDateProfile;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(5);
var util_1 = __webpack_require__(35);
var EventRange_1 = __webpack_require__(211);
/*
It's expected that there will be at least one EventInstance,
OR that an explicitEventDef is assigned.
*/
var EventInstanceGroup = /** @class */ (function () {
    function EventInstanceGroup(eventInstances) {
        this.eventInstances = eventInstances || [];
    }
    EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {
        if (constraintRange) {
            return this.sliceNormalRenderRanges(constraintRange);
        }
        else {
            return this.eventInstances.map(util_1.eventInstanceToEventRange);
        }
    };
    EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {
        if (this.isInverse()) {
            return this.sliceInverseRenderRanges(constraintRange);
        }
        else {
            return this.sliceNormalRenderRanges(constraintRange);
        }
    };
    EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {
        var eventInstances = this.eventInstances;
        var i;
        var eventInstance;
        var slicedRange;
        var slicedEventRanges = [];
        for (i = 0; i < eventInstances.length; i++) {
            eventInstance = eventInstances[i];
            slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);
            if (slicedRange) {
                slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));
            }
        }
        return slicedEventRanges;
    };
    EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {
        var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);
        var ownerDef = this.getEventDef();
        unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);
        return unzonedRanges.map(function (unzonedRange) {
            return new EventRange_1.default(unzonedRange, ownerDef); // don't give an EventInstance
        });
    };
    EventInstanceGroup.prototype.isInverse = function () {
        return this.getEventDef().hasInverseRendering();
    };
    EventInstanceGroup.prototype.getEventDef = function () {
        return this.explicitEventDef || this.eventInstances[0].def;
    };
    return EventInstanceGroup;
}());
exports.default = EventInstanceGroup;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var Theme = /** @class */ (function () {
    function Theme(optionsManager) {
        this.optionsManager = optionsManager;
        this.processIconOverride();
    }
    Theme.prototype.processIconOverride = function () {
        if (this.iconOverrideOption) {
            this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));
        }
    };
    Theme.prototype.setIconOverride = function (iconOverrideHash) {
        var iconClassesCopy;
        var buttonName;
        if ($.isPlainObject(iconOverrideHash)) {
            iconClassesCopy = $.extend({}, this.iconClasses);
            for (buttonName in iconOverrideHash) {
                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
            }
            this.iconClasses = iconClassesCopy;
        }
        else if (iconOverrideHash === false) {
            this.iconClasses = {};
        }
    };
    Theme.prototype.applyIconOverridePrefix = function (className) {
        var prefix = this.iconOverridePrefix;
        if (prefix && className.indexOf(prefix) !== 0) {
            className = prefix + className;
        }
        return className;
    };
    Theme.prototype.getClass = function (key) {
        return this.classes[key] || '';
    };
    Theme.prototype.getIconClass = function (buttonName) {
        var className = this.iconClasses[buttonName];
        if (className) {
            return this.baseIconClass + ' ' + className;
        }
        return '';
    };
    Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
        var className;
        if (this.iconOverrideCustomButtonOption) {
            className = customButtonProps[this.iconOverrideCustomButtonOption];
            if (className) {
                return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);
            }
        }
        return '';
    };
    return Theme;
}());
exports.default = Theme;
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = '';
Theme.prototype.iconOverridePrefix = '';


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var PromiseStub = {
    construct: function (executor) {
        var deferred = $.Deferred();
        var promise = deferred.promise();
        if (typeof executor === 'function') {
            executor(function (val) {
                deferred.resolve(val);
                attachImmediatelyResolvingThen(promise, val);
            }, function () {
                deferred.reject();
                attachImmediatelyRejectingThen(promise);
            });
        }
        return promise;
    },
    resolve: function (val) {
        var deferred = $.Deferred().resolve(val);
        var promise = deferred.promise();
        attachImmediatelyResolvingThen(promise, val);
        return promise;
    },
    reject: function () {
        var deferred = $.Deferred().reject();
        var promise = deferred.promise();
        attachImmediatelyRejectingThen(promise);
        return promise;
    }
};
exports.default = PromiseStub;
function attachImmediatelyResolvingThen(promise, val) {
    promise.then = function (onResolve) {
        if (typeof onResolve === 'function') {
            return PromiseStub.resolve(onResolve(val));
        }
        return promise;
    };
}
function attachImmediatelyRejectingThen(promise) {
    promise.then = function (onResolve, onReject) {
        if (typeof onReject === 'function') {
            onReject();
        }
        return promise;
    };
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var exportHooks = __webpack_require__(16);
var EmitterMixin_1 = __webpack_require__(11);
var ListenerMixin_1 = __webpack_require__(7);
exportHooks.touchMouseIgnoreWait = 500;
var globalEmitter = null;
var neededCount = 0;
/*
Listens to document and window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter.
Best when used as a singleton via GlobalEmitter.get()

Normalizes mouse/touch events. For examples:
- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
- compensates for various buggy scenarios where a touchend does not fire
*/
var GlobalEmitter = /** @class */ (function () {
    function GlobalEmitter() {
        this.isTouching = false;
        this.mouseIgnoreDepth = 0;
    }
    // gets the singleton
    GlobalEmitter.get = function () {
        if (!globalEmitter) {
            globalEmitter = new GlobalEmitter();
            globalEmitter.bind();
        }
        return globalEmitter;
    };
    // called when an object knows it will need a GlobalEmitter in the near future.
    GlobalEmitter.needed = function () {
        GlobalEmitter.get(); // ensures globalEmitter
        neededCount++;
    };
    // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
    GlobalEmitter.unneeded = function () {
        neededCount--;
        if (!neededCount) {
            globalEmitter.unbind();
            globalEmitter = null;
        }
    };
    GlobalEmitter.prototype.bind = function () {
        var _this = this;
        this.listenTo($(document), {
            touchstart: this.handleTouchStart,
            touchcancel: this.handleTouchCancel,
            touchend: this.handleTouchEnd,
            mousedown: this.handleMouseDown,
            mousemove: this.handleMouseMove,
            mouseup: this.handleMouseUp,
            click: this.handleClick,
            selectstart: this.handleSelectStart,
            contextmenu: this.handleContextMenu
        });
        // because we need to call preventDefault
        // because https://www.chromestatus.com/features/5093566007214080
        // TODO: investigate performance because this is a global handler
        window.addEventListener('touchmove', this.handleTouchMoveProxy = function (ev) {
            _this.handleTouchMove($.Event(ev));
        }, { passive: false } // allows preventDefault()
        );
        // attach a handler to get called when ANY scroll action happens on the page.
        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
        // http://stackoverflow.com/a/32954565/96342
        window.addEventListener('scroll', this.handleScrollProxy = function (ev) {
            _this.handleScroll($.Event(ev));
        }, true // useCapture
        );
    };
    GlobalEmitter.prototype.unbind = function () {
        this.stopListeningTo($(document));
        window.removeEventListener('touchmove', this.handleTouchMoveProxy);
        window.removeEventListener('scroll', this.handleScrollProxy, true // useCapture
        );
    };
    // Touch Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleTouchStart = function (ev) {
        // if a previous touch interaction never ended with a touchend, then implicitly end it,
        // but since a new touch interaction is about to begin, don't start the mouse ignore period.
        this.stopTouch(ev, true); // skipMouseIgnore=true
        this.isTouching = true;
        this.trigger('touchstart', ev);
    };
    GlobalEmitter.prototype.handleTouchMove = function (ev) {
        if (this.isTouching) {
            this.trigger('touchmove', ev);
        }
    };
    GlobalEmitter.prototype.handleTouchCancel = function (ev) {
        if (this.isTouching) {
            this.trigger('touchcancel', ev);
            // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
            // If touchend fires later, it won't have any effect b/c isTouching will be false.
            this.stopTouch(ev);
        }
    };
    GlobalEmitter.prototype.handleTouchEnd = function (ev) {
        this.stopTouch(ev);
    };
    // Mouse Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleMouseDown = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousedown', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseMove = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousemove', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseUp = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mouseup', ev);
        }
    };
    GlobalEmitter.prototype.handleClick = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('click', ev);
        }
    };
    // Misc Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleSelectStart = function (ev) {
        this.trigger('selectstart', ev);
    };
    GlobalEmitter.prototype.handleContextMenu = function (ev) {
        this.trigger('contextmenu', ev);
    };
    GlobalEmitter.prototype.handleScroll = function (ev) {
        this.trigger('scroll', ev);
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {
        if (skipMouseIgnore === void 0) { skipMouseIgnore = false; }
        if (this.isTouching) {
            this.isTouching = false;
            this.trigger('touchend', ev);
            if (!skipMouseIgnore) {
                this.startTouchMouseIgnore();
            }
        }
    };
    GlobalEmitter.prototype.startTouchMouseIgnore = function () {
        var _this = this;
        var wait = exportHooks.touchMouseIgnoreWait;
        if (wait) {
            this.mouseIgnoreDepth++;
            setTimeout(function () {
                _this.mouseIgnoreDepth--;
            }, wait);
        }
    };
    GlobalEmitter.prototype.shouldIgnoreMouse = function () {
        return this.isTouching || Boolean(this.mouseIgnoreDepth);
    };
    return GlobalEmitter;
}());
exports.default = GlobalEmitter;
ListenerMixin_1.default.mixInto(GlobalEmitter);
EmitterMixin_1.default.mixInto(GlobalEmitter);


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var exportHooks = __webpack_require__(16);
exports.viewHash = {};
exportHooks.views = exports.viewHash;
function defineView(viewName, viewConfig) {
    exports.viewHash[viewName] = viewConfig;
}
exports.defineView = defineView;
function getViewConfig(viewName) {
    return exports.viewHash[viewName];
}
exports.getViewConfig = getViewConfig;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var DragListener_1 = __webpack_require__(54);
/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/
var HitDragListener = /** @class */ (function (_super) {
    tslib_1.__extends(HitDragListener, _super);
    function HitDragListener(component, options) {
        var _this = _super.call(this, options) || this;
        _this.component = component;
        return _this;
    }
    // Called when drag listening starts (but a real drag has not necessarily began).
    // ev might be undefined if dragging was started manually.
    HitDragListener.prototype.handleInteractionStart = function (ev) {
        var subjectEl = this.subjectEl;
        var subjectRect;
        var origPoint;
        var point;
        this.component.hitsNeeded();
        this.computeScrollBounds(); // for autoscroll
        if (ev) {
            origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };
            point = origPoint;
            // constrain the point to bounds of the element being dragged
            if (subjectEl) {
                subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well
                point = util_1.constrainPoint(point, subjectRect);
            }
            this.origHit = this.queryHit(point.left, point.top);
            // treat the center of the subject as the collision point?
            if (subjectEl && this.options.subjectCenter) {
                // only consider the area the subject overlaps the hit. best for large subjects.
                // TODO: skip this if hit didn't supply left/right/top/bottom
                if (this.origHit) {
                    subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||
                        subjectRect; // in case there is no intersection
                }
                point = util_1.getRectCenter(subjectRect);
            }
            this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint
        }
        else {
            this.origHit = null;
            this.coordAdjust = null;
        }
        // call the super-method. do it after origHit has been computed
        _super.prototype.handleInteractionStart.call(this, ev);
    };
    // Called when the actual drag has started
    HitDragListener.prototype.handleDragStart = function (ev) {
        var hit;
        _super.prototype.handleDragStart.call(this, ev);
        // might be different from this.origHit if the min-distance is large
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        // report the initial hit the mouse is over
        // especially important if no min-distance and drag starts immediately
        if (hit) {
            this.handleHitOver(hit);
        }
    };
    // Called when the drag moves
    HitDragListener.prototype.handleDrag = function (dx, dy, ev) {
        var hit;
        _super.prototype.handleDrag.call(this, dx, dy, ev);
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        if (!isHitsEqual(hit, this.hit)) {
            if (this.hit) {
                this.handleHitOut();
            }
            if (hit) {
                this.handleHitOver(hit);
            }
        }
    };
    // Called when dragging has been stopped
    HitDragListener.prototype.handleDragEnd = function (ev) {
        this.handleHitDone();
        _super.prototype.handleDragEnd.call(this, ev);
    };
    // Called when a the mouse has just moved over a new hit
    HitDragListener.prototype.handleHitOver = function (hit) {
        var isOrig = isHitsEqual(hit, this.origHit);
        this.hit = hit;
        this.trigger('hitOver', this.hit, isOrig, this.origHit);
    };
    // Called when the mouse has just moved out of a hit
    HitDragListener.prototype.handleHitOut = function () {
        if (this.hit) {
            this.trigger('hitOut', this.hit);
            this.handleHitDone();
            this.hit = null;
        }
    };
    // Called after a hitOut. Also called before a dragStop
    HitDragListener.prototype.handleHitDone = function () {
        if (this.hit) {
            this.trigger('hitDone', this.hit);
        }
    };
    // Called when the interaction ends, whether there was a real drag or not
    HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);
        this.origHit = null;
        this.hit = null;
        this.component.hitsNotNeeded();
    };
    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    HitDragListener.prototype.handleScrollEnd = function () {
        _super.prototype.handleScrollEnd.call(this);
        // hits' absolute positions will be in new places after a user's scroll.
        // HACK for recomputing.
        if (this.isDragging) {
            this.component.releaseHits();
            this.component.prepareHits();
        }
    };
    // Gets the hit underneath the coordinates for the given mouse event
    HitDragListener.prototype.queryHit = function (left, top) {
        if (this.coordAdjust) {
            left += this.coordAdjust.left;
            top += this.coordAdjust.top;
        }
        return this.component.queryHit(left, top);
    };
    return HitDragListener;
}(DragListener_1.default));
exports.default = HitDragListener;
// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {
    if (!hit0 && !hit1) {
        return true;
    }
    if (hit0 && hit1) {
        return hit0.component === hit1.component &&
            isHitPropsWithin(hit0, hit1) &&
            isHitPropsWithin(hit1, hit0); // ensures all props are identical
    }
    return false;
}
// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
    for (var propName in subHit) {
        if (!/^(component|left|right|top|bottom)$/.test(propName)) {
            if (subHit[propName] !== superHit[propName]) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var exportHooks = __webpack_require__(16);
var options_1 = __webpack_require__(32);
var util_1 = __webpack_require__(4);
exports.localeOptionHash = {};
exportHooks.locales = exports.localeOptionHash;
// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {
    buttonText: function (dpOptions) {
        return {
            // the translations sometimes wrongly contain HTML entities
            prev: util_1.stripHtmlEntities(dpOptions.prevText),
            next: util_1.stripHtmlEntities(dpOptions.nextText),
            today: util_1.stripHtmlEntities(dpOptions.currentText)
        };
    },
    // Produces format strings like "MMMM YYYY" -> "September 2014"
    monthYearFormat: function (dpOptions) {
        return dpOptions.showMonthAfterYear ?
            'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
            'MMMM YYYY[' + dpOptions.yearSuffix + ']';
    }
};
var momComputableOptions = {
    // Produces format strings like "ddd M/D" -> "Fri 9/15"
    dayOfMonthFormat: function (momOptions, fcOptions) {
        var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"
        // strip the year off the edge, as well as other misc non-whitespace chars
        format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');
        if (fcOptions.isRTL) {
            format += ' ddd'; // for RTL, add day-of-week to end
        }
        else {
            format = 'ddd ' + format; // for LTR, add day-of-week to beginning
        }
        return format;
    },
    // Produces format strings like "h:mma" -> "6:00pm"
    mediumTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
    smallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
    extraSmallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
    },
    // Produces format strings like "ha" / "H" -> "6pm" / "18"
    hourFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '')
            .replace(/(\Wmm)$/, '') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
    noMeridiemTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, ''); // remove trailing AM/PM
    }
};
// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {
    // Produces format strings for results like "Mo 16"
    smallDayDateFormat: function (options) {
        return options.isRTL ?
            'D dd' :
            'dd D';
    },
    // Produces format strings for results like "Wk 5"
    weekFormat: function (options) {
        return options.isRTL ?
            'w[ ' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ' ]w';
    },
    // Produces format strings for results like "Wk5"
    smallWeekFormat: function (options) {
        return options.isRTL ?
            'w[' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ']w';
    }
};
// TODO: make these computable properties in optionsManager
function populateInstanceComputableOptions(options) {
    $.each(instanceComputableOptions, function (name, func) {
        if (options[name] == null) {
            options[name] = func(options);
        }
    });
}
exports.populateInstanceComputableOptions = populateInstanceComputableOptions;
// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
function datepickerLocale(localeCode, dpLocaleCode, dpOptions) {
    // get the FullCalendar internal option hash for this locale. create if necessary
    var fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});
    // transfer some simple options from datepicker to fc
    fcOptions.isRTL = dpOptions.isRTL;
    fcOptions.weekNumberTitle = dpOptions.weekHeader;
    // compute some more complex options from datepicker
    $.each(dpComputableOptions, function (name, func) {
        fcOptions[name] = func(dpOptions);
    });
    var jqDatePicker = $.datepicker;
    // is jQuery UI Datepicker is on the page?
    if (jqDatePicker) {
        // Register the locale data.
        // FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
        // does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
        // Make an alias so the locale can be referenced either way.
        jqDatePicker.regional[dpLocaleCode] =
            jqDatePicker.regional[localeCode] = // alias
                dpOptions;
        // Alias 'en' to the default locale data. Do this every time.
        jqDatePicker.regional.en = jqDatePicker.regional[''];
        // Set as Datepicker's global defaults.
        jqDatePicker.setDefaults(dpOptions);
    }
}
exports.datepickerLocale = datepickerLocale;
// Sets FullCalendar-specific translations. Will set the locales as the global default.
function locale(localeCode, newFcOptions) {
    var fcOptions;
    var momOptions;
    // get the FullCalendar internal option hash for this locale. create if necessary
    fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});
    // provided new options for this locales? merge them in
    if (newFcOptions) {
        fcOptions = exports.localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);
    }
    // compute locale options that weren't defined.
    // always do this. newFcOptions can be undefined when initializing from i18n file,
    // so no way to tell if this is an initialization or a default-setting.
    momOptions = getMomentLocaleData(localeCode); // will fall back to en
    $.each(momComputableOptions, function (name, func) {
        if (fcOptions[name] == null) {
            fcOptions[name] = (func)(momOptions, fcOptions);
        }
    });
    // set it as the default locale for FullCalendar
    options_1.globalDefaults.locale = localeCode;
}
exports.locale = locale;
// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
    return moment.localeData(localeCode) || moment.localeData('en');
}
exports.getMomentLocaleData = getMomentLocaleData;
// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
locale('en', options_1.englishDefaults);


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(4);
exports.globalDefaults = {
    titleRangeSeparator: ' \u2013 ',
    monthYearFormat: 'MMMM YYYY',
    defaultTimedEventDuration: '02:00:00',
    defaultAllDayEventDuration: { days: 1 },
    forceEventDuration: false,
    nextDayThreshold: '09:00:00',
    // display
    columnHeader: true,
    defaultView: 'month',
    aspectRatio: 1.35,
    header: {
        left: 'title',
        center: '',
        right: 'today prev,next'
    },
    weekends: true,
    weekNumbers: false,
    weekNumberTitle: 'W',
    weekNumberCalculation: 'local',
    // editable: false,
    // nowIndicator: false,
    scrollTime: '06:00:00',
    minTime: '00:00:00',
    maxTime: '24:00:00',
    showNonCurrentDates: true,
    // event ajax
    lazyFetching: true,
    startParam: 'start',
    endParam: 'end',
    timezoneParam: 'timezone',
    timezone: false,
    // allDayDefault: undefined,
    // locale
    locale: null,
    isRTL: false,
    buttonText: {
        prev: 'prev',
        next: 'next',
        prevYear: 'prev year',
        nextYear: 'next year',
        year: 'year',
        today: 'today',
        month: 'month',
        week: 'week',
        day: 'day'
    },
    // buttonIcons: null,
    allDayText: 'all-day',
    // allows setting a min-height to the event segment to prevent short events overlapping each other
    agendaEventMinHeight: 0,
    // jquery-ui theming
    theme: false,
    // themeButtonIcons: null,
    // eventResizableFromStart: false,
    dragOpacity: .75,
    dragRevertDuration: 500,
    dragScroll: true,
    // selectable: false,
    unselectAuto: true,
    // selectMinDistance: 0,
    dropAccept: '*',
    eventOrder: 'title',
    // eventRenderWait: null,
    eventLimit: false,
    eventLimitText: 'more',
    eventLimitClick: 'popover',
    dayPopoverFormat: 'LL',
    handleWindowResize: true,
    windowResizeDelay: 100,
    longPressDelay: 1000
};
exports.englishDefaults = {
    dayPopoverFormat: 'dddd, MMMM D'
};
exports.rtlDefaults = {
    header: {
        left: 'next,prev today',
        center: '',
        right: 'title'
    },
    buttonIcons: {
        prev: 'right-single-arrow',
        next: 'left-single-arrow',
        prevYear: 'right-double-arrow',
        nextYear: 'left-double-arrow'
    },
    themeButtonIcons: {
        prev: 'circle-triangle-e',
        next: 'circle-triangle-w',
        nextYear: 'seek-prev',
        prevYear: 'seek-next'
    }
};
var complexOptions = [
    'header',
    'footer',
    'buttonText',
    'buttonIcons',
    'themeButtonIcons'
];
// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
    return util_1.mergeProps(optionObjs, complexOptions);
}
exports.mergeOptions = mergeOptions;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
// Class that all other classes will inherit from
var Class = /** @class */ (function () {
    function Class() {
    }
    // Called on a class to create a subclass.
    // LIMITATION: cannot provide a constructor!
    Class.extend = function (members) {
        var SubClass = /** @class */ (function (_super) {
            tslib_1.__extends(SubClass, _super);
            function SubClass() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return SubClass;
        }(this));
        util_1.copyOwnProps(members, SubClass.prototype);
        return SubClass;
    };
    // Adds new member variables/methods to the class's prototype.
    // Can be called with another class, or a plain object hash containing new members.
    Class.mixin = function (members) {
        util_1.copyOwnProps(members, this.prototype);
    };
    return Class;
}());
exports.default = Class;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var ParsableModelMixin_1 = __webpack_require__(208);
var EventDef = /** @class */ (function () {
    function EventDef(source) {
        this.source = source;
        this.className = [];
        this.miscProps = {};
    }
    EventDef.parse = function (rawInput, source) {
        var def = new this(source);
        if (def.applyProps(rawInput)) {
            return def;
        }
        return false;
    };
    EventDef.normalizeId = function (id) {
        return String(id);
    };
    EventDef.generateId = function () {
        return '_fc' + (EventDef.uuid++);
    };
    EventDef.prototype.clone = function () {
        var copy = new this.constructor(this.source);
        copy.id = this.id;
        copy.rawId = this.rawId;
        copy.uid = this.uid; // not really unique anymore :(
        EventDef.copyVerbatimStandardProps(this, copy);
        copy.className = this.className.slice(); // copy
        copy.miscProps = $.extend({}, this.miscProps);
        return copy;
    };
    EventDef.prototype.hasInverseRendering = function () {
        return this.getRendering() === 'inverse-background';
    };
    EventDef.prototype.hasBgRendering = function () {
        var rendering = this.getRendering();
        return rendering === 'inverse-background' || rendering === 'background';
    };
    EventDef.prototype.getRendering = function () {
        if (this.rendering != null) {
            return this.rendering;
        }
        return this.source.rendering;
    };
    EventDef.prototype.getConstraint = function () {
        if (this.constraint != null) {
            return this.constraint;
        }
        if (this.source.constraint != null) {
            return this.source.constraint;
        }
        return this.source.calendar.opt('eventConstraint'); // what about View option?
    };
    EventDef.prototype.getOverlap = function () {
        if (this.overlap != null) {
            return this.overlap;
        }
        if (this.source.overlap != null) {
            return this.source.overlap;
        }
        return this.source.calendar.opt('eventOverlap'); // what about View option?
    };
    EventDef.prototype.isStartExplicitlyEditable = function () {
        if (this.startEditable != null) {
            return this.startEditable;
        }
        return this.source.startEditable;
    };
    EventDef.prototype.isDurationExplicitlyEditable = function () {
        if (this.durationEditable != null) {
            return this.durationEditable;
        }
        return this.source.durationEditable;
    };
    EventDef.prototype.isExplicitlyEditable = function () {
        if (this.editable != null) {
            return this.editable;
        }
        return this.source.editable;
    };
    EventDef.prototype.toLegacy = function () {
        var obj = $.extend({}, this.miscProps);
        obj._id = this.uid;
        obj.source = this.source;
        obj.className = this.className.slice(); // copy
        obj.allDay = this.isAllDay();
        if (this.rawId != null) {
            obj.id = this.rawId;
        }
        EventDef.copyVerbatimStandardProps(this, obj);
        return obj;
    };
    EventDef.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventDef.normalizeId((this.rawId = rawProps.id));
        }
        else {
            this.id = EventDef.generateId();
        }
        if (rawProps._id != null) {
            this.uid = String(rawProps._id);
        }
        else {
            this.uid = EventDef.generateId();
        }
        // TODO: converge with EventSource
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    EventDef.prototype.applyMiscProps = function (rawProps) {
        $.extend(this.miscProps, rawProps);
    };
    EventDef.uuid = 0;
    EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    return EventDef;
}());
exports.default = EventDef;
ParsableModelMixin_1.default.mixInto(EventDef);
EventDef.defineStandardProps({
    // not automatically assigned (`false`)
    _id: false,
    id: false,
    className: false,
    source: false,
    // automatically assigned (`true`)
    title: true,
    url: true,
    rendering: true,
    constraint: true,
    overlap: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true
});


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange_1 = __webpack_require__(211);
var EventFootprint_1 = __webpack_require__(36);
var ComponentFootprint_1 = __webpack_require__(12);
function eventDefsToEventInstances(eventDefs, unzonedRange) {
    var eventInstances = [];
    var i;
    for (i = 0; i < eventDefs.length; i++) {
        eventInstances.push.apply(eventInstances, // append
        eventDefs[i].buildInstances(unzonedRange));
    }
    return eventInstances;
}
exports.eventDefsToEventInstances = eventDefsToEventInstances;
function eventInstanceToEventRange(eventInstance) {
    return new EventRange_1.default(eventInstance.dateProfile.unzonedRange, eventInstance.def, eventInstance);
}
exports.eventInstanceToEventRange = eventInstanceToEventRange;
function eventRangeToEventFootprint(eventRange) {
    return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist
    );
}
exports.eventRangeToEventFootprint = eventRangeToEventFootprint;
function eventInstanceToUnzonedRange(eventInstance) {
    return eventInstance.dateProfile.unzonedRange;
}
exports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;
function eventFootprintToComponentFootprint(eventFootprint) {
    return eventFootprint.componentFootprint;
}
exports.eventFootprintToComponentFootprint = eventFootprintToComponentFootprint;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventFootprint = /** @class */ (function () {
    function EventFootprint(componentFootprint, eventDef, eventInstance) {
        this.componentFootprint = componentFootprint;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    EventFootprint.prototype.getEventLegacy = function () {
        return (this.eventInstance || this.eventDef).toLegacy();
    };
    return EventFootprint;
}());
exports.default = EventFootprint;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(4);
var EventDateProfile_1 = __webpack_require__(17);
var EventDef_1 = __webpack_require__(34);
var EventDefDateMutation_1 = __webpack_require__(50);
var SingleEventDef_1 = __webpack_require__(13);
var EventDefMutation = /** @class */ (function () {
    function EventDefMutation() {
    }
    EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {
        var eventDef = eventInstance.def;
        var dateProps = {};
        var standardProps = {};
        var miscProps = {};
        var verbatimStandardProps = {};
        var eventDefId = null;
        var className = null;
        var propName;
        var dateProfile;
        var dateMutation;
        var defMutation;
        for (propName in rawProps) {
            if (EventDateProfile_1.default.isStandardProp(propName)) {
                dateProps[propName] = rawProps[propName];
            }
            else if (eventDef.isStandardProp(propName)) {
                standardProps[propName] = rawProps[propName];
            }
            else if (eventDef.miscProps[propName] !== rawProps[propName]) {
                miscProps[propName] = rawProps[propName];
            }
        }
        dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);
        if (dateProfile) {
            dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);
        }
        if (standardProps.id !== eventDef.id) {
            eventDefId = standardProps.id; // only apply if there's a change
        }
        if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {
            className = standardProps.className; // only apply if there's a change
        }
        EventDef_1.default.copyVerbatimStandardProps(standardProps, // src
        verbatimStandardProps // dest
        );
        defMutation = new EventDefMutation();
        defMutation.eventDefId = eventDefId;
        defMutation.className = className;
        defMutation.verbatimStandardProps = verbatimStandardProps;
        defMutation.miscProps = miscProps;
        if (dateMutation) {
            defMutation.dateMutation = dateMutation;
        }
        return defMutation;
    };
    /*
    eventDef assumed to be a SingleEventDef.
    returns an undo function.
    */
    EventDefMutation.prototype.mutateSingle = function (eventDef) {
        var origDateProfile;
        if (this.dateMutation) {
            origDateProfile = eventDef.dateProfile;
            eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.eventDefId != null) {
            eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.className) {
            eventDef.className = this.className;
        }
        // can't undo
        if (this.verbatimStandardProps) {
            SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src
            eventDef // dest
            );
        }
        // can't undo
        if (this.miscProps) {
            eventDef.applyMiscProps(this.miscProps);
        }
        if (origDateProfile) {
            return function () {
                eventDef.dateProfile = origDateProfile;
            };
        }
        else {
            return function () { };
        }
    };
    EventDefMutation.prototype.setDateMutation = function (dateMutation) {
        if (dateMutation && !dateMutation.isEmpty()) {
            this.dateMutation = dateMutation;
        }
        else {
            this.dateMutation = null;
        }
    };
    EventDefMutation.prototype.isEmpty = function () {
        return !this.dateMutation;
    };
    return EventDefMutation;
}());
exports.default = EventDefMutation;


/***/ }),
/* 38 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    sourceClasses: [],
    registerClass: function (EventSourceClass) {
        this.sourceClasses.unshift(EventSourceClass); // give highest priority
    },
    parse: function (rawInput, calendar) {
        var sourceClasses = this.sourceClasses;
        var i;
        var eventSource;
        for (i = 0; i < sourceClasses.length; i++) {
            eventSource = sourceClasses[i].parse(rawInput, calendar);
            if (eventSource) {
                return eventSource;
            }
        }
    }
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Class_1 = __webpack_require__(33);
/*
Embodies a div that has potential scrollbars
*/
var Scroller = /** @class */ (function (_super) {
    tslib_1.__extends(Scroller, _super);
    function Scroller(options) {
        var _this = _super.call(this) || this;
        options = options || {};
        _this.overflowX = options.overflowX || options.overflow || 'auto';
        _this.overflowY = options.overflowY || options.overflow || 'auto';
        return _this;
    }
    Scroller.prototype.render = function () {
        this.el = this.renderEl();
        this.applyOverflow();
    };
    Scroller.prototype.renderEl = function () {
        return (this.scrollEl = $('<div class="fc-scroller"></div>'));
    };
    // sets to natural height, unlocks overflow
    Scroller.prototype.clear = function () {
        this.setHeight('auto');
        this.applyOverflow();
    };
    Scroller.prototype.destroy = function () {
        this.el.remove();
    };
    // Overflow
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.applyOverflow = function () {
        this.scrollEl.css({
            'overflow-x': this.overflowX,
            'overflow-y': this.overflowY
        });
    };
    // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
    // Useful for preserving scrollbar widths regardless of future resizes.
    // Can pass in scrollbarWidths for optimization.
    Scroller.prototype.lockOverflow = function (scrollbarWidths) {
        var overflowX = this.overflowX;
        var overflowY = this.overflowY;
        scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();
        if (overflowX === 'auto') {
            overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth) ? 'scroll' : 'hidden';
        }
        if (overflowY === 'auto') {
            overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight) ? 'scroll' : 'hidden';
        }
        this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
    };
    // Getters / Setters
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.setHeight = function (height) {
        this.scrollEl.height(height);
    };
    Scroller.prototype.getScrollTop = function () {
        return this.scrollEl.scrollTop();
    };
    Scroller.prototype.setScrollTop = function (top) {
        this.scrollEl.scrollTop(top);
    };
    Scroller.prototype.getClientWidth = function () {
        return this.scrollEl[0].clientWidth;
    };
    Scroller.prototype.getClientHeight = function () {
        return this.scrollEl[0].clientHeight;
    };
    Scroller.prototype.getScrollbarWidths = function () {
        return util_1.getScrollbarWidths(this.scrollEl);
    };
    return Scroller;
}(Class_1.default));
exports.default = Scroller;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var DateComponent_1 = __webpack_require__(219);
var GlobalEmitter_1 = __webpack_require__(21);
var InteractiveDateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InteractiveDateComponent, _super);
    function InteractiveDateComponent(_view, _options) {
        var _this = _super.call(this, _view, _options) || this;
        // self-config, overridable by subclasses
        _this.segSelector = '.fc-event-container > *'; // what constitutes an event element?
        if (_this.dateSelectingClass) {
            _this.dateClicking = new _this.dateClickingClass(_this);
        }
        if (_this.dateSelectingClass) {
            _this.dateSelecting = new _this.dateSelectingClass(_this);
        }
        if (_this.eventPointingClass) {
            _this.eventPointing = new _this.eventPointingClass(_this);
        }
        if (_this.eventDraggingClass && _this.eventPointing) {
            _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);
        }
        if (_this.eventResizingClass && _this.eventPointing) {
            _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);
        }
        if (_this.externalDroppingClass) {
            _this.externalDropping = new _this.externalDroppingClass(_this);
        }
        return _this;
    }
    // Sets the container element that the view should render inside of, does global DOM-related initializations,
    // and renders all the non-date-related content inside.
    InteractiveDateComponent.prototype.setElement = function (el) {
        _super.prototype.setElement.call(this, el);
        if (this.dateClicking) {
            this.dateClicking.bindToEl(el);
        }
        if (this.dateSelecting) {
            this.dateSelecting.bindToEl(el);
        }
        this.bindAllSegHandlersToEl(el);
    };
    InteractiveDateComponent.prototype.removeElement = function () {
        this.endInteractions();
        _super.prototype.removeElement.call(this);
    };
    InteractiveDateComponent.prototype.executeEventUnrender = function () {
        this.endInteractions();
        _super.prototype.executeEventUnrender.call(this);
    };
    InteractiveDateComponent.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.bindToDocument();
        }
    };
    InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.unbindFromDocument();
        }
    };
    InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {
        var _this = this;
        // attach a handler to the grid's root element.
        // jQuery will take care of unregistering them when removeElement gets called.
        this.el.on(name, function (ev) {
            if (!$(ev.target).is(_this.segSelector + ':not(.fc-helper),' + // directly on an event element
                _this.segSelector + ':not(.fc-helper) *,' + // within an event element
                '.fc-more,' + // a "more.." link
                'a[data-goto]' // a clickable nav link
            )) {
                return handler.call(_this, ev);
            }
        });
    };
    InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {
        [
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (eventInteraction) {
            if (eventInteraction) {
                eventInteraction.bindToEl(el);
            }
        });
    };
    InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {
        var _this = this;
        el.on(name, this.segSelector, function (ev) {
            var segEl = $(ev.currentTarget);
            if (!segEl.is('.fc-helper')) {
                var seg = segEl.data('fc-seg'); // grab segment data. put there by View::renderEventsPayload
                if (seg && !_this.shouldIgnoreEventPointing()) {
                    return handler.call(_this, seg, ev); // context will be the Grid
                }
            }
        });
    };
    InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {
        // HACK
        // This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.
        return GlobalEmitter_1.default.get().shouldIgnoreMouse();
    };
    InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {
        var view = this._getView();
        // On iOS (and Android?) when a new selection is initiated overtop another selection,
        // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
        // HACK: simply don't allow this to happen.
        // ALSO: prevent selection when an *event* is already raised.
        return view.isSelected || view.selectedEvent;
    };
    InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {
        // only call the handlers if there is not a drag/resize in progress
        return (this.eventDragging && this.eventDragging.isDragging) ||
            (this.eventResizing && this.eventResizing.isResizing);
    };
    InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {
        return util_1.getEvIsTouch(ev) &&
            !this.canStartResize(seg, ev) &&
            (this.isEventDefDraggable(seg.footprint.eventDef) ||
                this.isEventDefResizable(seg.footprint.eventDef));
    };
    InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {
        return !this.canStartResize(seg, ev) &&
            this.isEventDefDraggable(seg.footprint.eventDef);
    };
    InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {
        var view = this._getView();
        var eventDef = seg.footprint.eventDef;
        return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&
            this.isEventDefResizable(eventDef) &&
            $(ev.target).is('.fc-resizer');
    };
    // Kills all in-progress dragging.
    // Useful for when public API methods that result in re-rendering are invoked during a drag.
    // Also useful for when touch devices misbehave and don't fire their touchend.
    InteractiveDateComponent.prototype.endInteractions = function () {
        [
            this.dateClicking,
            this.dateSelecting,
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (interaction) {
            if (interaction) {
                interaction.end();
            }
        });
    };
    // Event Drag-n-Drop
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be dragged by the user
    InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {
        return this.isEventDefStartEditable(eventDef);
    };
    InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {
        var isEditable = eventDef.isStartExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('eventStartEditable');
            if (isEditable == null) {
                isEditable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isEditable;
    };
    InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {
        var isEditable = eventDef.isExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('editable');
        }
        return isEditable;
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be resized from its starting edge
    InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {
        return this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized from its ending edge
    InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {
        return this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized by the user at all
    InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {
        var isResizable = eventDef.isDurationExplicitlyEditable();
        if (isResizable == null) {
            isResizable = this.opt('eventDurationEditable');
            if (isResizable == null) {
                isResizable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isResizable;
    };
    // Event Mutation / Constraints
    // ---------------------------------------------------------------------------------------------------------------
    // Diffs the two dates, returning a duration, based on granularity of the grid
    // TODO: port isTimeScale into this system?
    InteractiveDateComponent.prototype.diffDates = function (a, b) {
        if (this.largeUnit) {
            return util_1.diffByUnit(a, b, this.largeUnit);
        }
        else {
            return util_1.diffDayTime(a, b);
        }
    };
    // is it allowed, in relation to the view's validRange?
    // NOTE: very similar to isExternalInstanceGroupAllowed
    InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            // TODO: just use getAllEventRanges directly
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);
    };
    // NOTE: very similar to isEventInstanceGroupAllowed
    // when it's a completely anonymous external drag, no event.
    InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        for (i = 0; i < eventFootprints.length; i++) {
            // treat it as a selection
            // TODO: pass in eventInstanceGroup instead
            //  because we don't want calendar's constraint system to depend on a component's
            //  determination of footprints.
            if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {
                return false;
            }
        }
        return true;
    };
    return InteractiveDateComponent;
}(DateComponent_1.default));
exports.default = InteractiveDateComponent;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var RenderQueue_1 = __webpack_require__(218);
var DateProfileGenerator_1 = __webpack_require__(221);
var InteractiveDateComponent_1 = __webpack_require__(40);
var GlobalEmitter_1 = __webpack_require__(21);
var UnzonedRange_1 = __webpack_require__(5);
/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/
var View = /** @class */ (function (_super) {
    tslib_1.__extends(View, _super);
    function View(calendar, viewSpec) {
        var _this = _super.call(this, null, viewSpec.options) || this;
        _this.batchRenderDepth = 0;
        _this.isSelected = false; // boolean whether a range of time is user-selected or not
        _this.calendar = calendar;
        _this.viewSpec = viewSpec;
        // shortcuts
        _this.type = viewSpec.type;
        // .name is deprecated
        _this.name = _this.type;
        _this.initRenderQueue();
        _this.initHiddenDays();
        _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);
        _this.bindBaseRenderHandlers();
        _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt('eventOrder'));
        // legacy
        if (_this['initialize']) {
            _this['initialize']();
        }
        return _this;
    }
    View.prototype._getView = function () {
        return this;
    };
    // Retrieves an option with the given name
    View.prototype.opt = function (name) {
        return this.options[name];
    };
    /* Render Queue
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.initRenderQueue = function () {
        this.renderQueue = new RenderQueue_1.default({
            event: this.opt('eventRenderWait')
        });
        this.renderQueue.on('start', this.onRenderQueueStart.bind(this));
        this.renderQueue.on('stop', this.onRenderQueueStop.bind(this));
        this.on('before:change', this.startBatchRender);
        this.on('change', this.stopBatchRender);
    };
    View.prototype.onRenderQueueStart = function () {
        this.calendar.freezeContentHeight();
        this.addScroll(this.queryScroll());
    };
    View.prototype.onRenderQueueStop = function () {
        if (this.calendar.updateViewSize()) {
            this.popScroll();
        }
        this.calendar.thawContentHeight();
    };
    View.prototype.startBatchRender = function () {
        if (!(this.batchRenderDepth++)) {
            this.renderQueue.pause();
        }
    };
    View.prototype.stopBatchRender = function () {
        if (!(--this.batchRenderDepth)) {
            this.renderQueue.resume();
        }
    };
    View.prototype.requestRender = function (func, namespace, actionType) {
        this.renderQueue.queue(func, namespace, actionType);
    };
    // given func will auto-bind to `this`
    View.prototype.whenSizeUpdated = function (func) {
        if (this.renderQueue.isRunning) {
            this.renderQueue.one('stop', func.bind(this));
        }
        else {
            func.call(this);
        }
    };
    /* Title and Date Formatting
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes what the title at the top of the calendar should be for this view
    View.prototype.computeTitle = function (dateProfile) {
        var unzonedRange;
        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
            unzonedRange = dateProfile.currentUnzonedRange;
        }
        else {
            unzonedRange = dateProfile.activeUnzonedRange;
        }
        return this.formatRange({
            start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),
            end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)
        }, dateProfile.isRangeAllDay, this.opt('titleFormat') || this.computeTitleFormat(dateProfile), this.opt('titleRangeSeparator'));
    };
    // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
    View.prototype.computeTitleFormat = function (dateProfile) {
        var currentRangeUnit = dateProfile.currentRangeUnit;
        if (currentRangeUnit === 'year') {
            return 'YYYY';
        }
        else if (currentRangeUnit === 'month') {
            return this.opt('monthYearFormat'); // like "September 2014"
        }
        else if (dateProfile.currentUnzonedRange.as('days') > 1) {
            return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
        }
        else {
            return 'LL'; // one day. longer, like "September 9 2014"
        }
    };
    // Date Setting/Unsetting
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.setDate = function (date) {
        var currentDateProfile = this.get('dateProfile');
        var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true
        if (!currentDateProfile ||
            !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {
            this.set('dateProfile', newDateProfile);
        }
    };
    View.prototype.unsetDate = function () {
        this.unset('dateProfile');
    };
    // Event Data
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.fetchInitialEvents = function (dateProfile) {
        var calendar = this.calendar;
        var forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;
        return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));
    };
    View.prototype.bindEventChanges = function () {
        this.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event
    };
    View.prototype.unbindEventChanges = function () {
        this.stopListeningTo(this.calendar, 'eventsReset');
    };
    View.prototype.setEvents = function (eventsPayload) {
        this.set('currentEvents', eventsPayload);
        this.set('hasEvents', true);
    };
    View.prototype.unsetEvents = function () {
        this.unset('currentEvents');
        this.unset('hasEvents');
    };
    View.prototype.resetEvents = function (eventsPayload) {
        this.startBatchRender();
        this.unsetEvents();
        this.setEvents(eventsPayload);
        this.stopBatchRender();
    };
    // Date High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestDateRender = function (dateProfile) {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateRender(dateProfile);
        }, 'date', 'init');
    };
    View.prototype.requestDateUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateUnrender();
        }, 'date', 'destroy');
    };
    // if dateProfile not specified, uses current
    View.prototype.executeDateRender = function (dateProfile) {
        _super.prototype.executeDateRender.call(this, dateProfile);
        if (this['render']) {
            this['render'](); // TODO: deprecate
        }
        this.trigger('datesRendered');
        this.addScroll({ isDateInit: true });
        this.startNowIndicator(); // shouldn't render yet because updateSize will be called soon
    };
    View.prototype.executeDateUnrender = function () {
        this.unselect();
        this.stopNowIndicator();
        this.trigger('before:datesUnrendered');
        if (this['destroy']) {
            this['destroy'](); // TODO: deprecate
        }
        _super.prototype.executeDateUnrender.call(this);
    };
    // "Base" rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.bindBaseRenderHandlers = function () {
        var _this = this;
        this.on('datesRendered', function () {
            _this.whenSizeUpdated(_this.triggerViewRender);
        });
        this.on('before:datesUnrendered', function () {
            _this.triggerViewDestroy();
        });
    };
    View.prototype.triggerViewRender = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerViewDestroy = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Event High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestEventsRender = function (eventsPayload) {
        var _this = this;
        this.requestRender(function () {
            _this.executeEventRender(eventsPayload);
            _this.whenSizeUpdated(_this.triggerAfterEventsRendered);
        }, 'event', 'init');
    };
    View.prototype.requestEventsUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.triggerBeforeEventsDestroyed();
            _this.executeEventUnrender();
        }, 'event', 'destroy');
    };
    // Business Hour High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {
        var _this = this;
        this.requestRender(function () {
            _this.renderBusinessHours(businessHourGenerator);
        }, 'businessHours', 'init');
    };
    View.prototype.requestBusinessHoursUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.unrenderBusinessHours();
        }, 'businessHours', 'destroy');
    };
    // Misc view rendering utils
    // -----------------------------------------------------------------------------------------------------------------
    // Binds DOM handlers to elements that reside outside the view container, such as the document
    View.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        this.listenTo(GlobalEmitter_1.default.get(), {
            touchstart: this.processUnselect,
            mousedown: this.handleDocumentMousedown
        });
    };
    // Unbinds DOM handlers from elements that reside outside the view container
    View.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        this.stopListeningTo(GlobalEmitter_1.default.get());
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    // Immediately render the current time indicator and begins re-rendering it at an interval,
    // which is defined by this.getNowIndicatorUnit().
    // TODO: somehow do this for the current whole day's background too
    View.prototype.startNowIndicator = function () {
        var _this = this;
        var unit;
        var update;
        var delay; // ms wait value
        if (this.opt('nowIndicator')) {
            unit = this.getNowIndicatorUnit();
            if (unit) {
                update = util_1.proxy(this, 'updateNowIndicator'); // bind to `this`
                this.initialNowDate = this.calendar.getNow();
                this.initialNowQueriedMs = new Date().valueOf();
                // wait until the beginning of the next interval
                delay = this.initialNowDate.clone().startOf(unit).add(1, unit).valueOf() - this.initialNowDate.valueOf();
                this.nowIndicatorTimeoutID = setTimeout(function () {
                    _this.nowIndicatorTimeoutID = null;
                    update();
                    delay = +moment.duration(1, unit);
                    delay = Math.max(100, delay); // prevent too frequent
                    _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
                }, delay);
            }
            // rendering will be initiated in updateSize
        }
    };
    // rerenders the now indicator, computing the new current time from the amount of time that has passed
    // since the initial getNow call.
    View.prototype.updateNowIndicator = function () {
        if (this.isDatesRendered &&
            this.initialNowDate // activated before?
        ) {
            this.unrenderNowIndicator(); // won't unrender if unnecessary
            this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms
            );
            this.isNowIndicatorRendered = true;
        }
    };
    // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
    // Won't cause side effects if indicator isn't rendered.
    View.prototype.stopNowIndicator = function () {
        if (this.isNowIndicatorRendered) {
            if (this.nowIndicatorTimeoutID) {
                clearTimeout(this.nowIndicatorTimeoutID);
                this.nowIndicatorTimeoutID = null;
            }
            if (this.nowIndicatorIntervalID) {
                clearInterval(this.nowIndicatorIntervalID);
                this.nowIndicatorIntervalID = null;
            }
            this.unrenderNowIndicator();
            this.isNowIndicatorRendered = false;
        }
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        if (this['setHeight']) {
            this['setHeight'](totalHeight, isAuto);
        }
        else {
            _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        }
        this.updateNowIndicator();
    };
    /* Scroller
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.addScroll = function (scroll) {
        var queuedScroll = this.queuedScroll || (this.queuedScroll = {});
        $.extend(queuedScroll, scroll);
    };
    View.prototype.popScroll = function () {
        this.applyQueuedScroll();
        this.queuedScroll = null;
    };
    View.prototype.applyQueuedScroll = function () {
        if (this.queuedScroll) {
            this.applyScroll(this.queuedScroll);
        }
    };
    View.prototype.queryScroll = function () {
        var scroll = {};
        if (this.isDatesRendered) {
            $.extend(scroll, this.queryDateScroll());
        }
        return scroll;
    };
    View.prototype.applyScroll = function (scroll) {
        if (scroll.isDateInit && this.isDatesRendered) {
            $.extend(scroll, this.computeInitialDateScroll());
        }
        if (this.isDatesRendered) {
            this.applyDateScroll(scroll);
        }
    };
    View.prototype.computeInitialDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.queryDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.applyDateScroll = function (scroll) {
        // subclasses must implement
    };
    /* Event Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);
        var dateMutation = eventMutation.dateMutation;
        // update the EventInstance, for handlers
        if (dateMutation) {
            eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        }
        this.triggerEventDrop(eventInstance, 
        // a drop doesn't necessarily mean a date mutation (ex: resource change)
        (dateMutation && dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);
    };
    // Triggers event-drop handlers that have subscribed via the API
    View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventDrop', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                dateDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* External Element Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
    // `meta` is the parsed data that has been embedded into the dragging event.
    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
    View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {
        if (isEvent) {
            this.calendar.eventManager.addEventDef(singleEventDef, isSticky);
        }
        this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);
    };
    // Triggers external-drop handlers that have subscribed via the API
    View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {
        // trigger 'drop' regardless of whether element represents an event
        this.publiclyTrigger('drop', {
            context: el[0],
            args: [
                singleEventDef.dateProfile.start.clone(),
                ev,
                ui,
                this
            ]
        });
        if (isEvent) {
            // signal an external event landed
            this.publiclyTrigger('eventReceive', {
                context: this,
                args: [
                    singleEventDef.buildInstance().toLegacy(),
                    this
                ]
            });
        }
    };
    /* Event Resizing
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an event in the view has been resized to a new length
    View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);
        // update the EventInstance, for handlers
        eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        this.triggerEventResize(eventInstance, eventMutation.dateMutation.endDelta, undoFunc, el, ev);
    };
    // Triggers event-resize handlers that have subscribed via the API
    View.prototype.triggerEventResize = function (eventInstance, durationDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventResize', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                durationDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* Selection (time range)
    ------------------------------------------------------------------------------------------------------------------*/
    // Selects a date span on the view. `start` and `end` are both Moments.
    // `ev` is the native mouse event that begin the interaction.
    View.prototype.select = function (footprint, ev) {
        this.unselect(ev);
        this.renderSelectionFootprint(footprint);
        this.reportSelection(footprint, ev);
    };
    View.prototype.renderSelectionFootprint = function (footprint) {
        if (this['renderSelection']) {
            this['renderSelection'](footprint.toLegacy(this.calendar));
        }
        else {
            _super.prototype.renderSelectionFootprint.call(this, footprint);
        }
    };
    // Called when a new selection is made. Updates internal state and triggers handlers.
    View.prototype.reportSelection = function (footprint, ev) {
        this.isSelected = true;
        this.triggerSelect(footprint, ev);
    };
    // Triggers handlers to 'select'
    View.prototype.triggerSelect = function (footprint, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('select', {
            context: this,
            args: [
                dateProfile.start,
                dateProfile.end,
                ev,
                this
            ]
        });
    };
    // Undoes a selection. updates in the internal state and triggers handlers.
    // `ev` is the native mouse event that began the interaction.
    View.prototype.unselect = function (ev) {
        if (this.isSelected) {
            this.isSelected = false;
            if (this['destroySelection']) {
                this['destroySelection'](); // TODO: deprecate
            }
            this.unrenderSelection();
            this.publiclyTrigger('unselect', {
                context: this,
                args: [ev, this]
            });
        }
    };
    /* Event Selection
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.selectEventInstance = function (eventInstance) {
        if (!this.selectedEventInstance ||
            this.selectedEventInstance !== eventInstance) {
            this.unselectEventInstance();
            this.getEventSegs().forEach(function (seg) {
                if (seg.footprint.eventInstance === eventInstance &&
                    seg.el // necessary?
                ) {
                    seg.el.addClass('fc-selected');
                }
            });
            this.selectedEventInstance = eventInstance;
        }
    };
    View.prototype.unselectEventInstance = function () {
        if (this.selectedEventInstance) {
            this.getEventSegs().forEach(function (seg) {
                if (seg.el) {
                    seg.el.removeClass('fc-selected');
                }
            });
            this.selectedEventInstance = null;
        }
    };
    View.prototype.isEventDefSelected = function (eventDef) {
        // event references might change on refetchEvents(), while selectedEventInstance doesn't,
        // so compare IDs
        return this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;
    };
    /* Mouse / Touch Unselecting (time range & event unselection)
    ------------------------------------------------------------------------------------------------------------------*/
    // TODO: move consistently to down/start or up/end?
    // TODO: don't kill previous selection if touch scrolling
    View.prototype.handleDocumentMousedown = function (ev) {
        if (util_1.isPrimaryMouseButton(ev)) {
            this.processUnselect(ev);
        }
    };
    View.prototype.processUnselect = function (ev) {
        this.processRangeUnselect(ev);
        this.processEventUnselect(ev);
    };
    View.prototype.processRangeUnselect = function (ev) {
        var ignore;
        // is there a time-range selection?
        if (this.isSelected && this.opt('unselectAuto')) {
            // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
            ignore = this.opt('unselectCancel');
            if (!ignore || !$(ev.target).closest(ignore).length) {
                this.unselect(ev);
            }
        }
    };
    View.prototype.processEventUnselect = function (ev) {
        if (this.selectedEventInstance) {
            if (!$(ev.target).closest('.fc-selected').length) {
                this.unselectEventInstance();
            }
        }
    };
    /* Triggers
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.triggerBaseRendered = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerBaseUnrendered = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Triggers handlers to 'dayClick'
    // Span has start/end of the clicked area. Only the start is useful.
    View.prototype.triggerDayClick = function (footprint, dayEl, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('dayClick', {
            context: dayEl,
            args: [dateProfile.start, ev, this]
        });
    };
    /* Date Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // For DateComponent::getDayClasses
    View.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return false;
    };
    // Arguments after name will be forwarded to a hypothetical function value
    // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
    // Always clone your objects if you fear mutation.
    View.prototype.getUnzonedRangeOption = function (name) {
        var val = this.opt(name);
        if (typeof val === 'function') {
            val = val.apply(null, Array.prototype.slice.call(arguments, 1));
        }
        if (val) {
            return this.calendar.parseUnzonedRange(val);
        }
    };
    /* Hidden Days
    ------------------------------------------------------------------------------------------------------------------*/
    // Initializes internal variables related to calculating hidden days-of-week
    View.prototype.initHiddenDays = function () {
        var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
        var dayCnt = 0;
        var i;
        if (this.opt('weekends') === false) {
            hiddenDays.push(0, 6); // 0=sunday, 6=saturday
        }
        for (i = 0; i < 7; i++) {
            if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {
                dayCnt++;
            }
        }
        if (!dayCnt) {
            throw new Error('invalid hiddenDays'); // all days were hidden? bad.
        }
        this.isHiddenDayHash = isHiddenDayHash;
    };
    // Remove days from the beginning and end of the range that are computed as hidden.
    // If the whole range is trimmed off, returns null
    View.prototype.trimHiddenDays = function (inputUnzonedRange) {
        var start = inputUnzonedRange.getStart();
        var end = inputUnzonedRange.getEnd();
        if (start) {
            start = this.skipHiddenDays(start);
        }
        if (end) {
            end = this.skipHiddenDays(end, -1, true);
        }
        if (start === null || end === null || start < end) {
            return new UnzonedRange_1.default(start, end);
        }
        return null;
    };
    // Is the current day hidden?
    // `day` is a day-of-week index (0-6), or a Moment
    View.prototype.isHiddenDay = function (day) {
        if (moment.isMoment(day)) {
            day = day.day();
        }
        return this.isHiddenDayHash[day];
    };
    // Incrementing the current day until it is no longer a hidden day, returning a copy.
    // DOES NOT CONSIDER validUnzonedRange!
    // If the initial value of `date` is not a hidden day, don't do anything.
    // Pass `isExclusive` as `true` if you are dealing with an end date.
    // `inc` defaults to `1` (increment one day forward each time)
    View.prototype.skipHiddenDays = function (date, inc, isExclusive) {
        if (inc === void 0) { inc = 1; }
        if (isExclusive === void 0) { isExclusive = false; }
        var out = date.clone();
        while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {
            out.add(inc, 'days');
        }
        return out;
    };
    return View;
}(InteractiveDateComponent_1.default));
exports.default = View;
View.prototype.usesMinMaxTime = false;
View.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;
View.watch('displayingDates', ['isInDom', 'dateProfile'], function (deps) {
    this.requestDateRender(deps.dateProfile);
}, function () {
    this.requestDateUnrender();
});
View.watch('displayingBusinessHours', ['displayingDates', 'businessHourGenerator'], function (deps) {
    this.requestBusinessHoursRender(deps.businessHourGenerator);
}, function () {
    this.requestBusinessHoursUnrender();
});
View.watch('initialEvents', ['dateProfile'], function (deps) {
    return this.fetchInitialEvents(deps.dateProfile);
});
View.watch('bindingEvents', ['initialEvents'], function (deps) {
    this.setEvents(deps.initialEvents);
    this.bindEventChanges();
}, function () {
    this.unbindEventChanges();
    this.unsetEvents();
});
View.watch('displayingEvents', ['displayingDates', 'hasEvents'], function () {
    this.requestEventsRender(this.get('currentEvents'));
}, function () {
    this.requestEventsUnrender();
});
View.watch('title', ['dateProfile'], function (deps) {
    return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons
});
View.watch('legacyDateProps', ['dateProfile'], function (deps) {
    var calendar = this.calendar;
    var dateProfile = deps.dateProfile;
    // DEPRECATED, but we need to keep it updated...
    this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);
    this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);
});


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventRenderer = /** @class */ (function () {
    function EventRenderer(component, fillRenderer) {
        this.view = component._getView();
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    EventRenderer.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    // Updates values that rely on options and also relate to range
    EventRenderer.prototype.rangeUpdated = function () {
        var displayEventTime;
        var displayEventEnd;
        this.eventTimeFormat =
            this.opt('eventTimeFormat') ||
                this.opt('timeFormat') || // deprecated
                this.computeEventTimeFormat();
        displayEventTime = this.opt('displayEventTime');
        if (displayEventTime == null) {
            displayEventTime = this.computeDisplayEventTime(); // might be based off of range
        }
        displayEventEnd = this.opt('displayEventEnd');
        if (displayEventEnd == null) {
            displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
        }
        this.displayEventTime = displayEventTime;
        this.displayEventEnd = displayEventEnd;
    };
    EventRenderer.prototype.render = function (eventsPayload) {
        var dateProfile = this.component._getDateProfile();
        var eventDefId;
        var instanceGroup;
        var eventRanges;
        var bgRanges = [];
        var fgRanges = [];
        for (eventDefId in eventsPayload) {
            instanceGroup = eventsPayload[eventDefId];
            eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);
            if (instanceGroup.getEventDef().hasBgRendering()) {
                bgRanges.push.apply(bgRanges, eventRanges);
            }
            else {
                fgRanges.push.apply(fgRanges, eventRanges);
            }
        }
        this.renderBgRanges(bgRanges);
        this.renderFgRanges(fgRanges);
    };
    EventRenderer.prototype.unrender = function () {
        this.unrenderBgRanges();
        this.unrenderFgRanges();
    };
    EventRenderer.prototype.renderFgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        // render an `.el` on each seg
        // returns a subset of the segs. segs that were actually rendered
        segs = this.renderFgSegEls(segs);
        if (this.renderFgSegs(segs) !== false) {
            this.fgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderFgRanges = function () {
        this.unrenderFgSegs(this.fgSegs || []);
        this.fgSegs = null;
    };
    EventRenderer.prototype.renderBgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        if (this.renderBgSegs(segs) !== false) {
            this.bgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderBgRanges = function () {
        this.unrenderBgSegs();
        this.bgSegs = null;
    };
    EventRenderer.prototype.getSegs = function () {
        return (this.bgSegs || []).concat(this.fgSegs || []);
    };
    // Renders foreground event segments onto the grid
    EventRenderer.prototype.renderFgSegs = function (segs) {
        // subclasses must implement
        // segs already has rendered els, and has been filtered.
        return false; // signal failure if not implemented
    };
    // Unrenders all currently rendered foreground segments
    EventRenderer.prototype.unrenderFgSegs = function (segs) {
        // subclasses must implement
    };
    EventRenderer.prototype.renderBgSegs = function (segs) {
        var _this = this;
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('bgEvent', segs, {
                getClasses: function (seg) {
                    return _this.getBgClasses(seg.footprint.eventDef);
                },
                getCss: function (seg) {
                    return {
                        'background-color': _this.getBgColor(seg.footprint.eventDef)
                    };
                },
                filterEl: function (seg, el) {
                    return _this.filterEventRenderEl(seg.footprint, el);
                }
            });
        }
        else {
            return false; // signal failure if no fillRenderer
        }
    };
    EventRenderer.prototype.unrenderBgSegs = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('bgEvent');
        }
    };
    // Renders and assigns an `el` property for each foreground event segment.
    // Only returns segments that successfully rendered.
    EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {
        var _this = this;
        if (disableResizing === void 0) { disableResizing = false; }
        var hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) {
            // build a large concatenation of event segment HTML
            for (i = 0; i < segs.length; i++) {
                this.beforeFgSegHtml(segs[i]);
                html += this.fgSegHtml(segs[i], disableResizing);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                if (hasEventRenderHandlers) {
                    el = _this.filterEventRenderEl(seg.footprint, el);
                }
                if (el) {
                    el.data('fc-seg', seg); // used by handlers
                    seg.el = el;
                    renderedSegs.push(seg);
                }
            });
        }
        return renderedSegs;
    };
    EventRenderer.prototype.beforeFgSegHtml = function (seg) {
    };
    // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
    EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        // subclasses should implement
    };
    // Generic utility for generating the HTML classNames for an event segment's element
    EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {
        var classes = [
            'fc-event',
            seg.isStart ? 'fc-start' : 'fc-not-start',
            seg.isEnd ? 'fc-end' : 'fc-not-end'
        ].concat(this.getClasses(seg.footprint.eventDef));
        if (isDraggable) {
            classes.push('fc-draggable');
        }
        if (isResizable) {
            classes.push('fc-resizable');
        }
        // event is currently selected? attach a className.
        if (this.view.isEventDefSelected(seg.footprint.eventDef)) {
            classes.push('fc-selected');
        }
        return classes;
    };
    // Given an event and the default element used for rendering, returns the element that should actually be used.
    // Basically runs events and elements through the eventRender hook.
    EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {
        var legacy = eventFootprint.getEventLegacy();
        var custom = this.view.publiclyTrigger('eventRender', {
            context: legacy,
            args: [legacy, el, this.view]
        });
        if (custom === false) {
            el = null;
        }
        else if (custom && custom !== true) {
            el = $(custom);
        }
        return el;
    };
    // Compute the text that should be displayed on an event's element.
    // `range` can be the Event object itself, or something range-like, with at least a `start`.
    // If event times are disabled, or the event has no time, will return a blank string.
    // If not specified, formatStr will default to the eventTimeFormat setting,
    // and displayEnd will default to the displayEventEnd setting.
    EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {
        return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);
    };
    EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {
        if (formatStr == null) {
            formatStr = this.eventTimeFormat;
        }
        if (displayEnd == null) {
            displayEnd = this.displayEventEnd;
        }
        if (this.displayEventTime && !isAllDay) {
            if (displayEnd && end) {
                return this.view.formatRange({ start: start, end: end }, false, // allDay
                formatStr);
            }
            else {
                return start.format(formatStr);
            }
        }
        return '';
    };
    EventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('smallTimeFormat');
    };
    EventRenderer.prototype.computeDisplayEventTime = function () {
        return true;
    };
    EventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    EventRenderer.prototype.getBgClasses = function (eventDef) {
        var classNames = this.getClasses(eventDef);
        classNames.push('fc-bgevent');
        return classNames;
    };
    EventRenderer.prototype.getClasses = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var classNames = [];
        for (i = 0; i < objs.length; i++) {
            classNames.push.apply(// append
            classNames, objs[i].eventClassName || objs[i].className || []);
        }
        return classNames;
    };
    // Utility for generating event skin-related CSS properties
    EventRenderer.prototype.getSkinCss = function (eventDef) {
        return {
            'background-color': this.getBgColor(eventDef),
            'border-color': this.getBorderColor(eventDef),
            color: this.getTextColor(eventDef)
        };
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBgColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBackgroundColor || objs[i].eventColor ||
                objs[i].backgroundColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBackgroundColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBorderColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBorderColor || objs[i].eventColor ||
                objs[i].borderColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBorderColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getTextColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventTextColor ||
                objs[i].textColor;
        }
        if (!val) {
            val = this.opt('eventTextColor');
        }
        return val;
    };
    EventRenderer.prototype.getStylingObjs = function (eventDef) {
        var objs = this.getFallbackStylingObjs(eventDef);
        objs.unshift(eventDef);
        return objs;
    };
    EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {
        return [eventDef.source];
    };
    EventRenderer.prototype.sortEventSegs = function (segs) {
        segs.sort(util_1.proxy(this, 'compareEventSegs'));
    };
    // A cmp function for determining which segments should take visual priority
    EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {
        var f1 = seg1.footprint;
        var f2 = seg2.footprint;
        var cf1 = f1.componentFootprint;
        var cf2 = f2.componentFootprint;
        var r1 = cf1.unzonedRange;
        var r2 = cf2.unzonedRange;
        return r1.startMs - r2.startMs || // earlier events go first
            (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first
            cf2.isAllDay - cf1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)
            util_1.compareByFieldSpecs(f1.eventDef, f2.eventDef, this.view.eventOrderSpecs, f1.eventDef.miscProps, f2.eventDef.miscProps);
    };
    return EventRenderer;
}());
exports.default = EventRenderer;


/***/ }),
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment_ext_1 = __webpack_require__(10);
// Plugin
// -------------------------------------------------------------------------------------------------
moment_ext_1.newMomentProto.format = function () {
    if (this._fullCalendar && arguments[0]) {
        return formatDate(this, arguments[0]); // our extended formatting
    }
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) {
        // moment.format() doesn't ensure english, but we want to.
        return moment_ext_1.oldMomentFormat(englishMoment(this));
    }
    return moment_ext_1.oldMomentProto.format.apply(this, arguments);
};
moment_ext_1.newMomentProto.toISOString = function () {
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) {
        // depending on browser, moment might not output english. ensure english.
        // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
        return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);
    }
    return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);
};
function englishMoment(mom) {
    if (mom.locale() !== 'en') {
        return mom.clone().locale('en');
    }
    return mom;
}
// Config
// ---------------------------------------------------------------------------------------------------------------------
/*
Inserted between chunks in the fake ("intermediate") formatting string.
Important that it passes as whitespace (\s) because moment often identifies non-standalone months
via a regexp with an \s.
*/
var PART_SEPARATOR = '\u000b'; // vertical tab
/*
Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
but rather, a "special" token that has custom rendering (see specialTokens map).
*/
var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1
/*
Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
Handling of these markers is done in a post-processing step at the very end of text rendering.
*/
var MAYBE_MARKER = '\u001e'; // information separator 2
var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global
/*
Addition formatting tokens we want recognized
*/
var specialTokens = {
    t: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'a').charAt(0);
    },
    T: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'A').charAt(0);
    }
};
/*
The first characters of formatting tokens for units that are 1 day or larger.
`value` is for ranking relative size (lower means bigger).
`unit` is a normalized unit, used for comparing moments.
*/
var largeTokenMap = {
    Y: { value: 1, unit: 'year' },
    M: { value: 2, unit: 'month' },
    W: { value: 3, unit: 'week' },
    w: { value: 3, unit: 'week' },
    D: { value: 4, unit: 'day' },
    d: { value: 4, unit: 'day' } // day of week
};
// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
*/
function formatDate(date, formatStr) {
    return renderFakeFormatString(getParsedFormatString(formatStr).fakeFormatString, date);
}
exports.formatDate = formatDate;
// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
/*
Using a formatting string meant for a single date, generate a range string, like
"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
If the dates are the same as far as the format string is concerned, just return a single
rendering of one date, without any separator.
*/
function formatRange(date1, date2, formatStr, separator, isRTL) {
    var localeData;
    date1 = moment_ext_1.default.parseZone(date1);
    date2 = moment_ext_1.default.parseZone(date2);
    localeData = date1.localeData();
    // Expand localized format strings, like "LL" -> "MMMM D YYYY".
    // BTW, this is not important for `formatDate` because it is impossible to put custom tokens
    // or non-zero areas in Moment's localized format strings.
    formatStr = localeData.longDateFormat(formatStr) || formatStr;
    return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || ' - ', isRTL);
}
exports.formatRange = formatRange;
/*
Renders a range with an already-parsed format string.
*/
function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
    var sameUnits = parsedFormat.sameUnits;
    var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
    var unzonedDate2 = date2.clone().stripZone(); // "
    var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
    var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);
    var leftI;
    var leftStr = '';
    var rightI;
    var rightStr = '';
    var middleI;
    var middleStr1 = '';
    var middleStr2 = '';
    var middleStr = '';
    // Start at the leftmost side of the formatting string and continue until you hit a token
    // that is not the same between dates.
    for (leftI = 0; leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {
        leftStr += renderedParts1[leftI];
    }
    // Similarly, start at the rightmost side of the formatting string and move left
    for (rightI = sameUnits.length - 1; rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {
        // If current chunk is on the boundary of unique date-content, and is a special-case
        // date-formatting postfix character, then don't consume it. Consider it unique date-content.
        // TODO: make configurable
        if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
            break;
        }
        rightStr = renderedParts1[rightI] + rightStr;
    }
    // The area in the middle is different for both of the dates.
    // Collect them distinctly so we can jam them together later.
    for (middleI = leftI; middleI <= rightI; middleI++) {
        middleStr1 += renderedParts1[middleI];
        middleStr2 += renderedParts2[middleI];
    }
    if (middleStr1 || middleStr2) {
        if (isRTL) {
            middleStr = middleStr2 + separator + middleStr1;
        }
        else {
            middleStr = middleStr1 + separator + middleStr2;
        }
    }
    return processMaybeMarkers(leftStr + middleStr + rightStr);
}
// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------
var parsedFormatStrCache = {};
/*
Returns a parsed format string, leveraging a cache.
*/
function getParsedFormatString(formatStr) {
    return parsedFormatStrCache[formatStr] ||
        (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
}
/*
Parses a format string into the following:
- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
  that indicates how similar a range's start & end must be in order to share the same formatted text.
  If not a token, then the value is null.
  Always a flat array (not nested liked "chunks").
*/
function parseFormatString(formatStr) {
    var chunks = chunkFormatString(formatStr);
    return {
        fakeFormatString: buildFakeFormatString(chunks),
        sameUnits: buildSameUnits(chunks)
    };
}
/*
Break the formatting string into an array of chunks.
A 'maybe' chunk will have nested chunks.
*/
function chunkFormatString(formatStr) {
    var chunks = [];
    var match;
    // TODO: more descrimination
    // \4 is a backreference to the first character of a multi-character set.
    var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;
    while ((match = chunker.exec(formatStr))) {
        if (match[1]) {
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[1]));
        }
        else if (match[2]) {
            chunks.push({ maybe: chunkFormatString(match[2]) });
        }
        else if (match[3]) {
            chunks.push({ token: match[3] });
        }
        else if (match[5]) {
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[5]));
        }
    }
    return chunks;
}
/*
Potentially splits a literal-text string into multiple parts. For special cases.
*/
function splitStringLiteral(s) {
    if (s === '. ') {
        return ['.', ' ']; // for locales with periods bound to the end of each year/month/date
    }
    else {
        return [s];
    }
}
/*
Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
characters that will eventually be given to moment for formatting, and then post-processed.
*/
function buildFakeFormatString(chunks) {
    var parts = [];
    var i;
    var chunk;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (typeof chunk === 'string') {
            parts.push('[' + chunk + ']');
        }
        else if (chunk.token) {
            if (chunk.token in specialTokens) {
                parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing
                    '[' + chunk.token + ']' // preserve as literal text
                );
            }
            else {
                parts.push(chunk.token); // unprotected text implies a format string
            }
        }
        else if (chunk.maybe) {
            parts.push(MAYBE_MARKER + // useful during post-processing
                buildFakeFormatString(chunk.maybe) +
                MAYBE_MARKER);
        }
    }
    return parts.join(PART_SEPARATOR);
}
/*
Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
in which regard two dates must be similar in order to share range formatting text.
The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
*/
function buildSameUnits(chunks) {
    var units = [];
    var i;
    var chunk;
    var tokenInfo;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            tokenInfo = largeTokenMap[chunk.token.charAt(0)];
            units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
        }
        else if (chunk.maybe) {
            units.push.apply(units, // append
            buildSameUnits(chunk.maybe));
        }
        else {
            units.push(null);
        }
    }
    return units;
}
// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats a date with a fake format string, post-processes the control characters, then returns.
*/
function renderFakeFormatString(fakeFormatString, date) {
    return processMaybeMarkers(renderFakeFormatStringParts(fakeFormatString, date).join(''));
}
/*
Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
*/
function renderFakeFormatStringParts(fakeFormatString, date) {
    var parts = [];
    var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);
    var fakeParts = fakeRender.split(PART_SEPARATOR);
    var i;
    var fakePart;
    for (i = 0; i < fakeParts.length; i++) {
        fakePart = fakeParts[i];
        if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
            parts.push(
            // the literal string IS the token's name.
            // call special token's registered function.
            specialTokens[fakePart.substring(1)](date));
        }
        else {
            parts.push(fakePart);
        }
    }
    return parts;
}
/*
Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
*/
function processMaybeMarkers(s) {
    return s.replace(MAYBE_REGEXP, function (m0, m1) {
        if (m1.match(/[1-9]/)) {
            return m1;
        }
        else {
            return '';
        }
    });
}
// Misc Utils
// -------------------------------------------------------------------------------------------------
/*
Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
*/
function queryMostGranularFormatUnit(formatStr) {
    var chunks = chunkFormatString(formatStr);
    var i;
    var chunk;
    var candidate;
    var best;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            candidate = largeTokenMap[chunk.token.charAt(0)];
            if (candidate) {
                if (!best || candidate.value > best.value) {
                    best = candidate;
                }
            }
        }
    }
    if (best) {
        return best.unit;
    }
    return null;
}
exports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Class_1 = __webpack_require__(33);
var EmitterMixin_1 = __webpack_require__(11);
var ListenerMixin_1 = __webpack_require__(7);
var Model = /** @class */ (function (_super) {
    tslib_1.__extends(Model, _super);
    function Model() {
        var _this = _super.call(this) || this;
        _this._watchers = {};
        _this._props = {};
        _this.applyGlobalWatchers();
        _this.constructed();
        return _this;
    }
    Model.watch = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // subclasses should make a masked-copy of the superclass's map
        // TODO: write test
        if (!this.prototype.hasOwnProperty('_globalWatchArgs')) {
            this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);
        }
        this.prototype._globalWatchArgs[name] = args;
    };
    Model.prototype.constructed = function () {
        // useful for monkeypatching. TODO: BaseClass?
    };
    Model.prototype.applyGlobalWatchers = function () {
        var map = this._globalWatchArgs;
        var name;
        for (name in map) {
            this.watch.apply(this, [name].concat(map[name]));
        }
    };
    Model.prototype.has = function (name) {
        return name in this._props;
    };
    Model.prototype.get = function (name) {
        if (name === undefined) {
            return this._props;
        }
        return this._props[name];
    };
    Model.prototype.set = function (name, val) {
        var newProps;
        if (typeof name === 'string') {
            newProps = {};
            newProps[name] = val === undefined ? null : val;
        }
        else {
            newProps = name;
        }
        this.setProps(newProps);
    };
    Model.prototype.reset = function (newProps) {
        var oldProps = this._props;
        var changeset = {}; // will have undefined's to signal unsets
        var name;
        for (name in oldProps) {
            changeset[name] = undefined;
        }
        for (name in newProps) {
            changeset[name] = newProps[name];
        }
        this.setProps(changeset);
    };
    Model.prototype.unset = function (name) {
        var newProps = {};
        var names;
        var i;
        if (typeof name === 'string') {
            names = [name];
        }
        else {
            names = name;
        }
        for (i = 0; i < names.length; i++) {
            newProps[names[i]] = undefined;
        }
        this.setProps(newProps);
    };
    Model.prototype.setProps = function (newProps) {
        var changedProps = {};
        var changedCnt = 0;
        var name;
        var val;
        for (name in newProps) {
            val = newProps[name];
            // a change in value?
            // if an object, don't check equality, because might have been mutated internally.
            // TODO: eventually enforce immutability.
            if (typeof val === 'object' ||
                val !== this._props[name]) {
                changedProps[name] = val;
                changedCnt++;
            }
        }
        if (changedCnt) {
            this.trigger('before:batchChange', changedProps);
            for (name in changedProps) {
                val = changedProps[name];
                this.trigger('before:change', name, val);
                this.trigger('before:change:' + name, val);
            }
            for (name in changedProps) {
                val = changedProps[name];
                if (val === undefined) {
                    delete this._props[name];
                }
                else {
                    this._props[name] = val;
                }
                this.trigger('change:' + name, val);
                this.trigger('change', name, val);
            }
            this.trigger('batchChange', changedProps);
        }
    };
    Model.prototype.watch = function (name, depList, startFunc, stopFunc) {
        var _this = this;
        this.unwatch(name);
        this._watchers[name] = this._watchDeps(depList, function (deps) {
            var res = startFunc.call(_this, deps);
            if (res && res.then) {
                _this.unset(name); // put in an unset state while resolving
                res.then(function (val) {
                    _this.set(name, val);
                });
            }
            else {
                _this.set(name, res);
            }
        }, function (deps) {
            _this.unset(name);
            if (stopFunc) {
                stopFunc.call(_this, deps);
            }
        });
    };
    Model.prototype.unwatch = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            delete this._watchers[name];
            watcher.teardown();
        }
    };
    Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {
        var _this = this;
        var queuedChangeCnt = 0;
        var depCnt = depList.length;
        var satisfyCnt = 0;
        var values = {}; // what's passed as the `deps` arguments
        var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
        var isCallingStop = false;
        var onBeforeDepChange = function (depName, val, isOptional) {
            queuedChangeCnt++;
            if (queuedChangeCnt === 1) {
                if (satisfyCnt === depCnt) {
                    isCallingStop = true;
                    stopFunc(values);
                    isCallingStop = false;
                }
            }
        };
        var onDepChange = function (depName, val, isOptional) {
            if (val === undefined) {
                // required dependency that was previously set?
                if (!isOptional && values[depName] !== undefined) {
                    satisfyCnt--;
                }
                delete values[depName];
            }
            else {
                // required dependency that was previously unset?
                if (!isOptional && values[depName] === undefined) {
                    satisfyCnt++;
                }
                values[depName] = val;
            }
            queuedChangeCnt--;
            if (!queuedChangeCnt) {
                // now finally satisfied or satisfied all along?
                if (satisfyCnt === depCnt) {
                    // if the stopFunc initiated another value change, ignore it.
                    // it will be processed by another change event anyway.
                    if (!isCallingStop) {
                        startFunc(values);
                    }
                }
            }
        };
        // intercept for .on() that remembers handlers
        var bind = function (eventName, handler) {
            _this.on(eventName, handler);
            bindTuples.push([eventName, handler]);
        };
        // listen to dependency changes
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') {
                depName = depName.substring(1);
                isOptional = true;
            }
            bind('before:change:' + depName, function (val) {
                onBeforeDepChange(depName, val, isOptional);
            });
            bind('change:' + depName, function (val) {
                onDepChange(depName, val, isOptional);
            });
        });
        // process current dependency values
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') {
                depName = depName.substring(1);
                isOptional = true;
            }
            if (_this.has(depName)) {
                values[depName] = _this.get(depName);
                satisfyCnt++;
            }
            else if (isOptional) {
                satisfyCnt++;
            }
        });
        // initially satisfied
        if (satisfyCnt === depCnt) {
            startFunc(values);
        }
        return {
            teardown: function () {
                // remove all handlers
                for (var i = 0; i < bindTuples.length; i++) {
                    _this.off(bindTuples[i][0], bindTuples[i][1]);
                }
                bindTuples = null;
                // was satisfied, so call stopFunc
                if (satisfyCnt === depCnt) {
                    stopFunc();
                }
            },
            flash: function () {
                if (satisfyCnt === depCnt) {
                    stopFunc();
                    startFunc(values);
                }
            }
        };
    };
    Model.prototype.flash = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            watcher.flash();
        }
    };
    return Model;
}(Class_1.default));
exports.default = Model;
Model.prototype._globalWatchArgs = {}; // mutation protection in Model.watch
EmitterMixin_1.default.mixInto(Model);
ListenerMixin_1.default.mixInto(Model);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var SingleEventDef_1 = __webpack_require__(13);
var RecurringEventDef_1 = __webpack_require__(210);
exports.default = {
    parse: function (eventInput, source) {
        if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||
            util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {
            return RecurringEventDef_1.default.parse(eventInput, source);
        }
        else {
            return SingleEventDef_1.default.parse(eventInput, source);
        }
    }
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(4);
var EventDateProfile_1 = __webpack_require__(17);
var EventDefDateMutation = /** @class */ (function () {
    function EventDefDateMutation() {
        this.clearEnd = false;
        this.forceTimed = false;
        this.forceAllDay = false;
    }
    EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {
        var clearEnd = dateProfile0.end && !dateProfile1.end;
        var forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();
        var forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();
        var dateDelta;
        var endDiff;
        var endDelta;
        var mutation;
        // subtracts the dates in the appropriate way, returning a duration
        function subtractDates(date1, date0) {
            if (largeUnit) {
                return util_1.diffByUnit(date1, date0, largeUnit); // poorly named
            }
            else if (dateProfile1.isAllDay()) {
                return util_1.diffDay(date1, date0); // poorly named
            }
            else {
                return util_1.diffDayTime(date1, date0); // poorly named
            }
        }
        dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);
        if (dateProfile1.end) {
            // use unzonedRanges because dateProfile0.end might be null
            endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());
            endDelta = endDiff.subtract(dateDelta);
        }
        mutation = new EventDefDateMutation();
        mutation.clearEnd = clearEnd;
        mutation.forceTimed = forceTimed;
        mutation.forceAllDay = forceAllDay;
        mutation.setDateDelta(dateDelta);
        mutation.setEndDelta(endDelta);
        return mutation;
    };
    /*
    returns an undo function.
    */
    EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {
        var start = eventDateProfile.start.clone();
        var end = null;
        var shouldRezone = false;
        if (eventDateProfile.end && !this.clearEnd) {
            end = eventDateProfile.end.clone();
        }
        else if (this.endDelta && !end) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        if (this.forceTimed) {
            shouldRezone = true;
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        else if (this.forceAllDay) {
            if (start.hasTime()) {
                start.stripTime();
            }
            if (end && end.hasTime()) {
                end.stripTime();
            }
        }
        if (this.dateDelta) {
            shouldRezone = true;
            start.add(this.dateDelta);
            if (end) {
                end.add(this.dateDelta);
            }
        }
        // do this before adding startDelta to start, so we can work off of start
        if (this.endDelta) {
            shouldRezone = true;
            end.add(this.endDelta);
        }
        if (this.startDelta) {
            shouldRezone = true;
            start.add(this.startDelta);
        }
        if (shouldRezone) {
            start = calendar.applyTimezone(start);
            if (end) {
                end = calendar.applyTimezone(end);
            }
        }
        // TODO: okay to access calendar option?
        if (!end && calendar.opt('forceEventDuration')) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        return new EventDateProfile_1.default(start, end, calendar);
    };
    EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {
        if (dateDelta && dateDelta.valueOf()) {
            this.dateDelta = dateDelta;
        }
        else {
            this.dateDelta = null;
        }
    };
    EventDefDateMutation.prototype.setStartDelta = function (startDelta) {
        if (startDelta && startDelta.valueOf()) {
            this.startDelta = startDelta;
        }
        else {
            this.startDelta = null;
        }
    };
    EventDefDateMutation.prototype.setEndDelta = function (endDelta) {
        if (endDelta && endDelta.valueOf()) {
            this.endDelta = endDelta;
        }
        else {
            this.endDelta = null;
        }
    };
    EventDefDateMutation.prototype.isEmpty = function () {
        return !this.clearEnd && !this.forceTimed && !this.forceAllDay &&
            !this.dateDelta && !this.startDelta && !this.endDelta;
    };
    return EventDefDateMutation;
}());
exports.default = EventDefDateMutation;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var StandardTheme_1 = __webpack_require__(213);
var JqueryUiTheme_1 = __webpack_require__(214);
var themeClassHash = {};
function defineThemeSystem(themeName, themeClass) {
    themeClassHash[themeName] = themeClass;
}
exports.defineThemeSystem = defineThemeSystem;
function getThemeSystemClass(themeSetting) {
    if (!themeSetting) {
        return StandardTheme_1.default;
    }
    else if (themeSetting === true) {
        return JqueryUiTheme_1.default;
    }
    else {
        return themeClassHash[themeSetting];
    }
}
exports.getThemeSystemClass = getThemeSystemClass;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Promise_1 = __webpack_require__(20);
var EventSource_1 = __webpack_require__(6);
var SingleEventDef_1 = __webpack_require__(13);
var ArrayEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(ArrayEventSource, _super);
    function ArrayEventSource(calendar) {
        var _this = _super.call(this, calendar) || this;
        _this.eventDefs = []; // for if setRawEventDefs is never called
        return _this;
    }
    ArrayEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isArray(rawInput.events)) {
            rawProps = rawInput;
        }
        else if ($.isArray(rawInput)) {
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {
        this.rawEventDefs = rawEventDefs;
        this.eventDefs = this.parseEventDefs(rawEventDefs);
    };
    ArrayEventSource.prototype.fetch = function (start, end, timezone) {
        var eventDefs = this.eventDefs;
        var i;
        if (this.currentTimezone != null &&
            this.currentTimezone !== timezone) {
            for (i = 0; i < eventDefs.length; i++) {
                if (eventDefs[i] instanceof SingleEventDef_1.default) {
                    eventDefs[i].rezone();
                }
            }
        }
        this.currentTimezone = timezone;
        return Promise_1.default.resolve(eventDefs);
    };
    ArrayEventSource.prototype.addEventDef = function (eventDef) {
        this.eventDefs.push(eventDef);
    };
    /*
    eventDefId already normalized to a string
    */
    ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {
        return util_1.removeMatching(this.eventDefs, function (eventDef) {
            return eventDef.id === eventDefId;
        });
    };
    ArrayEventSource.prototype.removeAllEventDefs = function () {
        this.eventDefs = [];
    };
    ArrayEventSource.prototype.getPrimitive = function () {
        return this.rawEventDefs;
    };
    ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.setRawEventDefs(rawProps.events);
        return superSuccess;
    };
    return ArrayEventSource;
}(EventSource_1.default));
exports.default = ArrayEventSource;
ArrayEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = /** @class */ (function () {
    function CoordCache(options) {
        this.isHorizontal = false; // whether to query for left/right/width
        this.isVertical = false; // whether to query for top/bottom/height
        this.els = $(options.els);
        this.isHorizontal = options.isHorizontal;
        this.isVertical = options.isVertical;
        this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
    }
    // Queries the els for coordinates and stores them.
    // Call this method before using and of the get* methods below.
    CoordCache.prototype.build = function () {
        var offsetParentEl = this.forcedOffsetParentEl;
        if (!offsetParentEl && this.els.length > 0) {
            offsetParentEl = this.els.eq(0).offsetParent();
        }
        this.origin = offsetParentEl ?
            offsetParentEl.offset() :
            null;
        this.boundingRect = this.queryBoundingRect();
        if (this.isHorizontal) {
            this.buildElHorizontals();
        }
        if (this.isVertical) {
            this.buildElVerticals();
        }
    };
    // Destroys all internal data about coordinates, freeing memory
    CoordCache.prototype.clear = function () {
        this.origin = null;
        this.boundingRect = null;
        this.lefts = null;
        this.rights = null;
        this.tops = null;
        this.bottoms = null;
    };
    // When called, if coord caches aren't built, builds them
    CoordCache.prototype.ensureBuilt = function () {
        if (!this.origin) {
            this.build();
        }
    };
    // Populates the left/right internal coordinate arrays
    CoordCache.prototype.buildElHorizontals = function () {
        var lefts = [];
        var rights = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var left = el.offset().left;
            var width = el.outerWidth();
            lefts.push(left);
            rights.push(left + width);
        });
        this.lefts = lefts;
        this.rights = rights;
    };
    // Populates the top/bottom internal coordinate arrays
    CoordCache.prototype.buildElVerticals = function () {
        var tops = [];
        var bottoms = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var top = el.offset().top;
            var height = el.outerHeight();
            tops.push(top);
            bottoms.push(top + height);
        });
        this.tops = tops;
        this.bottoms = bottoms;
    };
    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getHorizontalIndex = function (leftOffset) {
        this.ensureBuilt();
        var lefts = this.lefts;
        var rights = this.rights;
        var len = lefts.length;
        var i;
        for (i = 0; i < len; i++) {
            if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
                return i;
            }
        }
    };
    // Given a top offset (from document top), returns the index of the el that it vertically intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getVerticalIndex = function (topOffset) {
        this.ensureBuilt();
        var tops = this.tops;
        var bottoms = this.bottoms;
        var len = tops.length;
        var i;
        for (i = 0; i < len; i++) {
            if (topOffset >= tops[i] && topOffset < bottoms[i]) {
                return i;
            }
        }
    };
    // Gets the left offset (from document left) of the element at the given index
    CoordCache.prototype.getLeftOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex];
    };
    // Gets the left position (from offsetParent left) of the element at the given index
    CoordCache.prototype.getLeftPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex] - this.origin.left;
    };
    // Gets the right offset (from document left) of the element at the given index.
    // This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex];
    };
    // Gets the right position (from offsetParent left) of the element at the given index.
    // This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.origin.left;
    };
    // Gets the width of the element at the given index
    CoordCache.prototype.getWidth = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.lefts[leftIndex];
    };
    // Gets the top offset (from document top) of the element at the given index
    CoordCache.prototype.getTopOffset = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex];
    };
    // Gets the top position (from offsetParent top) of the element at the given position
    CoordCache.prototype.getTopPosition = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex] - this.origin.top;
    };
    // Gets the bottom offset (from the document top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomOffset = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex];
    };
    // Gets the bottom position (from the offsetParent top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomPosition = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.origin.top;
    };
    // Gets the height of the element at the given index
    CoordCache.prototype.getHeight = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.tops[topIndex];
    };
    // Bounding Rect
    // TODO: decouple this from CoordCache
    // Compute and return what the elements' bounding rectangle is, from the user's perspective.
    // Right now, only returns a rectangle if constrained by an overflow:scroll element.
    // Returns null if there are no elements
    CoordCache.prototype.queryBoundingRect = function () {
        var scrollParentEl;
        if (this.els.length > 0) {
            scrollParentEl = util_1.getScrollParent(this.els.eq(0));
            if (!scrollParentEl.is(document)) {
                return util_1.getClientRect(scrollParentEl);
            }
        }
        return null;
    };
    CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {
        return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
    };
    CoordCache.prototype.isLeftInBounds = function (leftOffset) {
        return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
    };
    CoordCache.prototype.isTopInBounds = function (topOffset) {
        return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
    };
    return CoordCache;
}());
exports.default = CoordCache;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ListenerMixin_1 = __webpack_require__(7);
var GlobalEmitter_1 = __webpack_require__(21);
/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter
var DragListener = /** @class */ (function () {
    function DragListener(options) {
        this.isInteracting = false;
        this.isDistanceSurpassed = false;
        this.isDelayEnded = false;
        this.isDragging = false;
        this.isTouch = false;
        this.isGeneric = false; // initiated by 'dragstart' (jqui)
        this.shouldCancelTouchScroll = true;
        this.scrollAlwaysKills = false;
        this.isAutoScroll = false;
        // defaults
        this.scrollSensitivity = 30; // pixels from edge for scrolling to start
        this.scrollSpeed = 200; // pixels per second, at maximum speed
        this.scrollIntervalMs = 50; // millisecond wait between scroll increment
        this.options = options || {};
    }
    // Interaction (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startInteraction = function (ev, extraOptions) {
        if (extraOptions === void 0) { extraOptions = {}; }
        if (ev.type === 'mousedown') {
            if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {
                return;
            }
            else if (!util_1.isPrimaryMouseButton(ev)) {
                return;
            }
            else {
                ev.preventDefault(); // prevents native selection in most browsers
            }
        }
        if (!this.isInteracting) {
            // process options
            this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);
            this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);
            this.subjectEl = this.options.subjectEl;
            util_1.preventSelection($('body'));
            this.isInteracting = true;
            this.isTouch = util_1.getEvIsTouch(ev);
            this.isGeneric = ev.type === 'dragstart';
            this.isDelayEnded = false;
            this.isDistanceSurpassed = false;
            this.originX = util_1.getEvX(ev);
            this.originY = util_1.getEvY(ev);
            this.scrollEl = util_1.getScrollParent($(ev.target));
            this.bindHandlers();
            this.initAutoScroll();
            this.handleInteractionStart(ev);
            this.startDelay(ev);
            if (!this.minDistance) {
                this.handleDistanceSurpassed(ev);
            }
        }
    };
    DragListener.prototype.handleInteractionStart = function (ev) {
        this.trigger('interactionStart', ev);
    };
    DragListener.prototype.endInteraction = function (ev, isCancelled) {
        if (this.isInteracting) {
            this.endDrag(ev);
            if (this.delayTimeoutId) {
                clearTimeout(this.delayTimeoutId);
                this.delayTimeoutId = null;
            }
            this.destroyAutoScroll();
            this.unbindHandlers();
            this.isInteracting = false;
            this.handleInteractionEnd(ev, isCancelled);
            util_1.allowSelection($('body'));
        }
    };
    DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        this.trigger('interactionEnd', ev, isCancelled || false);
    };
    // Binding To DOM
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.bindHandlers = function () {
        // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
        // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
        var globalEmitter = GlobalEmitter_1.default.get();
        if (this.isGeneric) {
            this.listenTo($(document), {
                drag: this.handleMove,
                dragstop: this.endInteraction
            });
        }
        else if (this.isTouch) {
            this.listenTo(globalEmitter, {
                touchmove: this.handleTouchMove,
                touchend: this.endInteraction,
                scroll: this.handleTouchScroll
            });
        }
        else {
            this.listenTo(globalEmitter, {
                mousemove: this.handleMouseMove,
                mouseup: this.endInteraction
            });
        }
        this.listenTo(globalEmitter, {
            selectstart: util_1.preventDefault,
            contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools
        });
    };
    DragListener.prototype.unbindHandlers = function () {
        this.stopListeningTo(GlobalEmitter_1.default.get());
        this.stopListeningTo($(document)); // for isGeneric
    };
    // Drag (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    // extraOptions ignored if drag already started
    DragListener.prototype.startDrag = function (ev, extraOptions) {
        this.startInteraction(ev, extraOptions); // ensure interaction began
        if (!this.isDragging) {
            this.isDragging = true;
            this.handleDragStart(ev);
        }
    };
    DragListener.prototype.handleDragStart = function (ev) {
        this.trigger('dragStart', ev);
    };
    DragListener.prototype.handleMove = function (ev) {
        var dx = util_1.getEvX(ev) - this.originX;
        var dy = util_1.getEvY(ev) - this.originY;
        var minDistance = this.minDistance;
        var distanceSq; // current distance from the origin, squared
        if (!this.isDistanceSurpassed) {
            distanceSq = dx * dx + dy * dy;
            if (distanceSq >= minDistance * minDistance) {
                this.handleDistanceSurpassed(ev);
            }
        }
        if (this.isDragging) {
            this.handleDrag(dx, dy, ev);
        }
    };
    // Called while the mouse is being moved and when we know a legitimate drag is taking place
    DragListener.prototype.handleDrag = function (dx, dy, ev) {
        this.trigger('drag', dx, dy, ev);
        this.updateAutoScroll(ev); // will possibly cause scrolling
    };
    DragListener.prototype.endDrag = function (ev) {
        if (this.isDragging) {
            this.isDragging = false;
            this.handleDragEnd(ev);
        }
    };
    DragListener.prototype.handleDragEnd = function (ev) {
        this.trigger('dragEnd', ev);
    };
    // Delay
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startDelay = function (initialEv) {
        var _this = this;
        if (this.delay) {
            this.delayTimeoutId = setTimeout(function () {
                _this.handleDelayEnd(initialEv);
            }, this.delay);
        }
        else {
            this.handleDelayEnd(initialEv);
        }
    };
    DragListener.prototype.handleDelayEnd = function (initialEv) {
        this.isDelayEnded = true;
        if (this.isDistanceSurpassed) {
            this.startDrag(initialEv);
        }
    };
    // Distance
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleDistanceSurpassed = function (ev) {
        this.isDistanceSurpassed = true;
        if (this.isDelayEnded) {
            this.startDrag(ev);
        }
    };
    // Mouse / Touch
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchMove = function (ev) {
        // prevent inertia and touchmove-scrolling while dragging
        if (this.isDragging && this.shouldCancelTouchScroll) {
            ev.preventDefault();
        }
        this.handleMove(ev);
    };
    DragListener.prototype.handleMouseMove = function (ev) {
        this.handleMove(ev);
    };
    // Scrolling (unrelated to auto-scroll)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchScroll = function (ev) {
        // if the drag is being initiated by touch, but a scroll happens before
        // the drag-initiating delay is over, cancel the drag
        if (!this.isDragging || this.scrollAlwaysKills) {
            this.endInteraction(ev, true); // isCancelled=true
        }
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    DragListener.prototype.trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.options[name]) {
            this.options[name].apply(this, args);
        }
        // makes _methods callable by event name. TODO: kill this
        if (this['_' + name]) {
            this['_' + name].apply(this, args);
        }
    };
    // Auto-scroll
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.initAutoScroll = function () {
        var scrollEl = this.scrollEl;
        this.isAutoScroll =
            this.options.scroll &&
                scrollEl &&
                !scrollEl.is(window) &&
                !scrollEl.is(document);
        if (this.isAutoScroll) {
            // debounce makes sure rapid calls don't happen
            this.listenTo(scrollEl, 'scroll', util_1.debounce(this.handleDebouncedScroll, 100));
        }
    };
    DragListener.prototype.destroyAutoScroll = function () {
        this.endAutoScroll(); // kill any animation loop
        // remove the scroll handler if there is a scrollEl
        if (this.isAutoScroll) {
            this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
        }
    };
    // Computes and stores the bounding rectangle of scrollEl
    DragListener.prototype.computeScrollBounds = function () {
        if (this.isAutoScroll) {
            this.scrollBounds = util_1.getOuterRect(this.scrollEl);
            // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
        }
    };
    // Called when the dragging is in progress and scrolling should be updated
    DragListener.prototype.updateAutoScroll = function (ev) {
        var sensitivity = this.scrollSensitivity;
        var bounds = this.scrollBounds;
        var topCloseness;
        var bottomCloseness;
        var leftCloseness;
        var rightCloseness;
        var topVel = 0;
        var leftVel = 0;
        if (bounds) {
            // compute closeness to edges. valid range is from 0.0 - 1.0
            topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;
            bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;
            leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;
            rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;
            // translate vertical closeness into velocity.
            // mouse must be completely in bounds for velocity to happen.
            if (topCloseness >= 0 && topCloseness <= 1) {
                topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
            }
            else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
                topVel = bottomCloseness * this.scrollSpeed;
            }
            // translate horizontal closeness into velocity
            if (leftCloseness >= 0 && leftCloseness <= 1) {
                leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
            }
            else if (rightCloseness >= 0 && rightCloseness <= 1) {
                leftVel = rightCloseness * this.scrollSpeed;
            }
        }
        this.setScrollVel(topVel, leftVel);
    };
    // Sets the speed-of-scrolling for the scrollEl
    DragListener.prototype.setScrollVel = function (topVel, leftVel) {
        this.scrollTopVel = topVel;
        this.scrollLeftVel = leftVel;
        this.constrainScrollVel(); // massages into realistic values
        // if there is non-zero velocity, and an animation loop hasn't already started, then START
        if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
            this.scrollIntervalId = setInterval(util_1.proxy(this, 'scrollIntervalFunc'), // scope to `this`
            this.scrollIntervalMs);
        }
    };
    // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
    DragListener.prototype.constrainScrollVel = function () {
        var el = this.scrollEl;
        if (this.scrollTopVel < 0) {
            if (el.scrollTop() <= 0) {
                this.scrollTopVel = 0;
            }
        }
        else if (this.scrollTopVel > 0) {
            if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {
                this.scrollTopVel = 0;
            }
        }
        if (this.scrollLeftVel < 0) {
            if (el.scrollLeft() <= 0) {
                this.scrollLeftVel = 0;
            }
        }
        else if (this.scrollLeftVel > 0) {
            if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {
                this.scrollLeftVel = 0;
            }
        }
    };
    // This function gets called during every iteration of the scrolling animation loop
    DragListener.prototype.scrollIntervalFunc = function () {
        var el = this.scrollEl;
        var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by
        // change the value of scrollEl's scroll
        if (this.scrollTopVel) {
            el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
        }
        if (this.scrollLeftVel) {
            el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
        }
        this.constrainScrollVel(); // since the scroll values changed, recompute the velocities
        // if scrolled all the way, which causes the vels to be zero, stop the animation loop
        if (!this.scrollTopVel && !this.scrollLeftVel) {
            this.endAutoScroll();
        }
    };
    // Kills any existing scrolling animation loop
    DragListener.prototype.endAutoScroll = function () {
        if (this.scrollIntervalId) {
            clearInterval(this.scrollIntervalId);
            this.scrollIntervalId = null;
            this.handleScrollEnd();
        }
    };
    // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
    DragListener.prototype.handleDebouncedScroll = function () {
        // recompute all coordinates, but *only* if this is *not* part of our scrolling animation
        if (!this.scrollIntervalId) {
            this.handleScrollEnd();
        }
    };
    DragListener.prototype.handleScrollEnd = function () {
        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    };
    return DragListener;
}());
exports.default = DragListener;
ListenerMixin_1.default.mixInto(DragListener);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var Mixin_1 = __webpack_require__(14);
/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = /** @class */ (function (_super) {
    tslib_1.__extends(DayTableMixin, _super);
    function DayTableMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Populates internal variables used for date calculation and rendering
    DayTableMixin.prototype.updateDayTable = function () {
        var t = this;
        var view = t.view;
        var calendar = view.calendar;
        var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);
        var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);
        var dayIndex = -1;
        var dayIndices = [];
        var dayDates = [];
        var daysPerRow;
        var firstDay;
        var rowCnt;
        while (date.isBefore(end)) {
            if (view.isHiddenDay(date)) {
                dayIndices.push(dayIndex + 0.5); // mark that it's between indices
            }
            else {
                dayIndex++;
                dayIndices.push(dayIndex);
                dayDates.push(date.clone());
            }
            date.add(1, 'days');
        }
        if (this.breakOnWeeks) {
            // count columns until the day-of-week repeats
            firstDay = dayDates[0].day();
            for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
                if (dayDates[daysPerRow].day() === firstDay) {
                    break;
                }
            }
            rowCnt = Math.ceil(dayDates.length / daysPerRow);
        }
        else {
            rowCnt = 1;
            daysPerRow = dayDates.length;
        }
        this.dayDates = dayDates;
        this.dayIndices = dayIndices;
        this.daysPerRow = daysPerRow;
        this.rowCnt = rowCnt;
        this.updateDayTableCols();
    };
    // Computes and assigned the colCnt property and updates any options that may be computed from it
    DayTableMixin.prototype.updateDayTableCols = function () {
        this.colCnt = this.computeColCnt();
        this.colHeadFormat =
            this.opt('columnHeaderFormat') ||
                this.opt('columnFormat') || // deprecated
                this.computeColHeadFormat();
    };
    // Determines how many columns there should be in the table
    DayTableMixin.prototype.computeColCnt = function () {
        return this.daysPerRow;
    };
    // Computes the ambiguously-timed moment for the given cell
    DayTableMixin.prototype.getCellDate = function (row, col) {
        return this.dayDates[this.getCellDayIndex(row, col)].clone();
    };
    // Computes the ambiguously-timed date range for the given cell
    DayTableMixin.prototype.getCellRange = function (row, col) {
        var start = this.getCellDate(row, col);
        var end = start.clone().add(1, 'days');
        return { start: start, end: end };
    };
    // Returns the number of day cells, chronologically, from the first of the grid (0-based)
    DayTableMixin.prototype.getCellDayIndex = function (row, col) {
        return row * this.daysPerRow + this.getColDayIndex(col);
    };
    // Returns the numner of day cells, chronologically, from the first cell in *any given row*
    DayTableMixin.prototype.getColDayIndex = function (col) {
        if (this.isRTL) {
            return this.colCnt - 1 - col;
        }
        else {
            return col;
        }
    };
    // Given a date, returns its chronolocial cell-index from the first cell of the grid.
    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
    // If before the first offset, returns a negative number.
    // If after the last offset, returns an offset past the last cell offset.
    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
    DayTableMixin.prototype.getDateDayIndex = function (date) {
        var dayIndices = this.dayIndices;
        var dayOffset = date.diff(this.dayDates[0], 'days');
        if (dayOffset < 0) {
            return dayIndices[0] - 1;
        }
        else if (dayOffset >= dayIndices.length) {
            return dayIndices[dayIndices.length - 1] + 1;
        }
        else {
            return dayIndices[dayOffset];
        }
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes a default column header formatting string if `colFormat` is not explicitly defined
    DayTableMixin.prototype.computeColHeadFormat = function () {
        // if more than one week row, or if there are a lot of columns with not much space,
        // put just the day numbers will be in each cell
        if (this.rowCnt > 1 || this.colCnt > 10) {
            return 'ddd'; // "Sat"
        }
        else if (this.colCnt > 1) {
            return this.opt('dayOfMonthFormat'); // "Sat 12/10"
        }
        else {
            return 'dddd'; // "Saturday"
        }
    };
    /* Slicing
    ------------------------------------------------------------------------------------------------------------------*/
    // Slices up a date range into a segment for every week-row it intersects with
    DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst;
        var rowLast; // inclusive day-index range for current row
        var segFirst;
        var segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            // intersect segment's offset range with the row's
            segFirst = Math.max(rangeFirst, rowFirst);
            segLast = Math.min(rangeLast, rowLast);
            // deal with in-between indices
            segFirst = Math.ceil(segFirst); // in-between starts round to next cell
            segLast = Math.floor(segLast); // in-between ends round to prev cell
            if (segFirst <= segLast) {
                segs.push({
                    row: row,
                    // normalize to start of row
                    firstRowDayIndex: segFirst - rowFirst,
                    lastRowDayIndex: segLast - rowFirst,
                    // must be matching integers to be the segment's start/end
                    isStart: segFirst === rangeFirst,
                    isEnd: segLast === rangeLast
                });
            }
        }
        return segs;
    };
    // Slices up a date range into a segment for every day-cell it intersects with.
    // TODO: make more DRY with sliceRangeByRow somehow.
    DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst;
        var rowLast; // inclusive day-index range for current row
        var i;
        var segFirst;
        var segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            for (i = rowFirst; i <= rowLast; i++) {
                // intersect segment's offset range with the row's
                segFirst = Math.max(rangeFirst, i);
                segLast = Math.min(rangeLast, i);
                // deal with in-between indices
                segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                segLast = Math.floor(segLast); // in-between ends round to prev cell
                if (segFirst <= segLast) {
                    segs.push({
                        row: row,
                        // normalize to start of row
                        firstRowDayIndex: segFirst - rowFirst,
                        lastRowDayIndex: segLast - rowFirst,
                        // must be matching integers to be the segment's start/end
                        isStart: segFirst === rangeFirst,
                        isEnd: segLast === rangeLast
                    });
                }
            }
        }
        return segs;
    };
    /* Header Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderHeadHtml = function () {
        var theme = this.view.calendar.theme;
        return '' +
            '<div class="fc-row ' + theme.getClass('headerRow') + '">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            '<thead>' +
            this.renderHeadTrHtml() +
            '</thead>' +
            '</table>' +
            '</div>';
    };
    DayTableMixin.prototype.renderHeadIntroHtml = function () {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderHeadTrHtml = function () {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderHeadIntroHtml()) +
            this.renderHeadDateCellsHtml() +
            (this.isRTL ? this.renderHeadIntroHtml() : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderHeadDateCellsHtml = function () {
        var htmls = [];
        var col;
        var date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(0, col);
            htmls.push(this.renderHeadDateCellHtml(date));
        }
        return htmls.join('');
    };
    // TODO: when internalApiVersion, accept an object for HTML attributes
    // (colspan should be no different)
    DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classNames = [
            'fc-day-header',
            view.calendar.theme.getClass('widgetHeader')
        ];
        var innerHtml;
        if (typeof t.opt('columnHeaderHtml') === 'function') {
            innerHtml = t.opt('columnHeaderHtml')(date);
        }
        else if (typeof t.opt('columnHeaderText') === 'function') {
            innerHtml = util_1.htmlEscape(t.opt('columnHeaderText')(date));
        }
        else {
            innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));
        }
        // if only one row of days, the classNames on the header can represent the specific days beneath
        if (t.rowCnt === 1) {
            classNames = classNames.concat(
            // includes the day-of-week class
            // noThemeHighlight=true (don't highlight the header)
            t.getDayClasses(date, true));
        }
        else {
            classNames.push('fc-' + util_1.dayIDs[date.day()]); // only add the day-of-week class
        }
        return '' +
            '<th class="' + classNames.join(' ') + '"' +
            ((isDateValid && t.rowCnt) === 1 ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' :
                '') +
            (colspan > 1 ?
                ' colspan="' + colspan + '"' :
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '>' +
            (isDateValid ?
                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
                view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt > 1 || t.colCnt === 1 }, innerHtml) :
                // if not valid, display text, but no link
                innerHtml) +
            '</th>';
    };
    /* Background Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderBgTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderBgIntroHtml(row)) +
            this.renderBgCellsHtml(row) +
            (this.isRTL ? this.renderBgIntroHtml(row) : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderBgIntroHtml = function (row) {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderBgCellsHtml = function (row) {
        var htmls = [];
        var col;
        var date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderBgCellHtml(date));
        }
        return htmls.join('');
    };
    DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classes = t.getDayClasses(date);
        classes.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));
        return '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '></td>';
    };
    /* Generic
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderIntroHtml = function () {
        // Generates the default HTML intro for any row. User classes should override
    };
    // TODO: a generic method for dealing with <tr>, RTL, intro
    // when increment internalApiVersion
    // wrapTr (scheduler)
    /* Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // Applies the generic "intro" and "outro" HTML to the given cells.
    // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
    DayTableMixin.prototype.bookendCells = function (trEl) {
        var introHtml = this.renderIntroHtml();
        if (introHtml) {
            if (this.isRTL) {
                trEl.append(introHtml);
            }
            else {
                trEl.prepend(introHtml);
            }
        }
    };
    return DayTableMixin;
}(Mixin_1.default));
exports.default = DayTableMixin;


/***/ }),
/* 56 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var BusinessHourRenderer = /** @class */ (function () {
    /*
    component implements:
      - eventRangesToEventFootprints
      - eventFootprintsToSegs
    */
    function BusinessHourRenderer(component, fillRenderer) {
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    BusinessHourRenderer.prototype.render = function (businessHourGenerator) {
        var component = this.component;
        var unzonedRange = component._getDateProfile().activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);
        var eventFootprints = eventInstanceGroup ?
            component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :
            [];
        this.renderEventFootprints(eventFootprints);
    };
    BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        this.renderSegs(segs);
        this.segs = segs;
    };
    BusinessHourRenderer.prototype.renderSegs = function (segs) {
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('businessHours', segs, {
                getClasses: function (seg) {
                    return ['fc-nonbusiness', 'fc-bgevent'];
                }
            });
        }
    };
    BusinessHourRenderer.prototype.unrender = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('businessHours');
        }
        this.segs = null;
    };
    BusinessHourRenderer.prototype.getSegs = function () {
        return this.segs || [];
    };
    return BusinessHourRenderer;
}());
exports.default = BusinessHourRenderer;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var FillRenderer = /** @class */ (function () {
    function FillRenderer(component) {
        this.fillSegTag = 'div';
        this.component = component;
        this.elsByFill = {};
    }
    FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {
        this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);
    };
    FillRenderer.prototype.renderSegs = function (type, segs, props) {
        var els;
        segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs
        els = this.attachSegEls(type, segs);
        if (els) {
            this.reportEls(type, els);
        }
        return segs;
    };
    // Unrenders a specific type of fill that is currently rendered on the grid
    FillRenderer.prototype.unrender = function (type) {
        var el = this.elsByFill[type];
        if (el) {
            el.remove();
            delete this.elsByFill[type];
        }
    };
    // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
    // Only returns segments that successfully rendered.
    FillRenderer.prototype.buildSegEls = function (type, segs, props) {
        var _this = this;
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) {
            // build a large concatenation of segment HTML
            for (i = 0; i < segs.length; i++) {
                html += this.buildSegHtml(type, segs[i], props);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                // allow custom filter methods per-type
                if (props.filterEl) {
                    el = props.filterEl(seg, el);
                }
                if (el) {
                    el = $(el); // allow custom filter to return raw DOM node
                    // correct element type? (would be bad if a non-TD were inserted into a table for example)
                    if (el.is(_this.fillSegTag)) {
                        seg.el = el;
                        renderedSegs.push(seg);
                    }
                }
            });
        }
        return renderedSegs;
    };
    // Builds the HTML needed for one fill segment. Generic enough to work with different types.
    FillRenderer.prototype.buildSegHtml = function (type, seg, props) {
        // custom hooks per-type
        var classes = props.getClasses ? props.getClasses(seg) : [];
        var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});
        return '<' + this.fillSegTag +
            (classes.length ? ' class="' + classes.join(' ') + '"' : '') +
            (css ? ' style="' + css + '"' : '') +
            ' />';
    };
    // Should return wrapping DOM structure
    FillRenderer.prototype.attachSegEls = function (type, segs) {
        // subclasses must implement
    };
    FillRenderer.prototype.reportEls = function (type, nodes) {
        if (this.elsByFill[type]) {
            this.elsByFill[type] = this.elsByFill[type].add(nodes);
        }
        else {
            this.elsByFill[type] = $(nodes);
        }
    };
    return FillRenderer;
}());
exports.default = FillRenderer;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventDef_1 = __webpack_require__(13);
var EventFootprint_1 = __webpack_require__(36);
var EventSource_1 = __webpack_require__(6);
var HelperRenderer = /** @class */ (function () {
    function HelperRenderer(component, eventRenderer) {
        this.view = component._getView();
        this.component = component;
        this.eventRenderer = eventRenderer;
    }
    HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {
        this.renderEventFootprints([
            this.fabricateEventFootprint(componentFootprint)
        ]);
    };
    HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-dragging', isTouch ? null : this.view.opt('dragOpacity'));
    };
    HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-resizing');
    };
    HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        var classNames = 'fc-helper ' + (extraClassNames || '');
        var i;
        // assigns each seg's el and returns a subset of segs that were rendered
        segs = this.eventRenderer.renderFgSegEls(segs);
        for (i = 0; i < segs.length; i++) {
            segs[i].el.addClass(classNames);
        }
        if (opacity != null) {
            for (i = 0; i < segs.length; i++) {
                segs[i].el.css('opacity', opacity);
            }
        }
        this.helperEls = this.renderSegs(segs, sourceSeg);
    };
    /*
    Must return all mock event elements
    */
    HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        // Subclasses must implement
    };
    HelperRenderer.prototype.unrender = function () {
        if (this.helperEls) {
            this.helperEls.remove();
            this.helperEls = null;
        }
    };
    HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {
        var calendar = this.view.calendar;
        var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);
        var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));
        var dummyInstance;
        dummyEvent.dateProfile = eventDateProfile;
        dummyInstance = dummyEvent.buildInstance();
        return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);
    };
    return HelperRenderer;
}());
exports.default = HelperRenderer;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var GlobalEmitter_1 = __webpack_require__(21);
var Interaction_1 = __webpack_require__(15);
var EventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(EventPointing, _super);
    function EventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    component must implement:
      - publiclyTrigger
    */
    EventPointing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));
        component.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));
        component.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));
    };
    EventPointing.prototype.handleClick = function (seg, ev) {
        var res = this.component.publiclyTrigger('eventClick', {
            context: seg.el[0],
            args: [seg.footprint.getEventLegacy(), ev, this.view]
        });
        if (res === false) {
            ev.preventDefault();
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused over
    EventPointing.prototype.handleMouseover = function (seg, ev) {
        if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &&
            !this.mousedOverSeg) {
            this.mousedOverSeg = seg;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.addClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseover', {
                context: seg.el[0],
                args: [seg.footprint.getEventLegacy(), ev, this.view]
            });
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused out.
    // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
    EventPointing.prototype.handleMouseout = function (seg, ev) {
        if (this.mousedOverSeg) {
            this.mousedOverSeg = null;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.removeClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseout', {
                context: seg.el[0],
                args: [
                    seg.footprint.getEventLegacy(),
                    ev || {},
                    this.view
                ]
            });
        }
    };
    EventPointing.prototype.end = function () {
        if (this.mousedOverSeg) {
            this.handleMouseout(this.mousedOverSeg);
        }
    };
    return EventPointing;
}(Interaction_1.default));
exports.default = EventPointing;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Mixin_1 = __webpack_require__(14);
var DateClicking_1 = __webpack_require__(245);
var DateSelecting_1 = __webpack_require__(225);
var EventPointing_1 = __webpack_require__(59);
var EventDragging_1 = __webpack_require__(224);
var EventResizing_1 = __webpack_require__(223);
var ExternalDropping_1 = __webpack_require__(222);
var StandardInteractionsMixin = /** @class */ (function (_super) {
    tslib_1.__extends(StandardInteractionsMixin, _super);
    function StandardInteractionsMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardInteractionsMixin;
}(Mixin_1.default));
exports.default = StandardInteractionsMixin;
StandardInteractionsMixin.prototype.dateClickingClass = DateClicking_1.default;
StandardInteractionsMixin.prototype.dateSelectingClass = DateSelecting_1.default;
StandardInteractionsMixin.prototype.eventPointingClass = EventPointing_1.default;
StandardInteractionsMixin.prototype.eventDraggingClass = EventDragging_1.default;
StandardInteractionsMixin.prototype.eventResizingClass = EventResizing_1.default;
StandardInteractionsMixin.prototype.externalDroppingClass = ExternalDropping_1.default;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var CoordCache_1 = __webpack_require__(53);
var Popover_1 = __webpack_require__(249);
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var EventFootprint_1 = __webpack_require__(36);
var BusinessHourRenderer_1 = __webpack_require__(56);
var StandardInteractionsMixin_1 = __webpack_require__(60);
var InteractiveDateComponent_1 = __webpack_require__(40);
var DayTableMixin_1 = __webpack_require__(55);
var DayGridEventRenderer_1 = __webpack_require__(250);
var DayGridHelperRenderer_1 = __webpack_require__(251);
var DayGridFillRenderer_1 = __webpack_require__(252);
/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/
var DayGrid = /** @class */ (function (_super) {
    tslib_1.__extends(DayGrid, _super);
    function DayGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.cellWeekNumbersVisible = false; // display week numbers in day cell?
        _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid
        // isRigid determines whether the individual rows should ignore the contents and be a constant height.
        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
        _this.isRigid = false;
        _this.hasAllDayBusinessHours = true;
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (this.isRTL) {
                seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
                seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
            }
            else {
                seg.leftCol = seg.firstRowDayIndex;
                seg.rightCol = seg.lastRowDayIndex;
            }
        }
        return segs;
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderGrid();
    };
    DayGrid.prototype.unrenderDates = function () {
        this.removeSegPopover();
    };
    // Renders the rows and columns into the component's `this.el`, which should already be assigned.
    DayGrid.prototype.renderGrid = function () {
        var view = this.view;
        var rowCnt = this.rowCnt;
        var colCnt = this.colCnt;
        var html = '';
        var row;
        var col;
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        for (row = 0; row < rowCnt; row++) {
            html += this.renderDayRowHtml(row, this.isRigid);
        }
        this.el.html(html);
        this.rowEls = this.el.find('.fc-row');
        this.cellEls = this.el.find('.fc-day, .fc-disabled-day');
        this.rowCoordCache = new CoordCache_1.default({
            els: this.rowEls,
            isVertical: true
        });
        this.colCoordCache = new CoordCache_1.default({
            els: this.cellEls.slice(0, this.colCnt),
            isHorizontal: true
        });
        // trigger dayRender with each cell's element
        for (row = 0; row < rowCnt; row++) {
            for (col = 0; col < colCnt; col++) {
                this.publiclyTrigger('dayRender', {
                    context: view,
                    args: [
                        this.getCellDate(row, col),
                        this.getCellEl(row, col),
                        view
                    ]
                });
            }
        }
    };
    // Generates the HTML for a single row, which is a div that wraps a table.
    // `row` is the row number.
    DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
        var theme = this.view.calendar.theme;
        var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];
        if (isRigid) {
            classes.push('fc-rigid');
        }
        return '' +
            '<div class="' + classes.join(' ') + '">' +
            '<div class="fc-bg">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(row) +
            '</table>' +
            '</div>' +
            '<div class="fc-content-skeleton">' +
            '<table>' +
            (this.getIsNumbersVisible() ?
                '<thead>' +
                    this.renderNumberTrHtml(row) +
                    '</thead>' :
                '') +
            '</table>' +
            '</div>' +
            '</div>';
    };
    DayGrid.prototype.getIsNumbersVisible = function () {
        return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;
    };
    DayGrid.prototype.getIsDayNumbersVisible = function () {
        return this.rowCnt > 1;
    };
    /* Grid Number Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderNumberTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
            this.renderNumberCellsHtml(row) +
            (this.isRTL ? this.renderNumberIntroHtml(row) : '') +
            '</tr>';
    };
    DayGrid.prototype.renderNumberIntroHtml = function (row) {
        return this.renderIntroHtml();
    };
    DayGrid.prototype.renderNumberCellsHtml = function (row) {
        var htmls = [];
        var col;
        var date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderNumberCellHtml(date));
        }
        return htmls.join('');
    };
    // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
    // The number row will only exist if either day numbers or week numbers are turned on.
    DayGrid.prototype.renderNumberCellHtml = function (date) {
        var view = this.view;
        var html = '';
        var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;
        var classes;
        var weekCalcFirstDoW;
        if (!isDayNumberVisible && !this.cellWeekNumbersVisible) {
            // no numbers in day cell (week number must be along the side)
            return '<td/>'; //  will create an empty space above events :(
        }
        classes = this.getDayClasses(date);
        classes.unshift('fc-day-top');
        if (this.cellWeekNumbersVisible) {
            // To determine the day of week number change under ISO, we cannot
            // rely on moment.js methods such as firstDayOfWeek() or weekday(),
            // because they rely on the locale's dow (possibly overridden by
            // our firstDay option), which may not be Monday. We cannot change
            // dow, because that would affect the calendar start day as well.
            if (date._locale._fullCalendar_weekCalc === 'ISO') {
                weekCalcFirstDoW = 1; // Monday by ISO 8601 definition
            }
            else {
                weekCalcFirstDoW = date._locale.firstDayOfWeek();
            }
        }
        html += '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format() + '"' :
                '') +
            '>';
        if (this.cellWeekNumbersVisible && (date.day() === weekCalcFirstDoW)) {
            html += view.buildGotoAnchorHtml({ date: date, type: 'week' }, { 'class': 'fc-week-number' }, date.format('w') // inner HTML
            );
        }
        if (isDayNumberVisible) {
            html += view.buildGotoAnchorHtml(date, { 'class': 'fc-day-number' }, date.format('D') // inner HTML
            );
        }
        html += '</td>';
        return html;
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.rowCoordCache.build();
        this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
    };
    DayGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        this.rowCoordCache.clear();
    };
    DayGrid.prototype.queryHit = function (leftOffset, topOffset) {
        if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
            var col = this.colCoordCache.getHorizontalIndex(leftOffset);
            var row = this.rowCoordCache.getVerticalIndex(topOffset);
            if (row != null && col != null) {
                return this.getCellHit(row, col);
            }
        }
    };
    DayGrid.prototype.getHitFootprint = function (hit) {
        var range = this.getCellRange(hit.row, hit.col);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?
        );
    };
    DayGrid.prototype.getHitEl = function (hit) {
        return this.getCellEl(hit.row, hit.col);
    };
    /* Cell System
    ------------------------------------------------------------------------------------------------------------------*/
    // FYI: the first column is the leftmost column, regardless of date
    DayGrid.prototype.getCellHit = function (row, col) {
        return {
            row: row,
            col: col,
            component: this,
            left: this.colCoordCache.getLeftOffset(col),
            right: this.colCoordCache.getRightOffset(col),
            top: this.rowCoordCache.getTopOffset(row),
            bottom: this.rowCoordCache.getBottomOffset(row)
        };
    };
    DayGrid.prototype.getCellEl = function (row, col) {
        return this.cellEls.eq(row * this.colCnt + col);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    // Unrenders all events currently rendered on the grid
    DayGrid.prototype.executeEventUnrender = function () {
        this.removeSegPopover(); // removes the "more.." events popover
        _super.prototype.executeEventUnrender.call(this);
    };
    // Retrieves all rendered segment objects currently rendered on the grid
    DayGrid.prototype.getOwnEventSegs = function () {
        // append the segments from the "more..." popover
        return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event or external element being dragged.
    // `eventLocation` has zoned start and end (optional)
    DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        // render drags from OTHER components as helpers
        if (eventFootprints.length && seg && seg.component !== this) {
            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
            return true; // signal helpers rendered
        }
    };
    // Unrenders any visual indication of a hovering event
    DayGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders a visual indication of an event being resized
    DayGrid.prototype.unrenderEventResize = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* More+ Link Popover
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.removeSegPopover = function () {
        if (this.segPopover) {
            this.segPopover.hide(); // in handler, will call segPopover's removeElement
        }
    };
    // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
    // `levelLimit` can be false (don't limit), a number, or true (should be computed).
    DayGrid.prototype.limitRows = function (levelLimit) {
        var rowStructs = this.eventRenderer.rowStructs || [];
        var row; // row #
        var rowLevelLimit;
        for (row = 0; row < rowStructs.length; row++) {
            this.unlimitRow(row);
            if (!levelLimit) {
                rowLevelLimit = false;
            }
            else if (typeof levelLimit === 'number') {
                rowLevelLimit = levelLimit;
            }
            else {
                rowLevelLimit = this.computeRowLevelLimit(row);
            }
            if (rowLevelLimit !== false) {
                this.limitRow(row, rowLevelLimit);
            }
        }
    };
    // Computes the number of levels a row will accomodate without going outside its bounds.
    // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
    // `row` is the row number.
    DayGrid.prototype.computeRowLevelLimit = function (row) {
        var rowEl = this.rowEls.eq(row); // the containing "fake" row div
        var rowHeight = rowEl.height(); // TODO: cache somehow?
        var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();
        var i;
        var trEl;
        var trHeight;
        function iterInnerHeights(i, childNode) {
            trHeight = Math.max(trHeight, $(childNode).outerHeight());
        }
        // Reveal one level <tr> at a time and stop when we find one out of bounds
        for (i = 0; i < trEls.length; i++) {
            trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)
            // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
            // so instead, find the tallest inner content element.
            trHeight = 0;
            trEl.find('> td > :first-child').each(iterInnerHeights);
            if (trEl.position().top + trHeight > rowHeight) {
                return i;
            }
        }
        return false; // should not limit at all
    };
    // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
    // `row` is the row number.
    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
    DayGrid.prototype.limitRow = function (row, levelLimit) {
        var _this = this;
        var rowStruct = this.eventRenderer.rowStructs[row];
        var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
        var col = 0; // col #, left-to-right (not chronologically)
        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
        var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
        var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
        var i;
        var seg;
        var segsBelow; // array of segment objects below `seg` in the current `col`
        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
        var td;
        var rowspan;
        var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
        var j;
        var moreTd;
        var moreWrap;
        var moreLink;
        // Iterates through empty level cells and places "more" links inside if need be
        var emptyCellsUntil = function (endCol) {
            while (col < endCol) {
                segsBelow = _this.getCellSegs(row, col, levelLimit);
                if (segsBelow.length) {
                    td = cellMatrix[levelLimit - 1][col];
                    moreLink = _this.renderMoreLink(row, col, segsBelow);
                    moreWrap = $('<div/>').append(moreLink);
                    td.append(moreWrap);
                    moreNodes.push(moreWrap[0]);
                }
                col++;
            }
        };
        if (levelLimit && levelLimit < rowStruct.segLevels.length) {
            levelSegs = rowStruct.segLevels[levelLimit - 1];
            cellMatrix = rowStruct.cellMatrix;
            limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
                .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array
            // iterate though segments in the last allowable level
            for (i = 0; i < levelSegs.length; i++) {
                seg = levelSegs[i];
                emptyCellsUntil(seg.leftCol); // process empty cells before the segment
                // determine *all* segments below `seg` that occupy the same columns
                colSegsBelow = [];
                totalSegsBelow = 0;
                while (col <= seg.rightCol) {
                    segsBelow = this.getCellSegs(row, col, levelLimit);
                    colSegsBelow.push(segsBelow);
                    totalSegsBelow += segsBelow.length;
                    col++;
                }
                if (totalSegsBelow) {
                    td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
                    rowspan = td.attr('rowspan') || 1;
                    segMoreNodes = [];
                    // make a replacement <td> for each column the segment occupies. will be one for each colspan
                    for (j = 0; j < colSegsBelow.length; j++) {
                        moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
                        segsBelow = colSegsBelow[j];
                        moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
                        );
                        moreWrap = $('<div/>').append(moreLink);
                        moreTd.append(moreWrap);
                        segMoreNodes.push(moreTd[0]);
                        moreNodes.push(moreTd[0]);
                    }
                    td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
                    limitedNodes.push(td[0]);
                }
            }
            emptyCellsUntil(this.colCnt); // finish off the level
            rowStruct.moreEls = $(moreNodes); // for easy undoing later
            rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
        }
    };
    // Reveals all levels and removes all "more"-related elements for a grid's row.
    // `row` is a row number.
    DayGrid.prototype.unlimitRow = function (row) {
        var rowStruct = this.eventRenderer.rowStructs[row];
        if (rowStruct.moreEls) {
            rowStruct.moreEls.remove();
            rowStruct.moreEls = null;
        }
        if (rowStruct.limitedEls) {
            rowStruct.limitedEls.removeClass('fc-limited');
            rowStruct.limitedEls = null;
        }
    };
    // Renders an <a> element that represents hidden event element for a cell.
    // Responsible for attaching click handler as well.
    DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
        var _this = this;
        var view = this.view;
        return $('<a class="fc-more"/>')
            .text(this.getMoreLinkText(hiddenSegs.length))
            .on('click', function (ev) {
            var clickOption = _this.opt('eventLimitClick');
            var date = _this.getCellDate(row, col);
            var moreEl = $(ev.currentTarget);
            var dayEl = _this.getCellEl(row, col);
            var allSegs = _this.getCellSegs(row, col);
            // rescope the segments to be within the cell's date
            var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
            var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
            if (typeof clickOption === 'function') {
                // the returned value can be an atomic option
                clickOption = _this.publiclyTrigger('eventLimitClick', {
                    context: view,
                    args: [
                        {
                            date: date.clone(),
                            dayEl: dayEl,
                            moreEl: moreEl,
                            segs: reslicedAllSegs,
                            hiddenSegs: reslicedHiddenSegs
                        },
                        ev,
                        view
                    ]
                });
            }
            if (clickOption === 'popover') {
                _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
            }
            else if (typeof clickOption === 'string') {
                view.calendar.zoomTo(date, clickOption);
            }
        });
    };
    // Reveals the popover that displays all events within a cell
    DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
        var _this = this;
        var view = this.view;
        var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
        var topEl; // the element we want to match the top coordinate of
        var options;
        if (this.rowCnt === 1) {
            topEl = view.el; // will cause the popover to cover any sort of header
        }
        else {
            topEl = this.rowEls.eq(row); // will align with top of row
        }
        options = {
            className: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),
            content: this.renderSegPopoverContent(row, col, segs),
            parentEl: view.el,
            top: topEl.offset().top,
            autoHide: true,
            viewportConstrain: this.opt('popoverViewportConstrain'),
            hide: function () {
                // kill everything when the popover is hidden
                // notify events to be removed
                if (_this.popoverSegs) {
                    _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);
                }
                _this.segPopover.removeElement();
                _this.segPopover = null;
                _this.popoverSegs = null;
            }
        };
        // Determine horizontal coordinate.
        // We use the moreWrap instead of the <td> to avoid border confusion.
        if (this.isRTL) {
            options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
        }
        else {
            options.left = moreWrap.offset().left - 1; // -1 to be over cell border
        }
        this.segPopover = new Popover_1.default(options);
        this.segPopover.show();
        // the popover doesn't live within the grid's container element, and thus won't get the event
        // delegated-handlers for free. attach event-related handlers to the popover.
        this.bindAllSegHandlersToEl(this.segPopover.el);
        this.triggerAfterEventSegsRendered(segs);
    };
    // Builds the inner DOM contents of the segment popover
    DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {
        var view = this.view;
        var theme = view.calendar.theme;
        var title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));
        var content = $('<div class="fc-header ' + theme.getClass('popoverHeader') + '">' +
            '<span class="fc-close ' + theme.getIconClass('close') + '"></span>' +
            '<span class="fc-title">' +
            util_1.htmlEscape(title) +
            '</span>' +
            '<div class="fc-clear"/>' +
            '</div>' +
            '<div class="fc-body ' + theme.getClass('popoverContent') + '">' +
            '<div class="fc-event-container"></div>' +
            '</div>');
        var segContainer = content.find('.fc-event-container');
        var i;
        // render each seg's `el` and only return the visible segs
        segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true
        this.popoverSegs = segs;
        for (i = 0; i < segs.length; i++) {
            // because segments in the popover are not part of a grid coordinate system, provide a hint to any
            // grids that want to do drag-n-drop about which cell it came from
            this.hitsNeeded();
            segs[i].hit = this.getCellHit(row, col);
            this.hitsNotNeeded();
            segContainer.append(segs[i].el);
        }
        return content;
    };
    // Given the events within an array of segment objects, reslice them to be in a single day
    DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
        var dayStart = dayDate.clone();
        var dayEnd = dayStart.clone().add(1, 'days');
        var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);
        var newSegs = [];
        var i;
        var seg;
        var slicedRange;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);
            if (slicedRange) {
                newSegs.push($.extend({}, seg, {
                    footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),
                    isStart: seg.isStart && slicedRange.isStart,
                    isEnd: seg.isEnd && slicedRange.isEnd
                }));
            }
        }
        // force an order because eventsToSegs doesn't guarantee one
        // TODO: research if still needed
        this.eventRenderer.sortEventSegs(newSegs);
        return newSegs;
    };
    // Generates the text that should be inside a "more" link, given the number of events it represents
    DayGrid.prototype.getMoreLinkText = function (num) {
        var opt = this.opt('eventLimitText');
        if (typeof opt === 'function') {
            return opt(num);
        }
        else {
            return '+' + num + ' ' + opt;
        }
    };
    // Returns segments within a given cell.
    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
    DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
        var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
        var level = startLevel || 0;
        var segs = [];
        var seg;
        while (level < segMatrix.length) {
            seg = segMatrix[level][col];
            if (seg) {
                segs.push(seg);
            }
            level++;
        }
        return segs;
    };
    return DayGrid;
}(InteractiveDateComponent_1.default));
exports.default = DayGrid;
DayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;
DayGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
DayGrid.prototype.helperRendererClass = DayGridHelperRenderer_1.default;
DayGrid.prototype.fillRendererClass = DayGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(DayGrid);
DayTableMixin_1.default.mixInto(DayGrid);


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Scroller_1 = __webpack_require__(39);
var View_1 = __webpack_require__(41);
var BasicViewDateProfileGenerator_1 = __webpack_require__(228);
var DayGrid_1 = __webpack_require__(61);
/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
var BasicView = /** @class */ (function (_super) {
    tslib_1.__extends(BasicView, _super);
    function BasicView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.dayGrid = _this.instantiateDayGrid();
        _this.dayGrid.isRigid = _this.hasRigidRows();
        if (_this.opt('weekNumbers')) {
            if (_this.opt('weekNumbersWithinDays')) {
                _this.dayGrid.cellWeekNumbersVisible = true;
                _this.dayGrid.colWeekNumbersVisible = false;
            }
            else {
                _this.dayGrid.cellWeekNumbersVisible = false;
                _this.dayGrid.colWeekNumbersVisible = true;
            }
        }
        _this.addChild(_this.dayGrid);
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Generates the DayGrid object this view needs. Draws from this.dayGridClass
    BasicView.prototype.instantiateDayGrid = function () {
        // generate a subclass on the fly with BasicView-specific behavior
        // TODO: cache this subclass
        var subclass = makeDayGridSubclass(this.dayGridClass);
        return new subclass(this);
    };
    BasicView.prototype.executeDateRender = function (dateProfile) {
        this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);
        _super.prototype.executeDateRender.call(this, dateProfile);
    };
    BasicView.prototype.renderSkeleton = function () {
        var dayGridContainerEl;
        var dayGridEl;
        this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
        dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
        this.el.find('.fc-body > tr > td').append(dayGridContainerEl);
        this.dayGrid.headContainerEl = this.el.find('.fc-head-container');
        this.dayGrid.setElement(dayGridEl);
    };
    BasicView.prototype.unrenderSkeleton = function () {
        this.dayGrid.removeElement();
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid component will render inside of a container defined by this HTML.
    BasicView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '"></td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the week number column, if it is known
    BasicView.prototype.weekNumberStyleAttr = function () {
        if (this.weekNumberWidth != null) {
            return 'style="width:' + this.weekNumberWidth + 'px"';
        }
        return '';
    };
    // Determines whether each row should have a constant height
    BasicView.prototype.hasRigidRows = function () {
        var eventLimit = this.opt('eventLimit');
        return eventLimit && typeof eventLimit !== 'number';
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Refreshes the horizontal dimensions of the view
    BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit = this.opt('eventLimit');
        var headRowEl = this.dayGrid.headContainerEl.find('.fc-row');
        var scrollerHeight;
        var scrollbarWidths;
        // hack to give the view some height prior to dayGrid's columns being rendered
        // TODO: separate setting height from scroller VS dayGrid.
        if (!this.dayGrid.rowEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        if (this.dayGrid.colWeekNumbersVisible) {
            // Make sure all week number cells running down the side have the same width.
            // Record the width for cells created later.
            this.weekNumberWidth = util_1.matchCellWidths(this.el.find('.fc-week-number'));
        }
        // reset all heights to be natural
        this.scroller.clear();
        util_1.uncompensateScroll(headRowEl);
        this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
        // is the event limit a constant level number?
        if (eventLimit && typeof eventLimit === 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
        }
        // distribute the height to the rows
        // (totalHeight is a "recommended" value if isAuto)
        scrollerHeight = this.computeScrollerHeight(totalHeight);
        this.setGridHeight(scrollerHeight, isAuto);
        // is the event limit dynamically calculated?
        if (eventLimit && typeof eventLimit !== 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
        }
        if (!isAuto) {
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) {
                util_1.compensateScroll(headRowEl, scrollbarWidths);
                // doing the scrollbar compensation might have created text overflow which created more height. redo
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    BasicView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    // Sets the height of just the DayGrid component in this view
    BasicView.prototype.setGridHeight = function (height, isAuto) {
        if (isAuto) {
            util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
        }
        else {
            util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
        }
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    BasicView.prototype.computeInitialDateScroll = function () {
        return { top: 0 };
    };
    BasicView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    BasicView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    return BasicView;
}(View_1.default));
exports.default = BasicView;
BasicView.prototype.dateProfileGeneratorClass = BasicViewDateProfileGenerator_1.default;
BasicView.prototype.dayGridClass = DayGrid_1.default;
// customize the rendering behavior of BasicView's dayGrid
function makeDayGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colWeekNumbersVisible = false; // display week numbers along the side?
            return _this;
        }
        // Generates the HTML that will go before the day-of week header cells
        SubClass.prototype.renderHeadIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<th class="fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '" ' + view.weekNumberStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    util_1.htmlEscape(this.opt('weekNumberTitle')) +
                    '</span>' +
                    '</th>';
            }
            return '';
        };
        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers
        SubClass.prototype.renderNumberIntroHtml = function (row) {
            var view = this.view;
            var weekStart = this.getCellDate(row, 0);
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                    { date: weekStart, type: 'week', forceOff: this.colCnt === 1 }, weekStart.format('w') // inner HTML
                    ) +
                    '</td>';
            }
            return '';
        };
        // Generates the HTML that goes before the day bg cells for each day-row
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '" ' +
                    view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        // Generates the HTML that goes before every other type of row generated by DayGrid.
        // Affects helper-skeleton and highlight-skeleton rows.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        SubClass.prototype.getIsNumbersVisible = function () {
            return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;
        };
        return SubClass;
    }(SuperClass));
}


/***/ }),
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var EventDefParser_1 = __webpack_require__(49);
var EventSource_1 = __webpack_require__(6);
var util_1 = __webpack_require__(35);
var Constraints = /** @class */ (function () {
    function Constraints(eventManager, _calendar) {
        this.eventManager = eventManager;
        this._calendar = _calendar;
    }
    Constraints.prototype.opt = function (name) {
        return this._calendar.opt(name);
    };
    /*
    determines if eventInstanceGroup is allowed,
    in relation to other EVENTS and business hours.
    */
    Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var eventDef = eventInstanceGroup.getEventDef();
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        var peerEventInstances = this.getPeerEventInstances(eventDef);
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var constraintVal = eventDef.getConstraint();
        var overlapVal = eventDef.getOverlap();
        var eventAllowFunc = this.opt('eventAllow');
        for (i = 0; i < eventFootprints.length; i++) {
            if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {
                return false;
            }
        }
        if (eventAllowFunc) {
            for (i = 0; i < eventFootprints.length; i++) {
                if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {
                    return false;
                }
            }
        }
        return true;
    };
    Constraints.prototype.getPeerEventInstances = function (eventDef) {
        return this.eventManager.getEventInstancesWithoutId(eventDef.id);
    };
    Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        var peerEventInstances = this.eventManager.getEventInstances();
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var selectAllowFunc;
        if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt('selectConstraint'), this.opt('selectOverlap'))) {
            selectAllowFunc = this.opt('selectAllow');
            if (selectAllowFunc) {
                return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional
    ) {
        var constraintFootprints; // ComponentFootprint[]
        var overlapEventFootprints; // EventFootprint[]
        if (constraintVal != null) {
            constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);
            if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {
                return false;
            }
        }
        overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);
        if (overlapVal === false) {
            if (overlapEventFootprints.length) {
                return false;
            }
        }
        else if (typeof overlapVal === 'function') {
            if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {
                return false;
            }
        }
        if (subjectEventInstance) {
            if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {
                return false;
            }
        }
        return true;
    };
    // Constraint
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {
        var i;
        for (i = 0; i < constraintFootprints.length; i++) {
            if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {
        var eventInstances;
        if (constraintVal === 'businessHours') {
            return this.buildCurrentBusinessFootprints(isAllDay);
        }
        else if (typeof constraintVal === 'object') {
            eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events
            if (!eventInstances) {
                return this.parseFootprints(constraintVal);
            }
            else {
                return this.eventInstancesToFootprints(eventInstances);
            }
        }
        else if (constraintVal != null) {
            eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);
            return this.eventInstancesToFootprints(eventInstances);
        }
    };
    // returns ComponentFootprint[]
    // uses current view's range
    Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {
        var view = this._calendar.view;
        var businessHourGenerator = view.get('businessHourGenerator');
        var unzonedRange = view.dateProfile.activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);
        if (eventInstanceGroup) {
            return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);
        }
        else {
            return [];
        }
    };
    // conversion util
    Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {
        var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);
        var eventFootprints = this.eventRangesToEventFootprints(eventRanges);
        return eventFootprints.map(util_1.eventFootprintToComponentFootprint);
    };
    // Overlap
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {
        var overlapEventFootprints = [];
        var i;
        for (i = 0; i < peerEventFootprints.length; i++) {
            if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {
                overlapEventFootprints.push(peerEventFootprints[i]);
            }
        }
        return overlapEventFootprints;
    };
    // Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints
    // ------------------------------------------------------------------------------------------------
    // NOTE: this might seem like repetitive code with the Grid class, however, this code is related to
    // constraints whereas the Grid code is related to rendering. Each approach might want to convert
    // eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make
    // this more DRY.
    /*
    Returns false on invalid input.
    */
    Constraints.prototype.parseEventDefToInstances = function (eventInput) {
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));
        if (!eventDef) {
            return false;
        }
        return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);
    };
    Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var i;
        var eventFootprints = [];
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// footprints
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_1.eventRangeToEventFootprint(eventRange)];
    };
    /*
    Parses footprints directly.
    Very similar to EventDateProfile::parse :(
    */
    Constraints.prototype.parseFootprints = function (rawInput) {
        var start;
        var end;
        if (rawInput.start) {
            start = this._calendar.moment(rawInput.start);
            if (!start.isValid()) {
                start = null;
            }
        }
        if (rawInput.end) {
            end = this._calendar.moment(rawInput.end);
            if (!end.isValid()) {
                end = null;
            }
        }
        return [
            new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay
            )
        ];
    };
    // Footprint Utils
    // ----------------------------------------------------------------------------------------
    Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {
        return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);
    };
    Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {
        return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);
    };
    return Constraints;
}());
exports.default = Constraints;
// optional subjectEventInstance
function isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {
    var i;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {
            return false;
        }
    }
    return true;
}
function isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {
    var subjectLegacyInstance = subjectEventInstance.toLegacy();
    var i;
    var overlapEventInstance;
    var overlapEventDef;
    var overlapVal;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        overlapEventInstance = overlapEventFootprints[i].eventInstance;
        overlapEventDef = overlapEventInstance.def;
        // don't need to pass in calendar, because don't want to consider global eventOverlap property,
        // because we already considered that earlier in the process.
        overlapVal = overlapEventDef.getOverlap();
        if (overlapVal === false) {
            return false;
        }
        else if (typeof overlapVal === 'function') {
            if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
  import { default as ParsableModelMixin, ParsableModelInterface } from './ParsableModelMixin'
in class:
  applyProps: ParsableModelInterface['applyProps']
  applyManualStandardProps: ParsableModelInterface['applyManualStandardProps']
  applyMiscProps: ParsableModelInterface['applyMiscProps']
  isStandardProp: ParsableModelInterface['isStandardProp']
  static defineStandardProps = ParsableModelMixin.defineStandardProps
  static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps
after class:
  ParsableModelMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var Mixin_1 = __webpack_require__(14);
var ParsableModelMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ParsableModelMixin, _super);
    function ParsableModelMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ParsableModelMixin.defineStandardProps = function (propDefs) {
        var proto = this.prototype;
        if (!proto.hasOwnProperty('standardPropMap')) {
            proto.standardPropMap = Object.create(proto.standardPropMap);
        }
        util_1.copyOwnProps(propDefs, proto.standardPropMap);
    };
    ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {
        var map = this.prototype.standardPropMap;
        var propName;
        for (propName in map) {
            if (src[propName] != null && // in the src object?
                map[propName] === true // false means "copy verbatim"
            ) {
                dest[propName] = src[propName];
            }
        }
    };
    /*
    Returns true/false for success.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyProps = function (rawProps) {
        var standardPropMap = this.standardPropMap;
        var manualProps = {};
        var miscProps = {};
        var propName;
        for (propName in rawProps) {
            if (standardPropMap[propName] === true) {
                this[propName] = rawProps[propName];
            }
            else if (standardPropMap[propName] === false) {
                manualProps[propName] = rawProps[propName];
            }
            else {
                miscProps[propName] = rawProps[propName];
            }
        }
        this.applyMiscProps(miscProps);
        return this.applyManualStandardProps(manualProps);
    };
    /*
    If subclasses override, they must call this supermethod and return the boolean response.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {
        return true;
    };
    /*
    Can be called even after initial object creation.
    */
    ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {
        // subclasses can implement
    };
    /*
    TODO: why is this a method when defineStandardProps is static
    */
    ParsableModelMixin.prototype.isStandardProp = function (propName) {
        return propName in this.standardPropMap;
    };
    return ParsableModelMixin;
}(Mixin_1.default));
exports.default = ParsableModelMixin;
ParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by defineStandardProps


/***/ }),
/* 209 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventInstance = /** @class */ (function () {
    function EventInstance(def, dateProfile) {
        this.def = def;
        this.dateProfile = dateProfile;
    }
    EventInstance.prototype.toLegacy = function () {
        var dateProfile = this.dateProfile;
        var obj = this.def.toLegacy();
        obj.start = dateProfile.start.clone();
        obj.end = dateProfile.end ? dateProfile.end.clone() : null;
        return obj;
    };
    return EventInstance;
}());
exports.default = EventInstance;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var EventDef_1 = __webpack_require__(34);
var EventInstance_1 = __webpack_require__(209);
var EventDateProfile_1 = __webpack_require__(17);
var RecurringEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(RecurringEventDef, _super);
    function RecurringEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RecurringEventDef.prototype.isAllDay = function () {
        return !this.startTime && !this.endTime;
    };
    RecurringEventDef.prototype.buildInstances = function (unzonedRange) {
        var calendar = this.source.calendar;
        var unzonedDate = unzonedRange.getStart();
        var unzonedEnd = unzonedRange.getEnd();
        var zonedDayStart;
        var instanceStart;
        var instanceEnd;
        var instances = [];
        while (unzonedDate.isBefore(unzonedEnd)) {
            // if everyday, or this particular day-of-week
            if (!this.dowHash || this.dowHash[unzonedDate.day()]) {
                zonedDayStart = calendar.applyTimezone(unzonedDate);
                instanceStart = zonedDayStart.clone();
                instanceEnd = null;
                if (this.startTime) {
                    instanceStart.time(this.startTime);
                }
                else {
                    instanceStart.stripTime();
                }
                if (this.endTime) {
                    instanceEnd = zonedDayStart.clone().time(this.endTime);
                }
                instances.push(new EventInstance_1.default(this, // definition
                new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));
            }
            unzonedDate.add(1, 'days');
        }
        return instances;
    };
    RecurringEventDef.prototype.setDow = function (dowNumbers) {
        if (!this.dowHash) {
            this.dowHash = {};
        }
        for (var i = 0; i < dowNumbers.length; i++) {
            this.dowHash[dowNumbers[i]] = true;
        }
    };
    RecurringEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        if (def.startTime) {
            def.startTime = moment.duration(this.startTime);
        }
        if (def.endTime) {
            def.endTime = moment.duration(this.endTime);
        }
        if (this.dowHash) {
            def.dowHash = $.extend({}, this.dowHash);
        }
        return def;
    };
    return RecurringEventDef;
}(EventDef_1.default));
exports.default = RecurringEventDef;
/*
HACK to work with TypeScript mixins
NOTE: if super-method fails, should still attempt to apply
*/
RecurringEventDef.prototype.applyProps = function (rawProps) {
    var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);
    if (rawProps.start) {
        this.startTime = moment.duration(rawProps.start);
    }
    if (rawProps.end) {
        this.endTime = moment.duration(rawProps.end);
    }
    if (rawProps.dow) {
        this.setDow(rawProps.dow);
    }
    return superSuccess;
};
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
RecurringEventDef.defineStandardProps({
    start: false,
    end: false,
    dow: false
});


/***/ }),
/* 211 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange = /** @class */ (function () {
    function EventRange(unzonedRange, eventDef, eventInstance) {
        this.unzonedRange = unzonedRange;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    return EventRange;
}());
exports.default = EventRange;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(35);
var EventInstanceGroup_1 = __webpack_require__(18);
var RecurringEventDef_1 = __webpack_require__(210);
var EventSource_1 = __webpack_require__(6);
var BUSINESS_HOUR_EVENT_DEFAULTS = {
    start: '09:00',
    end: '17:00',
    dow: [1, 2, 3, 4, 5],
    rendering: 'inverse-background'
    // classNames are defined in businessHoursSegClasses
};
var BusinessHourGenerator = /** @class */ (function () {
    function BusinessHourGenerator(rawComplexDef, calendar) {
        this.rawComplexDef = rawComplexDef;
        this.calendar = calendar;
    }
    BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {
        var eventDefs = this.buildEventDefs(isAllDay);
        var eventInstanceGroup;
        if (eventDefs.length) {
            eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));
            // so that inverse-background rendering can happen even when no eventRanges in view
            eventInstanceGroup.explicitEventDef = eventDefs[0];
            return eventInstanceGroup;
        }
    };
    BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {
        var rawComplexDef = this.rawComplexDef;
        var rawDefs = [];
        var requireDow = false;
        var i;
        var defs = [];
        if (rawComplexDef === true) {
            rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim
        }
        else if ($.isPlainObject(rawComplexDef)) {
            rawDefs = [rawComplexDef];
        }
        else if ($.isArray(rawComplexDef)) {
            rawDefs = rawComplexDef;
            requireDow = true; // every sub-definition NEEDS a day-of-week
        }
        for (i = 0; i < rawDefs.length; i++) {
            if (!requireDow || rawDefs[i].dow) {
                defs.push(this.buildEventDef(isAllDay, rawDefs[i]));
            }
        }
        return defs;
    };
    BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {
        var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);
        if (isAllDay) {
            fullRawDef.start = null;
            fullRawDef.end = null;
        }
        return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source
        );
    };
    return BusinessHourGenerator;
}());
exports.default = BusinessHourGenerator;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(19);
var StandardTheme = /** @class */ (function (_super) {
    tslib_1.__extends(StandardTheme, _super);
    function StandardTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardTheme;
}(Theme_1.default));
exports.default = StandardTheme;
StandardTheme.prototype.classes = {
    widget: 'fc-unthemed',
    widgetHeader: 'fc-widget-header',
    widgetContent: 'fc-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'fc-button',
    cornerLeft: 'fc-corner-left',
    cornerRight: 'fc-corner-right',
    stateDefault: 'fc-state-default',
    stateActive: 'fc-state-active',
    stateDisabled: 'fc-state-disabled',
    stateHover: 'fc-state-hover',
    stateDown: 'fc-state-down',
    popoverHeader: 'fc-widget-header',
    popoverContent: 'fc-widget-content',
    // day grid
    headerRow: 'fc-widget-header',
    dayRow: 'fc-widget-content',
    // list view
    listView: 'fc-widget-content'
};
StandardTheme.prototype.baseIconClass = 'fc-icon';
StandardTheme.prototype.iconClasses = {
    close: 'fc-icon-x',
    prev: 'fc-icon-left-single-arrow',
    next: 'fc-icon-right-single-arrow',
    prevYear: 'fc-icon-left-double-arrow',
    nextYear: 'fc-icon-right-double-arrow'
};
StandardTheme.prototype.iconOverrideOption = 'buttonIcons';
StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(19);
var JqueryUiTheme = /** @class */ (function (_super) {
    tslib_1.__extends(JqueryUiTheme, _super);
    function JqueryUiTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return JqueryUiTheme;
}(Theme_1.default));
exports.default = JqueryUiTheme;
JqueryUiTheme.prototype.classes = {
    widget: 'ui-widget',
    widgetHeader: 'ui-widget-header',
    widgetContent: 'ui-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'ui-button',
    cornerLeft: 'ui-corner-left',
    cornerRight: 'ui-corner-right',
    stateDefault: 'ui-state-default',
    stateActive: 'ui-state-active',
    stateDisabled: 'ui-state-disabled',
    stateHover: 'ui-state-hover',
    stateDown: 'ui-state-down',
    today: 'ui-state-highlight',
    popoverHeader: 'ui-widget-header',
    popoverContent: 'ui-widget-content',
    // day grid
    headerRow: 'ui-widget-header',
    dayRow: 'ui-widget-content',
    // list view
    listView: 'ui-widget-content'
};
JqueryUiTheme.prototype.baseIconClass = 'ui-icon';
JqueryUiTheme.prototype.iconClasses = {
    close: 'ui-icon-closethick',
    prev: 'ui-icon-circle-triangle-w',
    next: 'ui-icon-circle-triangle-e',
    prevYear: 'ui-icon-seek-prev',
    nextYear: 'ui-icon-seek-next'
};
JqueryUiTheme.prototype.iconOverrideOption = 'themeButtonIcons';
JqueryUiTheme.prototype.iconOverrideCustomButtonOption = 'themeIcon';
JqueryUiTheme.prototype.iconOverridePrefix = 'ui-icon-';


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var Promise_1 = __webpack_require__(20);
var EventSource_1 = __webpack_require__(6);
var FuncEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(FuncEventSource, _super);
    function FuncEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FuncEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isFunction(rawInput.events)) {
            rawProps = rawInput;
        }
        else if ($.isFunction(rawInput)) {
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    FuncEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve) {
            _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {
                _this.calendar.popLoading();
                onResolve(_this.parseEventDefs(rawEventDefs));
            });
        });
    };
    FuncEventSource.prototype.getPrimitive = function () {
        return this.func;
    };
    FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.func = rawProps.events;
        return superSuccess;
    };
    return FuncEventSource;
}(EventSource_1.default));
exports.default = FuncEventSource;
FuncEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Promise_1 = __webpack_require__(20);
var EventSource_1 = __webpack_require__(6);
var JsonFeedEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(JsonFeedEventSource, _super);
    function JsonFeedEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonFeedEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if (typeof rawInput.url === 'string') {
            rawProps = rawInput;
        }
        else if (typeof rawInput === 'string') {
            rawProps = { url: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        var ajaxSettings = this.ajaxSettings;
        var onSuccess = ajaxSettings.success;
        var onError = ajaxSettings.error;
        var requestParams = this.buildRequestParams(start, end, timezone);
        // todo: eventually handle the promise's then,
        // don't intercept success/error
        // tho will be a breaking API change
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve, onReject) {
            $.ajax($.extend({}, // destination
            JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {
                url: _this.url,
                data: requestParams,
                success: function (rawEventDefs, status, xhr) {
                    var callbackRes;
                    _this.calendar.popLoading();
                    if (rawEventDefs) {
                        callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`
                        if ($.isArray(callbackRes)) {
                            rawEventDefs = callbackRes;
                        }
                        onResolve(_this.parseEventDefs(rawEventDefs));
                    }
                    else {
                        onReject();
                    }
                },
                error: function (xhr, statusText, errorThrown) {
                    _this.calendar.popLoading();
                    util_1.applyAll(onError, _this, [xhr, statusText, errorThrown]); // redirect `this`
                    onReject();
                }
            }));
        });
    };
    JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {
        var calendar = this.calendar;
        var ajaxSettings = this.ajaxSettings;
        var startParam;
        var endParam;
        var timezoneParam;
        var customRequestParams;
        var params = {};
        startParam = this.startParam;
        if (startParam == null) {
            startParam = calendar.opt('startParam');
        }
        endParam = this.endParam;
        if (endParam == null) {
            endParam = calendar.opt('endParam');
        }
        timezoneParam = this.timezoneParam;
        if (timezoneParam == null) {
            timezoneParam = calendar.opt('timezoneParam');
        }
        // retrieve any outbound GET/POST $.ajax data from the options
        if ($.isFunction(ajaxSettings.data)) {
            // supplied as a function that returns a key/value object
            customRequestParams = ajaxSettings.data();
        }
        else {
            // probably supplied as a straight key/value object
            customRequestParams = ajaxSettings.data || {};
        }
        $.extend(params, customRequestParams);
        params[startParam] = start.format();
        params[endParam] = end.format();
        if (timezone && timezone !== 'local') {
            params[timezoneParam] = timezone;
        }
        return params;
    };
    JsonFeedEventSource.prototype.getPrimitive = function () {
        return this.url;
    };
    JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {
        this.ajaxSettings = rawProps;
    };
    JsonFeedEventSource.AJAX_DEFAULTS = {
        dataType: 'json',
        cache: false
    };
    return JsonFeedEventSource;
}(EventSource_1.default));
exports.default = JsonFeedEventSource;
JsonFeedEventSource.defineStandardProps({
    // automatically transfer (true)...
    url: true,
    startParam: true,
    endParam: true,
    timezoneParam: true
});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EmitterMixin_1 = __webpack_require__(11);
var TaskQueue = /** @class */ (function () {
    function TaskQueue() {
        this.q = [];
        this.isPaused = false;
        this.isRunning = false;
    }
    TaskQueue.prototype.queue = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.q.push.apply(this.q, args); // append
        this.tryStart();
    };
    TaskQueue.prototype.pause = function () {
        this.isPaused = true;
    };
    TaskQueue.prototype.resume = function () {
        this.isPaused = false;
        this.tryStart();
    };
    TaskQueue.prototype.getIsIdle = function () {
        return !this.isRunning && !this.isPaused;
    };
    TaskQueue.prototype.tryStart = function () {
        if (!this.isRunning && this.canRunNext()) {
            this.isRunning = true;
            this.trigger('start');
            this.runRemaining();
        }
    };
    TaskQueue.prototype.canRunNext = function () {
        return !this.isPaused && this.q.length;
    };
    TaskQueue.prototype.runRemaining = function () {
        var _this = this;
        var task;
        var res;
        do {
            task = this.q.shift(); // always freshly reference q. might have been reassigned.
            res = this.runTask(task);
            if (res && res.then) {
                res.then(function () {
                    if (_this.canRunNext()) {
                        _this.runRemaining();
                    }
                });
                return; // prevent marking as stopped
            }
        } while (this.canRunNext());
        this.trigger('stop'); // not really a 'stop' ... more of a 'drained'
        this.isRunning = false;
        // if 'stop' handler added more tasks.... TODO: write test for this
        this.tryStart();
    };
    TaskQueue.prototype.runTask = function (task) {
        return task(); // task *is* the function, but subclasses can change the format of a task
    };
    return TaskQueue;
}());
exports.default = TaskQueue;
EmitterMixin_1.default.mixInto(TaskQueue);


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var TaskQueue_1 = __webpack_require__(217);
var RenderQueue = /** @class */ (function (_super) {
    tslib_1.__extends(RenderQueue, _super);
    function RenderQueue(waitsByNamespace) {
        var _this = _super.call(this) || this;
        _this.waitsByNamespace = waitsByNamespace || {};
        return _this;
    }
    RenderQueue.prototype.queue = function (taskFunc, namespace, type) {
        var task = {
            func: taskFunc,
            namespace: namespace,
            type: type
        };
        var waitMs;
        if (namespace) {
            waitMs = this.waitsByNamespace[namespace];
        }
        if (this.waitNamespace) {
            if (namespace === this.waitNamespace && waitMs != null) {
                this.delayWait(waitMs);
            }
            else {
                this.clearWait();
                this.tryStart();
            }
        }
        if (this.compoundTask(task)) {
            if (!this.waitNamespace && waitMs != null) {
                this.startWait(namespace, waitMs);
            }
            else {
                this.tryStart();
            }
        }
    };
    RenderQueue.prototype.startWait = function (namespace, waitMs) {
        this.waitNamespace = namespace;
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.delayWait = function (waitMs) {
        clearTimeout(this.waitId);
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.spawnWait = function (waitMs) {
        var _this = this;
        this.waitId = setTimeout(function () {
            _this.waitNamespace = null;
            _this.tryStart();
        }, waitMs);
    };
    RenderQueue.prototype.clearWait = function () {
        if (this.waitNamespace) {
            clearTimeout(this.waitId);
            this.waitId = null;
            this.waitNamespace = null;
        }
    };
    RenderQueue.prototype.canRunNext = function () {
        if (!_super.prototype.canRunNext.call(this)) {
            return false;
        }
        // waiting for a certain namespace to stop receiving tasks?
        if (this.waitNamespace) {
            var q = this.q;
            // if there was a different namespace task in the meantime,
            // that forces all previously-waiting tasks to suddenly execute.
            // TODO: find a way to do this in constant time.
            for (var i = 0; i < q.length; i++) {
                if (q[i].namespace !== this.waitNamespace) {
                    return true; // allow execution
                }
            }
            return false;
        }
        return true;
    };
    RenderQueue.prototype.runTask = function (task) {
        task.func();
    };
    RenderQueue.prototype.compoundTask = function (newTask) {
        var q = this.q;
        var shouldAppend = true;
        var i;
        var task;
        if (newTask.namespace && newTask.type === 'destroy') {
            // remove all init/add/remove ops with same namespace, regardless of order
            for (i = q.length - 1; i >= 0; i--) {
                task = q[i];
                switch (task.type) {
                    case 'init':
                        shouldAppend = false;
                    // the latest destroy is cancelled out by not doing the init
                    /* falls through */
                    case 'add':
                    /* falls through */
                    case 'remove':
                        q.splice(i, 1); // remove task
                }
            }
        }
        if (shouldAppend) {
            q.push(newTask);
        }
        return shouldAppend;
    };
    return RenderQueue;
}(TaskQueue_1.default));
exports.default = RenderQueue;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var moment_ext_1 = __webpack_require__(10);
var date_formatting_1 = __webpack_require__(47);
var Component_1 = __webpack_require__(237);
var util_2 = __webpack_require__(35);
var DateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(DateComponent, _super);
    function DateComponent(_view, _options) {
        var _this = _super.call(this) || this;
        _this.isRTL = false; // frequently accessed options
        _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits
        _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?
        _this.isDatesRendered = false;
        // hack to set options prior to the this.opt calls
        if (_view) {
            _this['view'] = _view;
        }
        if (_options) {
            _this['options'] = _options;
        }
        _this.uid = String(DateComponent.guid++);
        _this.childrenByUid = {};
        _this.nextDayThreshold = moment.duration(_this.opt('nextDayThreshold'));
        _this.isRTL = _this.opt('isRTL');
        if (_this.fillRendererClass) {
            _this.fillRenderer = new _this.fillRendererClass(_this);
        }
        if (_this.eventRendererClass) {
            _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);
        }
        if (_this.helperRendererClass && _this.eventRenderer) {
            _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);
        }
        if (_this.businessHourRendererClass && _this.fillRenderer) {
            _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);
        }
        return _this;
    }
    DateComponent.prototype.addChild = function (child) {
        if (!this.childrenByUid[child.uid]) {
            this.childrenByUid[child.uid] = child;
            return true;
        }
        return false;
    };
    DateComponent.prototype.removeChild = function (child) {
        if (this.childrenByUid[child.uid]) {
            delete this.childrenByUid[child.uid];
            return true;
        }
        return false;
    };
    // TODO: only do if isInDom?
    // TODO: make part of Component, along with children/batch-render system?
    DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        this.callChildren('updateSize', arguments);
    };
    // Options
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.opt = function (name) {
        return this._getView().opt(name); // default implementation
    };
    DateComponent.prototype.publiclyTrigger = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.publiclyTrigger.apply(calendar, args);
    };
    DateComponent.prototype.hasPublicHandlers = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.hasPublicHandlers.apply(calendar, args);
    };
    // Date
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeDateRender = function (dateProfile) {
        this.dateProfile = dateProfile; // for rendering
        this.renderDates(dateProfile);
        this.isDatesRendered = true;
        this.callChildren('executeDateRender', arguments);
    };
    DateComponent.prototype.executeDateUnrender = function () {
        this.callChildren('executeDateUnrender', arguments);
        this.dateProfile = null;
        this.unrenderDates();
        this.isDatesRendered = false;
    };
    // date-cell content only
    DateComponent.prototype.renderDates = function (dateProfile) {
        // subclasses should implement
    };
    // date-cell content only
    DateComponent.prototype.unrenderDates = function () {
        // subclasses should override
    };
    // Now-Indicator
    // -----------------------------------------------------------------------------------------------------------------
    // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
    // should be refreshed. If something falsy is returned, no time indicator is rendered at all.
    DateComponent.prototype.getNowIndicatorUnit = function () {
        // subclasses should implement
    };
    // Renders a current time indicator at the given datetime
    DateComponent.prototype.renderNowIndicator = function (date) {
        this.callChildren('renderNowIndicator', arguments);
    };
    // Undoes the rendering actions from renderNowIndicator
    DateComponent.prototype.unrenderNowIndicator = function () {
        this.callChildren('unrenderNowIndicator', arguments);
    };
    // Business Hours
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {
        if (this.businessHourRenderer) {
            this.businessHourRenderer.render(businessHourGenerator);
        }
        this.callChildren('renderBusinessHours', arguments);
    };
    // Unrenders previously-rendered business-hours
    DateComponent.prototype.unrenderBusinessHours = function () {
        this.callChildren('unrenderBusinessHours', arguments);
        if (this.businessHourRenderer) {
            this.businessHourRenderer.unrender();
        }
    };
    // Event Displaying
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeEventRender = function (eventsPayload) {
        if (this.eventRenderer) {
            this.eventRenderer.rangeUpdated(); // poorly named now
            this.eventRenderer.render(eventsPayload);
        }
        else if (this['renderEvents']) {
            this['renderEvents'](convertEventsPayloadToLegacyArray(eventsPayload));
        }
        this.callChildren('executeEventRender', arguments);
    };
    DateComponent.prototype.executeEventUnrender = function () {
        this.callChildren('executeEventUnrender', arguments);
        if (this.eventRenderer) {
            this.eventRenderer.unrender();
        }
        else if (this['destroyEvents']) {
            this['destroyEvents']();
        }
    };
    DateComponent.prototype.getBusinessHourSegs = function () {
        var segs = this.getOwnBusinessHourSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getBusinessHourSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnBusinessHourSegs = function () {
        if (this.businessHourRenderer) {
            return this.businessHourRenderer.getSegs();
        }
        return [];
    };
    DateComponent.prototype.getEventSegs = function () {
        var segs = this.getOwnEventSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getEventSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnEventSegs = function () {
        if (this.eventRenderer) {
            return this.eventRenderer.getSegs();
        }
        return [];
    };
    // Event Rendering Triggering
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.triggerAfterEventsRendered = function () {
        this.triggerAfterEventSegsRendered(this.getEventSegs());
        this.publiclyTrigger('eventAfterAllRender', {
            context: this,
            args: [this]
        });
    };
    DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {
        var _this = this;
        // an optimization, because getEventLegacy is expensive
        if (this.hasPublicHandlers('eventAfterRender')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) {
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventAfterRender', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    DateComponent.prototype.triggerBeforeEventsDestroyed = function () {
        this.triggerBeforeEventSegsDestroyed(this.getEventSegs());
    };
    DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {
        var _this = this;
        if (this.hasPublicHandlers('eventDestroy')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) {
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventDestroy', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    // Event Rendering Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Hides all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.showEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', '');
            }
        });
        this.callChildren('showEventsWithId', arguments);
    };
    // Shows all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.hideEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', 'hidden');
            }
        });
        this.callChildren('hideEventsWithId', arguments);
    };
    // Drag-n-Drop Rendering (for both events and external elements)
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of a event or external-element drag over the given drop zone.
    // If an external-element, seg will be `null`.
    // Must return elements used for any mock events.
    DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var renderedHelper = false;
        this.iterChildren(function (child) {
            if (child.renderDrag(eventFootprints, seg, isTouch)) {
                renderedHelper = true;
            }
        });
        return renderedHelper;
    };
    // Unrenders a visual indication of an event or external-element being dragged.
    DateComponent.prototype.unrenderDrag = function () {
        this.callChildren('unrenderDrag', arguments);
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of an event being resized.
    DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.callChildren('renderEventResize', arguments);
    };
    // Unrenders a visual indication of an event being resized.
    DateComponent.prototype.unrenderEventResize = function () {
        this.callChildren('unrenderEventResize', arguments);
    };
    // Selection
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of the selection
    // TODO: rename to `renderSelection` after legacy is gone
    DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {
        this.renderHighlight(componentFootprint);
        this.callChildren('renderSelectionFootprint', arguments);
    };
    // Unrenders a visual indication of selection
    DateComponent.prototype.unrenderSelection = function () {
        this.unrenderHighlight();
        this.callChildren('unrenderSelection', arguments);
    };
    // Highlight
    // ---------------------------------------------------------------------------------------------------------------
    // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
    DateComponent.prototype.renderHighlight = function (componentFootprint) {
        if (this.fillRenderer) {
            this.fillRenderer.renderFootprint('highlight', componentFootprint, {
                getClasses: function () {
                    return ['fc-highlight'];
                }
            });
        }
        this.callChildren('renderHighlight', arguments);
    };
    // Unrenders the emphasis on a date range
    DateComponent.prototype.unrenderHighlight = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('highlight');
        }
        this.callChildren('unrenderHighlight', arguments);
    };
    // Hit Areas
    // ---------------------------------------------------------------------------------------------------------------
    // just because all DateComponents support this interface
    // doesn't mean they need to have their own internal coord system. they can defer to sub-components.
    DateComponent.prototype.hitsNeeded = function () {
        if (!(this.hitsNeededDepth++)) {
            this.prepareHits();
        }
        this.callChildren('hitsNeeded', arguments);
    };
    DateComponent.prototype.hitsNotNeeded = function () {
        if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
            this.releaseHits();
        }
        this.callChildren('hitsNotNeeded', arguments);
    };
    DateComponent.prototype.prepareHits = function () {
        // subclasses can implement
    };
    DateComponent.prototype.releaseHits = function () {
        // subclasses can implement
    };
    // Given coordinates from the topleft of the document, return data about the date-related area underneath.
    // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
    // Must have a `grid` property, a reference to this current grid. TODO: avoid this
    // The returned object will be processed by getHitFootprint and getHitEl.
    DateComponent.prototype.queryHit = function (leftOffset, topOffset) {
        var childrenByUid = this.childrenByUid;
        var uid;
        var hit;
        for (uid in childrenByUid) {
            hit = childrenByUid[uid].queryHit(leftOffset, topOffset);
            if (hit) {
                break;
            }
        }
        return hit;
    };
    DateComponent.prototype.getSafeHitFootprint = function (hit) {
        var footprint = this.getHitFootprint(hit);
        if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {
            return null;
        }
        return footprint;
    };
    DateComponent.prototype.getHitFootprint = function (hit) {
        // what about being abstract!?
    };
    // Given position-level information about a date-related area within the grid,
    // should return a jQuery element that best represents it. passed to dayClick callback.
    DateComponent.prototype.getHitEl = function (hit) {
        // what about being abstract!?
    };
    /* Converting eventRange -> eventFootprint
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var eventFootprints = [];
        var i;
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// append
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_2.eventRangeToEventFootprint(eventRange)];
    };
    /* Converting componentFootprint/eventFootprint -> segs
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {
        var segs = [];
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));
        }
        return segs;
    };
    // Given an event's span (unzoned start/end and other misc data), and the event itself,
    // slices into segments and attaches event-derived properties to them.
    // eventSpan - { start, end, isStart, isEnd, otherthings... }
    DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {
        var unzonedRange = eventFootprint.componentFootprint.unzonedRange;
        var segs;
        var i;
        var seg;
        segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (!unzonedRange.isStart) {
                seg.isStart = false;
            }
            if (!unzonedRange.isEnd) {
                seg.isEnd = false;
            }
            seg.footprint = eventFootprint;
            // TODO: rename to seg.eventFootprint
        }
        return segs;
    };
    DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {
        return [];
    };
    // Utils
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.callChildren = function (methodName, args) {
        this.iterChildren(function (child) {
            child[methodName].apply(child, args);
        });
    };
    DateComponent.prototype.iterChildren = function (func) {
        var childrenByUid = this.childrenByUid;
        var uid;
        for (uid in childrenByUid) {
            func(childrenByUid[uid]);
        }
    };
    DateComponent.prototype._getCalendar = function () {
        var t = this;
        return t.calendar || t.view.calendar;
    };
    DateComponent.prototype._getView = function () {
        return this.view;
    };
    DateComponent.prototype._getDateProfile = function () {
        return this._getView().get('dateProfile');
    };
    // Generates HTML for an anchor to another view into the calendar.
    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
    // `gotoOptions` can either be a moment input, or an object with the form:
    // { date, type, forceOff }
    // `type` is a view-type like "day" or "week". default value is "day".
    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
    DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {
        var date;
        var type;
        var forceOff;
        var finalOptions;
        if ($.isPlainObject(gotoOptions)) {
            date = gotoOptions.date;
            type = gotoOptions.type;
            forceOff = gotoOptions.forceOff;
        }
        else {
            date = gotoOptions; // a single moment input
        }
        date = moment_ext_1.default(date); // if a string, parse it
        finalOptions = {
            date: date.format('YYYY-MM-DD'),
            type: type || 'day'
        };
        if (typeof attrs === 'string') {
            innerHtml = attrs;
            attrs = null;
        }
        attrs = attrs ? ' ' + util_1.attrsToStr(attrs) : ''; // will have a leading space
        innerHtml = innerHtml || '';
        if (!forceOff && this.opt('navLinks')) {
            return '<a' + attrs +
                ' data-goto="' + util_1.htmlEscape(JSON.stringify(finalOptions)) + '">' +
                innerHtml +
                '</a>';
        }
        else {
            return '<span' + attrs + '>' +
                innerHtml +
                '</span>';
        }
    };
    DateComponent.prototype.getAllDayHtml = function () {
        return this.opt('allDayHtml') || util_1.htmlEscape(this.opt('allDayText'));
    };
    // Computes HTML classNames for a single-day element
    DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {
        var view = this._getView();
        var classes = [];
        var today;
        if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {
            classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
        }
        else {
            classes.push('fc-' + util_1.dayIDs[date.day()]);
            if (view.isDateInOtherMonth(date, this.dateProfile)) {
                classes.push('fc-other-month');
            }
            today = view.calendar.getNow();
            if (date.isSame(today, 'day')) {
                classes.push('fc-today');
                if (noThemeHighlight !== true) {
                    classes.push(view.calendar.theme.getClass('today'));
                }
            }
            else if (date < today) {
                classes.push('fc-past');
            }
            else {
                classes.push('fc-future');
            }
        }
        return classes;
    };
    // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
    // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
    // The timezones of the dates within `range` will be respected.
    DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {
        var end = range.end;
        if (isAllDay) {
            end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
        }
        return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);
    };
    // Compute the number of the give units in the "current" range.
    // Will return a floating-point number. Won't round.
    DateComponent.prototype.currentRangeAs = function (unit) {
        return this._getDateProfile().currentUnzonedRange.as(unit);
    };
    // Returns the date range of the full days the given range visually appears to occupy.
    // Returns a plain object with start/end, NOT an UnzonedRange!
    DateComponent.prototype.computeDayRange = function (unzonedRange) {
        var calendar = this._getCalendar();
        var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts
        var end = calendar.msToUtcMoment(unzonedRange.endMs);
        var endTimeMS = +end.time(); // # of milliseconds into `endDay`
        var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
        // If the end time is actually inclusively part of the next day and is equal to or
        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
        if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
            endDay.add(1, 'days');
        }
        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
        if (endDay <= startDay) {
            endDay = startDay.clone().add(1, 'days');
        }
        return { start: startDay, end: endDay };
    };
    // Does the given range visually appear to occupy more than one day?
    DateComponent.prototype.isMultiDayRange = function (unzonedRange) {
        var dayRange = this.computeDayRange(unzonedRange);
        return dayRange.end.diff(dayRange.start, 'days') > 1;
    };
    DateComponent.guid = 0; // TODO: better system for this?
    return DateComponent;
}(Component_1.default));
exports.default = DateComponent;
// legacy
function convertEventsPayloadToLegacyArray(eventsPayload) {
    var eventDefId;
    var eventInstances;
    var legacyEvents = [];
    var i;
    for (eventDefId in eventsPayload) {
        eventInstances = eventsPayload[eventDefId].eventInstances;
        for (i = 0; i < eventInstances.length; i++) {
            legacyEvents.push(eventInstances[i].toLegacy());
        }
    }
    return legacyEvents;
}


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var options_1 = __webpack_require__(32);
var Iterator_1 = __webpack_require__(238);
var GlobalEmitter_1 = __webpack_require__(21);
var EmitterMixin_1 = __webpack_require__(11);
var ListenerMixin_1 = __webpack_require__(7);
var Toolbar_1 = __webpack_require__(239);
var OptionsManager_1 = __webpack_require__(240);
var ViewSpecManager_1 = __webpack_require__(241);
var Constraints_1 = __webpack_require__(207);
var locale_1 = __webpack_require__(31);
var moment_ext_1 = __webpack_require__(10);
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var EventDateProfile_1 = __webpack_require__(17);
var EventManager_1 = __webpack_require__(242);
var BusinessHourGenerator_1 = __webpack_require__(212);
var EventSourceParser_1 = __webpack_require__(38);
var EventDefParser_1 = __webpack_require__(49);
var SingleEventDef_1 = __webpack_require__(13);
var EventDefMutation_1 = __webpack_require__(37);
var EventSource_1 = __webpack_require__(6);
var ThemeRegistry_1 = __webpack_require__(51);
var Calendar = /** @class */ (function () {
    function Calendar(el, overrides) {
        this.loadingLevel = 0; // number of simultaneous loading tasks
        this.ignoreUpdateViewSize = 0;
        this.freezeContentHeightDepth = 0;
        // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
        // unneeded() is called in destroy.
        GlobalEmitter_1.default.needed();
        this.el = el;
        this.viewsByType = {};
        this.optionsManager = new OptionsManager_1.default(this, overrides);
        this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);
        this.initMomentInternals(); // needs to happen after options hash initialized
        this.initCurrentDate();
        this.initEventManager();
        this.constraints = new Constraints_1.default(this.eventManager, this);
        this.constructed();
    }
    Calendar.prototype.constructed = function () {
        // useful for monkeypatching. used?
    };
    Calendar.prototype.getView = function () {
        return this.view;
    };
    Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {
        var optHandler = this.opt(name);
        var context;
        var args;
        if ($.isPlainObject(triggerInfo)) {
            context = triggerInfo.context;
            args = triggerInfo.args;
        }
        else if ($.isArray(triggerInfo)) {
            args = triggerInfo;
        }
        if (context == null) {
            context = this.el[0]; // fallback context
        }
        if (!args) {
            args = [];
        }
        this.triggerWith(name, context, args); // Emitter's method
        if (optHandler) {
            return optHandler.apply(context, args);
        }
    };
    Calendar.prototype.hasPublicHandlers = function (name) {
        return this.hasHandlers(name) ||
            this.opt(name); // handler specified in options
    };
    // Options Public API
    // -----------------------------------------------------------------------------------------------------------------
    // public getter/setter
    Calendar.prototype.option = function (name, value) {
        var newOptionHash;
        if (typeof name === 'string') {
            if (value === undefined) {
                return this.optionsManager.get(name);
            }
            else {
                newOptionHash = {};
                newOptionHash[name] = value;
                this.optionsManager.add(newOptionHash);
            }
        }
        else if (typeof name === 'object') {
            this.optionsManager.add(name);
        }
    };
    // private getter
    Calendar.prototype.opt = function (name) {
        return this.optionsManager.get(name);
    };
    // View
    // -----------------------------------------------------------------------------------------------------------------
    // Given a view name for a custom view or a standard view, creates a ready-to-go View object
    Calendar.prototype.instantiateView = function (viewType) {
        var spec = this.viewSpecManager.getViewSpec(viewType);
        if (!spec) {
            throw new Error("View type \"" + viewType + "\" is not valid");
        }
        return new spec['class'](this, spec);
    };
    // Returns a boolean about whether the view is okay to instantiate at some point
    Calendar.prototype.isValidViewType = function (viewType) {
        return Boolean(this.viewSpecManager.getViewSpec(viewType));
    };
    Calendar.prototype.changeView = function (viewName, dateOrRange) {
        if (dateOrRange) {
            if (dateOrRange.start && dateOrRange.end) {
                this.optionsManager.recordOverrides({
                    visibleRange: dateOrRange
                });
            }
            else {
                this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
            }
        }
        this.renderView(viewName);
    };
    // Forces navigation to a view for the given date.
    // `viewType` can be a specific view name or a generic one like "week" or "day".
    Calendar.prototype.zoomTo = function (newDate, viewType) {
        var spec;
        viewType = viewType || 'day'; // day is default zoom
        spec = this.viewSpecManager.getViewSpec(viewType) ||
            this.viewSpecManager.getUnitViewSpec(viewType);
        this.currentDate = newDate.clone();
        this.renderView(spec ? spec.type : null);
    };
    // Current Date
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initCurrentDate = function () {
        var defaultDateInput = this.opt('defaultDate');
        // compute the initial ambig-timezone date
        if (defaultDateInput != null) {
            this.currentDate = this.moment(defaultDateInput).stripZone();
        }
        else {
            this.currentDate = this.getNow(); // getNow already returns unzoned
        }
    };
    Calendar.prototype.prev = function () {
        var view = this.view;
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        if (prevInfo.isValid) {
            this.currentDate = prevInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.next = function () {
        var view = this.view;
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        if (nextInfo.isValid) {
            this.currentDate = nextInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.prevYear = function () {
        this.currentDate.add(-1, 'years');
        this.renderView();
    };
    Calendar.prototype.nextYear = function () {
        this.currentDate.add(1, 'years');
        this.renderView();
    };
    Calendar.prototype.today = function () {
        this.currentDate = this.getNow(); // should deny like prev/next?
        this.renderView();
    };
    Calendar.prototype.gotoDate = function (zonedDateInput) {
        this.currentDate = this.moment(zonedDateInput).stripZone();
        this.renderView();
    };
    Calendar.prototype.incrementDate = function (delta) {
        this.currentDate.add(moment.duration(delta));
        this.renderView();
    };
    // for external API
    Calendar.prototype.getDate = function () {
        return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
    };
    // Loading Triggering
    // -----------------------------------------------------------------------------------------------------------------
    // Should be called when any type of async data fetching begins
    Calendar.prototype.pushLoading = function () {
        if (!(this.loadingLevel++)) {
            this.publiclyTrigger('loading', [true, this.view]);
        }
    };
    // Should be called when any type of async data fetching completes
    Calendar.prototype.popLoading = function () {
        if (!(--this.loadingLevel)) {
            this.publiclyTrigger('loading', [false, this.view]);
        }
    };
    // High-level Rendering
    // -----------------------------------------------------------------------------------
    Calendar.prototype.render = function () {
        if (!this.contentEl) {
            this.initialRender();
        }
        else if (this.elementVisible()) {
            // mainly for the public API
            this.calcSize();
            this.updateViewSize();
        }
    };
    Calendar.prototype.initialRender = function () {
        var _this = this;
        var el = this.el;
        el.addClass('fc');
        // event delegation for nav links
        el.on('click.fc', 'a[data-goto]', function (ev) {
            var anchorEl = $(ev.currentTarget);
            var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
            var date = _this.moment(gotoOptions.date);
            var viewType = gotoOptions.type;
            // property like "navLinkDayClick". might be a string or a function
            var customAction = _this.view.opt('navLink' + util_1.capitaliseFirstLetter(viewType) + 'Click');
            if (typeof customAction === 'function') {
                customAction(date, ev);
            }
            else {
                if (typeof customAction === 'string') {
                    viewType = customAction;
                }
                _this.zoomTo(date, viewType);
            }
        });
        // called immediately, and upon option change
        this.optionsManager.watch('settingTheme', ['?theme', '?themeSystem'], function (opts) {
            var themeClass = ThemeRegistry_1.getThemeSystemClass(opts.themeSystem || opts.theme);
            var theme = new themeClass(_this.optionsManager);
            var widgetClass = theme.getClass('widget');
            _this.theme = theme;
            if (widgetClass) {
                el.addClass(widgetClass);
            }
        }, function () {
            var widgetClass = _this.theme.getClass('widget');
            _this.theme = null;
            if (widgetClass) {
                el.removeClass(widgetClass);
            }
        });
        this.optionsManager.watch('settingBusinessHourGenerator', ['?businessHours'], function (deps) {
            _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);
            if (_this.view) {
                _this.view.set('businessHourGenerator', _this.businessHourGenerator);
            }
        }, function () {
            _this.businessHourGenerator = null;
        });
        // called immediately, and upon option change.
        // HACK: locale often affects isRTL, so we explicitly listen to that too.
        this.optionsManager.watch('applyingDirClasses', ['?isRTL', '?locale'], function (opts) {
            el.toggleClass('fc-ltr', !opts.isRTL);
            el.toggleClass('fc-rtl', opts.isRTL);
        });
        this.contentEl = $("<div class='fc-view-container'/>").prependTo(el);
        this.initToolbars();
        this.renderHeader();
        this.renderFooter();
        this.renderView(this.opt('defaultView'));
        if (this.opt('handleWindowResize')) {
            $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls
            this.windowResize.bind(this), this.opt('windowResizeDelay')));
        }
    };
    Calendar.prototype.destroy = function () {
        if (this.view) {
            this.clearView();
        }
        this.toolbarsManager.proxyCall('removeElement');
        this.contentEl.remove();
        this.el.removeClass('fc fc-ltr fc-rtl');
        // removes theme-related root className
        this.optionsManager.unwatch('settingTheme');
        this.optionsManager.unwatch('settingBusinessHourGenerator');
        this.el.off('.fc'); // unbind nav link handlers
        if (this.windowResizeProxy) {
            $(window).unbind('resize', this.windowResizeProxy);
            this.windowResizeProxy = null;
        }
        GlobalEmitter_1.default.unneeded();
    };
    Calendar.prototype.elementVisible = function () {
        return this.el.is(':visible');
    };
    // Render Queue
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.bindViewHandlers = function (view) {
        var _this = this;
        view.watch('titleForCalendar', ['title'], function (deps) {
            if (view === _this.view) {
                _this.setToolbarsTitle(deps.title);
            }
        });
        view.watch('dateProfileForCalendar', ['dateProfile'], function (deps) {
            if (view === _this.view) {
                _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates
                _this.updateToolbarButtons(deps.dateProfile);
            }
        });
    };
    Calendar.prototype.unbindViewHandlers = function (view) {
        view.unwatch('titleForCalendar');
        view.unwatch('dateProfileForCalendar');
    };
    // View Rendering
    // -----------------------------------------------------------------------------------
    // Renders a view because of a date change, view-type change, or for the first time.
    // If not given a viewType, keep the current view but render different dates.
    // Accepts an optional scroll state to restore to.
    Calendar.prototype.renderView = function (viewType) {
        var oldView = this.view;
        var newView;
        this.freezeContentHeight();
        if (oldView && viewType && oldView.type !== viewType) {
            this.clearView();
        }
        // if viewType changed, or the view was never created, create a fresh view
        if (!this.view && viewType) {
            newView = this.view =
                this.viewsByType[viewType] ||
                    (this.viewsByType[viewType] = this.instantiateView(viewType));
            this.bindViewHandlers(newView);
            newView.startBatchRender(); // so that setElement+setDate rendering are joined
            newView.setElement($("<div class='fc-view fc-" + viewType + "-view' />").appendTo(this.contentEl));
            this.toolbarsManager.proxyCall('activateButton', viewType);
        }
        if (this.view) {
            // prevent unnecessary change firing
            if (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {
                this.view.set('businessHourGenerator', this.businessHourGenerator);
            }
            this.view.setDate(this.currentDate);
            if (newView) {
                newView.stopBatchRender();
            }
        }
        this.thawContentHeight();
    };
    // Unrenders the current view and reflects this change in the Header.
    // Unregsiters the `view`, but does not remove from viewByType hash.
    Calendar.prototype.clearView = function () {
        var currentView = this.view;
        this.toolbarsManager.proxyCall('deactivateButton', currentView.type);
        this.unbindViewHandlers(currentView);
        currentView.removeElement();
        currentView.unsetDate(); // so bindViewHandlers doesn't fire with old values next time
        this.view = null;
    };
    // Destroys the view, including the view object. Then, re-instantiates it and renders it.
    // Maintains the same scroll state.
    // TODO: maintain any other user-manipulated state.
    Calendar.prototype.reinitView = function () {
        var oldView = this.view;
        var scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll
        this.freezeContentHeight();
        this.clearView();
        this.calcSize();
        this.renderView(oldView.type); // needs the type to freshly render
        this.view.applyScroll(scroll);
        this.thawContentHeight();
    };
    // Resizing
    // -----------------------------------------------------------------------------------
    Calendar.prototype.getSuggestedViewHeight = function () {
        if (this.suggestedViewHeight == null) {
            this.calcSize();
        }
        return this.suggestedViewHeight;
    };
    Calendar.prototype.isHeightAuto = function () {
        return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';
    };
    Calendar.prototype.updateViewSize = function (isResize) {
        if (isResize === void 0) { isResize = false; }
        var view = this.view;
        var scroll;
        if (!this.ignoreUpdateViewSize && view) {
            if (isResize) {
                this.calcSize();
                scroll = view.queryScroll();
            }
            this.ignoreUpdateViewSize++;
            view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);
            this.ignoreUpdateViewSize--;
            if (isResize) {
                view.applyScroll(scroll);
            }
            return true; // signal success
        }
    };
    Calendar.prototype.calcSize = function () {
        if (this.elementVisible()) {
            this._calcSize();
        }
    };
    Calendar.prototype._calcSize = function () {
        var contentHeightInput = this.opt('contentHeight');
        var heightInput = this.opt('height');
        if (typeof contentHeightInput === 'number') {
            this.suggestedViewHeight = contentHeightInput;
        }
        else if (typeof contentHeightInput === 'function') {
            this.suggestedViewHeight = contentHeightInput();
        }
        else if (typeof heightInput === 'number') {
            this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
        }
        else if (typeof heightInput === 'function') {
            this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
        }
        else if (heightInput === 'parent') {
            this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
        }
        else {
            this.suggestedViewHeight = Math.round(this.contentEl.width() /
                Math.max(this.opt('aspectRatio'), .5));
        }
    };
    Calendar.prototype.windowResize = function (ev) {
        if (
        // the purpose: so we don't process jqui "resize" events that have bubbled up
        // cast to any because .target, which is Element, can't be compared to window for some reason.
        ev.target === window &&
            this.view &&
            this.view.isDatesRendered) {
            if (this.updateViewSize(true)) {
                this.publiclyTrigger('windowResize', [this.view]);
            }
        }
    };
    /* Height "Freezing"
    -----------------------------------------------------------------------------*/
    Calendar.prototype.freezeContentHeight = function () {
        if (!(this.freezeContentHeightDepth++)) {
            this.forceFreezeContentHeight();
        }
    };
    Calendar.prototype.forceFreezeContentHeight = function () {
        this.contentEl.css({
            width: '100%',
            height: this.contentEl.height(),
            overflow: 'hidden'
        });
    };
    Calendar.prototype.thawContentHeight = function () {
        this.freezeContentHeightDepth--;
        // always bring back to natural height
        this.contentEl.css({
            width: '',
            height: '',
            overflow: ''
        });
        // but if there are future thaws, re-freeze
        if (this.freezeContentHeightDepth) {
            this.forceFreezeContentHeight();
        }
    };
    // Toolbar
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initToolbars = function () {
        this.header = new Toolbar_1.default(this, this.computeHeaderOptions());
        this.footer = new Toolbar_1.default(this, this.computeFooterOptions());
        this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);
    };
    Calendar.prototype.computeHeaderOptions = function () {
        return {
            extraClasses: 'fc-header-toolbar',
            layout: this.opt('header')
        };
    };
    Calendar.prototype.computeFooterOptions = function () {
        return {
            extraClasses: 'fc-footer-toolbar',
            layout: this.opt('footer')
        };
    };
    // can be called repeatedly and Header will rerender
    Calendar.prototype.renderHeader = function () {
        var header = this.header;
        header.setToolbarOptions(this.computeHeaderOptions());
        header.render();
        if (header.el) {
            this.el.prepend(header.el);
        }
    };
    // can be called repeatedly and Footer will rerender
    Calendar.prototype.renderFooter = function () {
        var footer = this.footer;
        footer.setToolbarOptions(this.computeFooterOptions());
        footer.render();
        if (footer.el) {
            this.el.append(footer.el);
        }
    };
    Calendar.prototype.setToolbarsTitle = function (title) {
        this.toolbarsManager.proxyCall('updateTitle', title);
    };
    Calendar.prototype.updateToolbarButtons = function (dateProfile) {
        var now = this.getNow();
        var view = this.view;
        var todayInfo = view.dateProfileGenerator.build(now);
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        this.toolbarsManager.proxyCall((todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?
            'enableButton' :
            'disableButton', 'today');
        this.toolbarsManager.proxyCall(prevInfo.isValid ?
            'enableButton' :
            'disableButton', 'prev');
        this.toolbarsManager.proxyCall(nextInfo.isValid ?
            'enableButton' :
            'disableButton', 'next');
    };
    Calendar.prototype.queryToolbarsHeight = function () {
        return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {
            var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
            return accumulator + toolbarHeight;
        }, 0);
    };
    // Selection
    // -----------------------------------------------------------------------------------------------------------------
    // this public method receives start/end dates in any format, with any timezone
    Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {
        this.view.select(this.buildSelectFootprint.apply(this, arguments));
    };
    Calendar.prototype.unselect = function () {
        if (this.view) {
            this.view.unselect();
        }
    };
    // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
    Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {
        var start = this.moment(zonedStartInput).stripZone();
        var end;
        if (zonedEndInput) {
            end = this.moment(zonedEndInput).stripZone();
        }
        else if (start.hasTime()) {
            end = start.clone().add(this.defaultTimedEventDuration);
        }
        else {
            end = start.clone().add(this.defaultAllDayEventDuration);
        }
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());
    };
    // Date Utils
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initMomentInternals = function () {
        var _this = this;
        this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));
        this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));
        // Called immediately, and when any of the options change.
        // Happens before any internal objects rebuild or rerender, because this is very core.
        this.optionsManager.watch('buildingMomentLocale', [
            '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',
            '?firstDay', '?weekNumberCalculation'
        ], function (opts) {
            var weekNumberCalculation = opts.weekNumberCalculation;
            var firstDay = opts.firstDay;
            var _week;
            // normalize
            if (weekNumberCalculation === 'iso') {
                weekNumberCalculation = 'ISO'; // normalize
            }
            var localeData = Object.create(// make a cheap copy
            locale_1.getMomentLocaleData(opts.locale) // will fall back to en
            );
            if (opts.monthNames) {
                localeData._months = opts.monthNames;
            }
            if (opts.monthNamesShort) {
                localeData._monthsShort = opts.monthNamesShort;
            }
            if (opts.dayNames) {
                localeData._weekdays = opts.dayNames;
            }
            if (opts.dayNamesShort) {
                localeData._weekdaysShort = opts.dayNamesShort;
            }
            if (firstDay == null && weekNumberCalculation === 'ISO') {
                firstDay = 1;
            }
            if (firstDay != null) {
                _week = Object.create(localeData._week); // _week: { dow: # }
                _week.dow = firstDay;
                localeData._week = _week;
            }
            if (weekNumberCalculation === 'ISO' ||
                weekNumberCalculation === 'local' ||
                typeof weekNumberCalculation === 'function') {
                localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
            }
            _this.localeData = localeData;
            // If the internal current date object already exists, move to new locale.
            // We do NOT need to do this technique for event dates, because this happens when converting to "segments".
            if (_this.currentDate) {
                _this.localizeMoment(_this.currentDate); // sets to localeData
            }
        });
    };
    // Builds a moment using the settings of the current calendar: timezone and locale.
    // Accepts anything the vanilla moment() constructor accepts.
    Calendar.prototype.moment = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var mom;
        if (this.opt('timezone') === 'local') {
            mom = moment_ext_1.default.apply(null, args);
            // Force the moment to be local, because momentExt doesn't guarantee it.
            if (mom.hasTime()) {
                mom.local();
            }
        }
        else if (this.opt('timezone') === 'UTC') {
            mom = moment_ext_1.default.utc.apply(null, args); // process as UTC
        }
        else {
            mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone
        }
        this.localizeMoment(mom); // TODO
        return mom;
    };
    Calendar.prototype.msToMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        else {
            mom = this.applyTimezone(mom); // may or may not apply locale
        }
        this.localizeMoment(mom);
        return mom;
    };
    Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        this.localizeMoment(mom);
        return mom;
    };
    // Updates the given moment's locale settings to the current calendar locale settings.
    Calendar.prototype.localizeMoment = function (mom) {
        mom._locale = this.localeData;
    };
    // Returns a boolean about whether or not the calendar knows how to calculate
    // the timezone offset of arbitrary dates in the current timezone.
    Calendar.prototype.getIsAmbigTimezone = function () {
        return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';
    };
    // Returns a copy of the given date in the current timezone. Has no effect on dates without times.
    Calendar.prototype.applyTimezone = function (date) {
        if (!date.hasTime()) {
            return date.clone();
        }
        var zonedDate = this.moment(date.toArray());
        var timeAdjust = date.time().asMilliseconds() - zonedDate.time().asMilliseconds();
        var adjustedZonedDate;
        // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
        if (timeAdjust) {
            adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
            if (date.time().asMilliseconds() - adjustedZonedDate.time().asMilliseconds() === 0) {
                zonedDate = adjustedZonedDate;
            }
        }
        return zonedDate;
    };
    /*
    Assumes the footprint is non-open-ended.
    */
    Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {
        if (ignoreEnd === void 0) { ignoreEnd = false; }
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);
        var end;
        if (!ignoreEnd) {
            end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);
        }
        if (componentFootprint.isAllDay) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else {
            start = this.applyTimezone(start);
            if (end) {
                end = this.applyTimezone(end);
            }
        }
        return new EventDateProfile_1.default(start, end, this);
    };
    // Returns a moment for the current date, as defined by the client's computer or from the `now` option.
    // Will return an moment with an ambiguous timezone.
    Calendar.prototype.getNow = function () {
        var now = this.opt('now');
        if (typeof now === 'function') {
            now = now();
        }
        return this.moment(now).stripZone();
    };
    // Produces a human-readable string for the given duration.
    // Side-effect: changes the locale of the given duration.
    Calendar.prototype.humanizeDuration = function (duration) {
        return duration.locale(this.opt('locale')).humanize();
    };
    // will return `null` if invalid range
    Calendar.prototype.parseUnzonedRange = function (rangeInput) {
        var start = null;
        var end = null;
        if (rangeInput.start) {
            start = this.moment(rangeInput.start).stripZone();
        }
        if (rangeInput.end) {
            end = this.moment(rangeInput.end).stripZone();
        }
        if (!start && !end) {
            return null;
        }
        if (start && end && end.isBefore(start)) {
            return null;
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Event-Date Utilities
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initEventManager = function () {
        var _this = this;
        var eventManager = new EventManager_1.default(this);
        var rawSources = this.opt('eventSources') || [];
        var singleRawSource = this.opt('events');
        this.eventManager = eventManager;
        if (singleRawSource) {
            rawSources.unshift(singleRawSource);
        }
        eventManager.on('release', function (eventsPayload) {
            _this.trigger('eventsReset', eventsPayload);
        });
        eventManager.freeze();
        rawSources.forEach(function (rawSource) {
            var source = EventSourceParser_1.default.parse(rawSource, _this);
            if (source) {
                eventManager.addSource(source);
            }
        });
        eventManager.thaw();
    };
    Calendar.prototype.requestEvents = function (start, end) {
        return this.eventManager.requestEvents(start, end, this.opt('timezone'), !this.opt('lazyFetching'));
    };
    // Get an event's normalized end date. If not present, calculate it from the defaults.
    Calendar.prototype.getEventEnd = function (event) {
        if (event.end) {
            return event.end.clone();
        }
        else {
            return this.getDefaultEventEnd(event.allDay, event.start);
        }
    };
    // Given an event's allDay status and start date, return what its fallback end date should be.
    // TODO: rename to computeDefaultEventEnd
    Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {
        var end = zonedStart.clone();
        if (allDay) {
            end.stripTime().add(this.defaultAllDayEventDuration);
        }
        else {
            end.add(this.defaultTimedEventDuration);
        }
        if (this.getIsAmbigTimezone()) {
            end.stripZone(); // we don't know what the tzo should be
        }
        return end;
    };
    // Public Events API
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.rerenderEvents = function () {
        this.view.flash('displayingEvents');
    };
    Calendar.prototype.refetchEvents = function () {
        this.eventManager.refetchAllSources();
    };
    Calendar.prototype.renderEvents = function (eventInputs, isSticky) {
        this.eventManager.freeze();
        for (var i = 0; i < eventInputs.length; i++) {
            this.renderEvent(eventInputs[i], isSticky);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.renderEvent = function (eventInput, isSticky) {
        if (isSticky === void 0) { isSticky = false; }
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);
        if (eventDef) {
            eventManager.addEventDef(eventDef, isSticky);
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.removeEvents = function (legacyQuery) {
        var eventManager = this.eventManager;
        var legacyInstances = [];
        var idMap = {};
        var eventDef;
        var i;
        if (legacyQuery == null) {
            eventManager.removeAllEventDefs(); // persist=true
        }
        else {
            eventManager.getEventInstances().forEach(function (eventInstance) {
                legacyInstances.push(eventInstance.toLegacy());
            });
            legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);
            // compute unique IDs
            for (i = 0; i < legacyInstances.length; i++) {
                eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);
                idMap[eventDef.id] = true;
            }
            eventManager.freeze();
            for (i in idMap) {
                eventManager.removeEventDefsById(i); // persist=true
            }
            eventManager.thaw();
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.clientEvents = function (legacyQuery) {
        var legacyEventInstances = [];
        this.eventManager.getEventInstances().forEach(function (eventInstance) {
            legacyEventInstances.push(eventInstance.toLegacy());
        });
        return filterLegacyEventInstances(legacyEventInstances, legacyQuery);
    };
    Calendar.prototype.updateEvents = function (eventPropsArray) {
        this.eventManager.freeze();
        for (var i = 0; i < eventPropsArray.length; i++) {
            this.updateEvent(eventPropsArray[i]);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.updateEvent = function (eventProps) {
        var eventDef = this.eventManager.getEventDefByUid(eventProps._id);
        var eventInstance;
        var eventDefMutation;
        if (eventDef instanceof SingleEventDef_1.default) {
            eventInstance = eventDef.buildInstance();
            eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props
            null // largeUnit -- who uses it?
            );
            this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release
        }
    };
    // Public Event Sources API
    // ------------------------------------------------------------------------------------
    Calendar.prototype.getEventSources = function () {
        return this.eventManager.otherSources.slice(); // clone
    };
    Calendar.prototype.getEventSourceById = function (id) {
        return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));
    };
    Calendar.prototype.addEventSource = function (sourceInput) {
        var source = EventSourceParser_1.default.parse(sourceInput, this);
        if (source) {
            this.eventManager.addSource(source);
        }
    };
    Calendar.prototype.removeEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources;
        var i;
        if (sourceMultiQuery == null) {
            this.eventManager.removeAllSources();
        }
        else {
            sources = eventManager.multiQuerySources(sourceMultiQuery);
            eventManager.freeze();
            for (i = 0; i < sources.length; i++) {
                eventManager.removeSource(sources[i]);
            }
            eventManager.thaw();
        }
    };
    Calendar.prototype.removeEventSource = function (sourceQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.querySources(sourceQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.removeSource(sources[i]);
        }
        eventManager.thaw();
    };
    Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.multiQuerySources(sourceMultiQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.refetchSource(sources[i]);
        }
        eventManager.thaw();
    };
    // not for internal use. use options module directly instead.
    Calendar.defaults = options_1.globalDefaults;
    Calendar.englishDefaults = options_1.englishDefaults;
    Calendar.rtlDefaults = options_1.rtlDefaults;
    return Calendar;
}());
exports.default = Calendar;
EmitterMixin_1.default.mixInto(Calendar);
ListenerMixin_1.default.mixInto(Calendar);
function filterLegacyEventInstances(legacyEventInstances, legacyQuery) {
    if (legacyQuery == null) {
        return legacyEventInstances;
    }
    else if ($.isFunction(legacyQuery)) {
        return legacyEventInstances.filter(legacyQuery);
    }
    else {
        legacyQuery += ''; // normalize to string
        return legacyEventInstances.filter(function (legacyEventInstance) {
            // soft comparison because id not be normalized to string
            // tslint:disable-next-line
            return legacyEventInstance.id == legacyQuery ||
                legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match
        });
    }
}


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var UnzonedRange_1 = __webpack_require__(5);
var DateProfileGenerator = /** @class */ (function () {
    function DateProfileGenerator(_view) {
        this._view = _view;
    }
    DateProfileGenerator.prototype.opt = function (name) {
        return this._view.opt(name);
    };
    DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {
        return this._view.trimHiddenDays(unzonedRange);
    };
    DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {
        return this._view.calendar.msToUtcMoment(ms, forceAllDay);
    };
    /* Date Range Computation
    ------------------------------------------------------------------------------------------------------------------*/
    // Builds a structure with info about what the dates/ranges will be for the "prev" view.
    DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {
        var prevDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .subtract(currentDateProfile.dateIncrement);
        return this.build(prevDate, -1);
    };
    // Builds a structure with info about what the dates/ranges will be for the "next" view.
    DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {
        var nextDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .add(currentDateProfile.dateIncrement);
        return this.build(nextDate, 1);
    };
    // Builds a structure holding dates/ranges for rendering around the given date.
    // Optional direction param indicates whether the date is being incremented/decremented
    // from its previous value. decremented = -1, incremented = 1 (default).
    DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {
        if (forceToValid === void 0) { forceToValid = false; }
        var isDateAllDay = !date.hasTime();
        var validUnzonedRange;
        var minTime = null;
        var maxTime = null;
        var currentInfo;
        var isRangeAllDay;
        var renderUnzonedRange;
        var activeUnzonedRange;
        var isValid;
        validUnzonedRange = this.buildValidRange();
        validUnzonedRange = this.trimHiddenDays(validUnzonedRange);
        if (forceToValid) {
            date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        currentInfo = this.buildCurrentRangeInfo(date, direction);
        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
        renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);
        renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);
        activeUnzonedRange = renderUnzonedRange.clone();
        if (!this.opt('showNonCurrentDates')) {
            activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);
        }
        minTime = moment.duration(this.opt('minTime'));
        maxTime = moment.duration(this.opt('maxTime'));
        activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);
        activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null
        if (activeUnzonedRange) {
            date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        // it's invalid if the originally requested date is not contained,
        // or if the range is completely outside of the valid range.
        isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);
        return {
            // constraint for where prev/next operations can go and where events can be dragged/resized to.
            // an object with optional start and end properties.
            validUnzonedRange: validUnzonedRange,
            // range the view is formally responsible for.
            // for example, a month view might have 1st-31st, excluding padded dates
            currentUnzonedRange: currentInfo.unzonedRange,
            // name of largest unit being displayed, like "month" or "week"
            currentRangeUnit: currentInfo.unit,
            isRangeAllDay: isRangeAllDay,
            // dates that display events and accept drag-n-drop
            // will be `null` if no dates accept events
            activeUnzonedRange: activeUnzonedRange,
            // date range with a rendered skeleton
            // includes not-active days that need some sort of DOM
            renderUnzonedRange: renderUnzonedRange,
            // Duration object that denotes the first visible time of any given day
            minTime: minTime,
            // Duration object that denotes the exclusive visible end time of any given day
            maxTime: maxTime,
            isValid: isValid,
            date: date,
            // how far the current date will move for a prev/next operation
            dateIncrement: this.buildDateIncrement(currentInfo.duration)
            // pass a fallback (might be null) ^
        };
    };
    // Builds an object with optional start/end properties.
    // Indicates the minimum/maximum dates to display.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildValidRange = function () {
        return this._view.getUnzonedRangeOption('validRange', this._view.calendar.getNow()) ||
            new UnzonedRange_1.default(); // completely open-ended
    };
    // Builds a structure with info about the "current" range, the range that is
    // highlighted as being the current month for example.
    // See build() for a description of `direction`.
    // Guaranteed to have `range` and `unit` properties. `duration` is optional.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
        var viewSpec = this._view.viewSpec;
        var duration = null;
        var unit = null;
        var unzonedRange = null;
        var dayCount;
        if (viewSpec.duration) {
            duration = viewSpec.duration;
            unit = viewSpec.durationUnit;
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        else if ((dayCount = this.opt('dayCount'))) {
            unit = 'day';
            unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);
        }
        else if ((unzonedRange = this.buildCustomVisibleRange(date))) {
            unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());
        }
        else {
            duration = this.getFallbackDuration();
            unit = util_1.computeGreatestUnit(duration);
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        return { duration: duration, unit: unit, unzonedRange: unzonedRange };
    };
    DateProfileGenerator.prototype.getFallbackDuration = function () {
        return moment.duration({ days: 1 });
    };
    // Returns a new activeUnzonedRange to have time values (un-ambiguate)
    // minTime or maxTime causes the range to expand.
    DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {
        var start = unzonedRange.getStart();
        var end = unzonedRange.getEnd();
        if (this._view.usesMinMaxTime) {
            if (minTime < 0) {
                start.time(0).add(minTime);
            }
            if (maxTime > 24 * 60 * 60 * 1000) {
                end.time(maxTime - (24 * 60 * 60 * 1000));
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Builds the "current" range when it is specified as an explicit duration.
    // `unit` is the already-computed computeGreatestUnit value of duration.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
        var alignment = this.opt('dateAlignment');
        var dateIncrementInput;
        var dateIncrementDuration;
        var start;
        var end;
        var res;
        // compute what the alignment should be
        if (!alignment) {
            dateIncrementInput = this.opt('dateIncrement');
            if (dateIncrementInput) {
                dateIncrementDuration = moment.duration(dateIncrementInput);
                // use the smaller of the two units
                if (dateIncrementDuration < duration) {
                    alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
                }
                else {
                    alignment = unit;
                }
            }
            else {
                alignment = unit;
            }
        }
        // if the view displays a single day or smaller
        if (duration.as('days') <= 1) {
            if (this._view.isHiddenDay(start)) {
                start = this._view.skipHiddenDays(start, direction);
                start.startOf('day');
            }
        }
        function computeRes() {
            start = date.clone().startOf(alignment);
            end = start.clone().add(duration);
            res = new UnzonedRange_1.default(start, end);
        }
        computeRes();
        // if range is completely enveloped by hidden days, go past the hidden days
        if (!this.trimHiddenDays(res)) {
            date = this._view.skipHiddenDays(date, direction);
            computeRes();
        }
        return res;
    };
    // Builds the "current" range when a dayCount is specified.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
        var customAlignment = this.opt('dateAlignment');
        var runningCount = 0;
        var start = date.clone();
        var end;
        if (customAlignment) {
            start.startOf(customAlignment);
        }
        start.startOf('day');
        start = this._view.skipHiddenDays(start, direction);
        end = start.clone();
        do {
            end.add(1, 'day');
            if (!this._view.isHiddenDay(end)) {
                runningCount++;
            }
        } while (runningCount < dayCount);
        return new UnzonedRange_1.default(start, end);
    };
    // Builds a normalized range object for the "visible" range,
    // which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
        var visibleUnzonedRange = this._view.getUnzonedRangeOption('visibleRange', this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations
        );
        if (visibleUnzonedRange && (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {
            return null;
        }
        return visibleUnzonedRange;
    };
    // Computes the range that will represent the element/cells for *rendering*,
    // but which may have voided days/times.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        return currentUnzonedRange.clone();
    };
    // Compute the duration value that should be added/substracted to the current date
    // when a prev/next operation happens.
    DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
        var dateIncrementInput = this.opt('dateIncrement');
        var customAlignment;
        if (dateIncrementInput) {
            return moment.duration(dateIncrementInput);
        }
        else if ((customAlignment = this.opt('dateAlignment'))) {
            return moment.duration(1, customAlignment);
        }
        else if (fallback) {
            return fallback;
        }
        else {
            return moment.duration({ days: 1 });
        }
    };
    return DateProfileGenerator;
}());
exports.default = DateProfileGenerator;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var exportHooks = __webpack_require__(16);
var util_1 = __webpack_require__(4);
var moment_ext_1 = __webpack_require__(10);
var ListenerMixin_1 = __webpack_require__(7);
var HitDragListener_1 = __webpack_require__(23);
var SingleEventDef_1 = __webpack_require__(13);
var EventInstanceGroup_1 = __webpack_require__(18);
var EventSource_1 = __webpack_require__(6);
var Interaction_1 = __webpack_require__(15);
var ExternalDropping = /** @class */ (function (_super) {
    tslib_1.__extends(ExternalDropping, _super);
    function ExternalDropping() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isDragging = false; // jqui-dragging an external element? boolean
        return _this;
    }
    /*
    component impements:
      - eventRangesToEventFootprints
      - isEventInstanceGroupAllowed
      - isExternalInstanceGroupAllowed
      - renderDrag
      - unrenderDrag
    */
    ExternalDropping.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    ExternalDropping.prototype.bindToDocument = function () {
        this.listenTo($(document), {
            dragstart: this.handleDragStart,
            sortstart: this.handleDragStart // jqui
        });
    };
    ExternalDropping.prototype.unbindFromDocument = function () {
        this.stopListeningTo($(document));
    };
    // Called when a jQuery UI drag is initiated anywhere in the DOM
    ExternalDropping.prototype.handleDragStart = function (ev, ui) {
        var el;
        var accept;
        if (this.opt('droppable')) {
            el = $((ui ? ui.item : null) || ev.target);
            // Test that the dragged element passes the dropAccept selector or filter function.
            // FYI, the default is "*" (matches all)
            accept = this.opt('dropAccept');
            if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
                if (!this.isDragging) {
                    this.listenToExternalDrag(el, ev, ui);
                }
            }
        }
    };
    // Called when a jQuery UI drag starts and it needs to be monitored for dropping
    ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
        var singleEventDef; // a null value signals an unsuccessful drag
        // listener that tracks mouse movement over date-associated pixel regions
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            interactionStart: function () {
                _this.isDragging = true;
            },
            hitOver: function (hit) {
                var isAllowed = true;
                var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid
                var mutatedEventInstanceGroup;
                if (hitFootprint) {
                    singleEventDef = _this.computeExternalDrop(hitFootprint, meta);
                    if (singleEventDef) {
                        mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());
                        isAllowed = meta.eventProps ? // isEvent?
                            component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :
                            component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    singleEventDef = null;
                    util_1.disableCursor();
                }
                if (singleEventDef) {
                    component.renderDrag(// called without a seg parameter
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));
                }
            },
            hitOut: function () {
                singleEventDef = null; // signal unsuccessful
            },
            hitDone: function () {
                util_1.enableCursor();
                component.unrenderDrag();
            },
            interactionEnd: function (ev) {
                if (singleEventDef) {
                    view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent
                    Boolean(meta.stick), // isSticky
                    el, ev, ui);
                }
                _this.isDragging = false;
                _this.dragListener = null;
            }
        });
        dragListener.startDrag(ev); // start listening immediately
    };
    // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
    // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
    // Returning a null value signals an invalid drop hit.
    // DOES NOT consider overlap/constraint.
    // Assumes both footprints are non-open-ended.
    ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {
        var calendar = this.view.calendar;
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();
        var end;
        var eventDef;
        if (componentFootprint.isAllDay) {
            // if dropped on an all-day span, and element's metadata specified a time, set it
            if (meta.startTime) {
                start.time(meta.startTime);
            }
            else {
                start.stripTime();
            }
        }
        if (meta.duration) {
            end = start.clone().add(meta.duration);
        }
        start = calendar.applyTimezone(start);
        if (end) {
            end = calendar.applyTimezone(end);
        }
        eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {
            start: start,
            end: end
        }), new EventSource_1.default(calendar));
        return eventDef;
    };
    return ExternalDropping;
}(Interaction_1.default));
exports.default = ExternalDropping;
ListenerMixin_1.default.mixInto(ExternalDropping);
/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/
// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
exportHooks.dataAttrPrefix = '';
// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
    var prefix = exportHooks.dataAttrPrefix;
    var eventProps; // properties for creating the event, not related to date/time
    var startTime; // a Duration
    var duration;
    var stick;
    if (prefix) {
        prefix += '-';
    }
    eventProps = el.data(prefix + 'event') || null;
    if (eventProps) {
        if (typeof eventProps === 'object') {
            eventProps = $.extend({}, eventProps); // make a copy
        }
        else {
            eventProps = {};
        }
        // pluck special-cased date/time properties
        startTime = eventProps.start;
        if (startTime == null) {
            startTime = eventProps.time;
        } // accept 'time' as well
        duration = eventProps.duration;
        stick = eventProps.stick;
        delete eventProps.start;
        delete eventProps.time;
        delete eventProps.duration;
        delete eventProps.stick;
    }
    // fallback to standalone attribute values for each of the date/time properties
    if (startTime == null) {
        startTime = el.data(prefix + 'start');
    }
    if (startTime == null) {
        startTime = el.data(prefix + 'time');
    } // accept 'time' as well
    if (duration == null) {
        duration = el.data(prefix + 'duration');
    }
    if (stick == null) {
        stick = el.data(prefix + 'stick');
    }
    // massage into correct data types
    startTime = startTime != null ? moment.duration(startTime) : null;
    duration = duration != null ? moment.duration(duration) : null;
    stick = Boolean(stick);
    return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventDefMutation_1 = __webpack_require__(37);
var EventDefDateMutation_1 = __webpack_require__(50);
var HitDragListener_1 = __webpack_require__(23);
var Interaction_1 = __webpack_require__(15);
var EventResizing = /** @class */ (function (_super) {
    tslib_1.__extends(EventResizing, _super);
    /*
    component impements:
      - bindSegHandlerToEl
      - publiclyTrigger
      - diffDates
      - eventRangesToEventFootprints
      - isEventInstanceGroupAllowed
      - getSafeHitFootprint
    */
    function EventResizing(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isResizing = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventResizing.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventResizing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventResizing.prototype.handleMouseDown = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev, { distance: 5 });
        }
    };
    EventResizing.prototype.handleTouchStart = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev);
        }
    };
    // Creates a listener that tracks the user as they resize an event segment.
    // Generic enough to work with any type of Grid.
    EventResizing.prototype.buildDragListener = function (seg, isStart) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance;
        var isDragging;
        var resizeMutation; // zoned event date properties. falsy if invalid resize
        // Tracks mouse movement over the *grid's* coordinate map
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            interactionStart: function () {
                isDragging = false;
            },
            dragStart: function (ev) {
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segResizeStart(seg, ev);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origHitFootprint = component.getSafeHitFootprint(origHit);
                var hitFootprint = component.getSafeHitFootprint(hit);
                var mutatedEventInstanceGroup;
                if (origHitFootprint && hitFootprint) {
                    resizeMutation = isStart ?
                        _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :
                        _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);
                    if (resizeMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    resizeMutation = null;
                    util_1.disableCursor();
                }
                else if (resizeMutation.isEmpty()) {
                    // no change. (FYI, event dates might have zones)
                    resizeMutation = null;
                }
                if (resizeMutation) {
                    view.hideEventsWithId(seg.footprint.eventDef.id);
                    view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);
                }
            },
            hitOut: function () {
                resizeMutation = null;
            },
            hitDone: function () {
                view.unrenderEventResize(seg);
                view.showEventsWithId(seg.footprint.eventDef.id);
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                if (isDragging) {
                    _this.segResizeStop(seg, ev);
                }
                if (resizeMutation) {
                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                    view.reportEventResize(eventInstance, resizeMutation, el, ev);
                }
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment resizing starts
    EventResizing.prototype.segResizeStart = function (seg, ev) {
        this.isResizing = true;
        this.component.publiclyTrigger('eventResizeStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment resizing stops
    EventResizing.prototype.segResizeStop = function (seg, ev) {
        this.isResizing = false;
        this.component.publiclyTrigger('eventResizeStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Returns new date-information for an event segment being resized from its start
    EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getStart().add(startDelta) < origRange.getEnd()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setStartDelta(startDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    // Returns new date-information for an event segment being resized from its end
    EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getEnd().add(endDelta) > origRange.getStart()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setEndDelta(endDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    return EventResizing;
}(Interaction_1.default));
exports.default = EventResizing;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var EventDefMutation_1 = __webpack_require__(37);
var EventDefDateMutation_1 = __webpack_require__(50);
var DragListener_1 = __webpack_require__(54);
var HitDragListener_1 = __webpack_require__(23);
var MouseFollower_1 = __webpack_require__(244);
var Interaction_1 = __webpack_require__(15);
var EventDragging = /** @class */ (function (_super) {
    tslib_1.__extends(EventDragging, _super);
    /*
    component implements:
      - bindSegHandlerToEl
      - publiclyTrigger
      - diffDates
      - eventRangesToEventFootprints
      - isEventInstanceGroupAllowed
    */
    function EventDragging(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isDragging = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventDragging.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventDragging.prototype.getSelectionDelay = function () {
        var delay = this.opt('eventLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    EventDragging.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventDragging.prototype.handleMousedown = function (seg, ev) {
        if (!this.component.shouldIgnoreMouse() &&
            this.component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, { distance: 5 });
        }
    };
    EventDragging.prototype.handleTouchStart = function (seg, ev) {
        var component = this.component;
        var settings = {
            delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?
                0 : this.getSelectionDelay()
        };
        if (component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, settings);
        }
        else if (component.canStartSelection(seg, ev)) {
            this.buildSelectListener(seg).startInteraction(ev, settings);
        }
    };
    // seg isn't draggable, but let's use a generic DragListener
    // simply for the delay, so it can be selected.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildSelectListener = function (seg) {
        var _this = this;
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        if (this.dragListener) {
            return this.dragListener;
        }
        var dragListener = this.dragListener = new DragListener_1.default({
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
            },
            interactionEnd: function (ev) {
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Builds a listener that will track user-dragging on an event segment.
    // Generic enough to work with any type of Grid.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildDragListener = function (seg) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        var isDragging;
        var mouseFollower; // A clone of the original element that will move with the mouse
        var eventDefMutation;
        if (this.dragListener) {
            return this.dragListener;
        }
        // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
        // of the view.
        var dragListener = this.dragListener = new HitDragListener_1.default(view, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            subjectCenter: true,
            interactionStart: function (ev) {
                seg.component = component; // for renderDrag
                isDragging = false;
                mouseFollower = new MouseFollower_1.default(seg.el, {
                    additionalClass: 'fc-dragging',
                    parentEl: view.el,
                    opacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),
                    revertDuration: _this.opt('dragRevertDuration'),
                    zIndex: 2 // one above the .fc-view
                });
                mouseFollower.hide(); // don't show until we know this is a real drag
                mouseFollower.start(ev);
            },
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segDragStart(seg, ev);
                view.hideEventsWithId(seg.footprint.eventDef.id);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origFootprint;
                var footprint;
                var mutatedEventInstanceGroup;
                // starting hit could be forced (DayGrid.limit)
                if (seg.hit) {
                    origHit = seg.hit;
                }
                // hit might not belong to this grid, so query origin grid
                origFootprint = origHit.component.getSafeHitFootprint(origHit);
                footprint = hit.component.getSafeHitFootprint(hit);
                if (origFootprint && footprint) {
                    eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);
                    if (eventDefMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    eventDefMutation = null;
                    util_1.disableCursor();
                }
                // if a valid drop location, have the subclass render a visual indication
                if (eventDefMutation &&
                    view.renderDrag(// truthy if rendered something
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {
                    mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
                }
                else {
                    mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
                }
                if (isOrig) {
                    // needs to have moved hits to be a valid drop
                    eventDefMutation = null;
                }
            },
            hitOut: function () {
                view.unrenderDrag(seg); // unrender whatever was done in renderDrag
                mouseFollower.show(); // show in case we are moving out of all hits
                eventDefMutation = null;
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                delete seg.component; // prevent side effects
                // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
                mouseFollower.stop(!eventDefMutation, function () {
                    if (isDragging) {
                        view.unrenderDrag(seg);
                        _this.segDragStop(seg, ev);
                    }
                    view.showEventsWithId(seg.footprint.eventDef.id);
                    if (eventDefMutation) {
                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                        view.reportEventDrop(eventInstance, eventDefMutation, el, ev);
                    }
                });
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment dragging starts
    EventDragging.prototype.segDragStart = function (seg, ev) {
        this.isDragging = true;
        this.component.publiclyTrigger('eventDragStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment dragging stops
    EventDragging.prototype.segDragStop = function (seg, ev) {
        this.isDragging = false;
        this.component.publiclyTrigger('eventDragStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // DOES NOT consider overlap/constraint
    EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {
        var eventDefMutation = new EventDefMutation_1.default();
        eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));
        return eventDefMutation;
    };
    EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {
        var date0 = startFootprint.unzonedRange.getStart();
        var date1 = endFootprint.unzonedRange.getStart();
        var clearEnd = false;
        var forceTimed = false;
        var forceAllDay = false;
        var dateDelta;
        var dateMutation;
        if (startFootprint.isAllDay !== endFootprint.isAllDay) {
            clearEnd = true;
            if (endFootprint.isAllDay) {
                forceAllDay = true;
                date0.stripTime();
            }
            else {
                forceTimed = true;
            }
        }
        dateDelta = this.component.diffDates(date1, date0);
        dateMutation = new EventDefDateMutation_1.default();
        dateMutation.clearEnd = clearEnd;
        dateMutation.forceTimed = forceTimed;
        dateMutation.forceAllDay = forceAllDay;
        dateMutation.setDateDelta(dateDelta);
        return dateMutation;
    };
    return EventDragging;
}(Interaction_1.default));
exports.default = EventDragging;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var HitDragListener_1 = __webpack_require__(23);
var ComponentFootprint_1 = __webpack_require__(12);
var UnzonedRange_1 = __webpack_require__(5);
var Interaction_1 = __webpack_require__(15);
var DateSelecting = /** @class */ (function (_super) {
    tslib_1.__extends(DateSelecting, _super);
    /*
    component must implement:
      - bindDateHandlerToEl
      - getSafeHitFootprint
      - renderHighlight
      - unrenderHighlight
    */
    function DateSelecting(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateSelecting.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateSelecting.prototype.getDelay = function () {
        var delay = this.opt('selectLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    DateSelecting.prototype.bindToEl = function (el) {
        var _this = this;
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev, {
                    distance: _this.opt('selectMinDistance')
                });
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev, {
                    delay: _this.getDelay()
                });
            }
        });
        util_1.preventSelection(el);
    };
    // Creates a listener that tracks the user's drag across day elements, for day selecting.
    DateSelecting.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var selectionFootprint; // null if invalid selection
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                selectionFootprint = null;
            },
            dragStart: function (ev) {
                _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one
            },
            hitOver: function (hit, isOrig, origHit) {
                var origHitFootprint;
                var hitFootprint;
                if (origHit) {
                    origHitFootprint = component.getSafeHitFootprint(origHit);
                    hitFootprint = component.getSafeHitFootprint(hit);
                    if (origHitFootprint && hitFootprint) {
                        selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);
                    }
                    else {
                        selectionFootprint = null;
                    }
                    if (selectionFootprint) {
                        component.renderSelectionFootprint(selectionFootprint);
                    }
                    else if (selectionFootprint === false) {
                        util_1.disableCursor();
                    }
                }
            },
            hitOut: function () {
                selectionFootprint = null;
                component.unrenderSelection();
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev, isCancelled) {
                if (!isCancelled && selectionFootprint) {
                    // the selection will already have been rendered. just report it
                    _this.view.reportSelection(selectionFootprint, ev);
                }
            }
        });
        return dragListener;
    };
    // Given the first and last date-spans of a selection, returns another date-span object.
    // Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().
    // Will return false if the selection is invalid and this should be indicated to the user.
    // Will return null/undefined if a selection invalid but no error should be reported.
    DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {
        var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);
        if (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {
            return false;
        }
        return wholeFootprint;
    };
    // Given two spans, must return the combination of the two.
    // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
    // Assumes both footprints are non-open-ended.
    DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {
        var ms = [
            footprint0.unzonedRange.startMs,
            footprint0.unzonedRange.endMs,
            footprint1.unzonedRange.startMs,
            footprint1.unzonedRange.endMs
        ];
        ms.sort(util_1.compareNumbers);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);
    };
    DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&
            this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);
    };
    return DateSelecting;
}(Interaction_1.default));
exports.default = DateSelecting;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Scroller_1 = __webpack_require__(39);
var View_1 = __webpack_require__(41);
var TimeGrid_1 = __webpack_require__(227);
var DayGrid_1 = __webpack_require__(61);
var AGENDA_ALL_DAY_EVENT_LIMIT = 5;
var agendaTimeGridMethods;
var agendaDayGridMethods;
/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.
var AgendaView = /** @class */ (function (_super) {
    tslib_1.__extends(AgendaView, _super);
    function AgendaView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering
        _this.timeGrid = _this.instantiateTimeGrid();
        _this.addChild(_this.timeGrid);
        if (_this.opt('allDaySlot')) {
            _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view
            _this.addChild(_this.dayGrid);
        }
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
    AgendaView.prototype.instantiateTimeGrid = function () {
        var timeGrid = new this.timeGridClass(this);
        util_1.copyOwnProps(agendaTimeGridMethods, timeGrid);
        return timeGrid;
    };
    // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
    AgendaView.prototype.instantiateDayGrid = function () {
        var dayGrid = new this.dayGridClass(this);
        util_1.copyOwnProps(agendaDayGridMethods, dayGrid);
        return dayGrid;
    };
    /* Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.renderSkeleton = function () {
        var timeGridWrapEl;
        var timeGridEl;
        this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
        timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
        this.el.find('.fc-body > tr > td').append(timeGridWrapEl);
        this.timeGrid.headContainerEl = this.el.find('.fc-head-container');
        this.timeGrid.setElement(timeGridEl);
        if (this.dayGrid) {
            this.dayGrid.setElement(this.el.find('.fc-day-grid'));
            // have the day-grid extend it's coordinate area over the <hr> dividing the two grids
            this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
        }
    };
    AgendaView.prototype.unrenderSkeleton = function () {
        this.timeGrid.removeElement();
        if (this.dayGrid) {
            this.dayGrid.removeElement();
        }
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid and time-grid components will render inside containers defined by this HTML.
    AgendaView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '">' +
            (this.dayGrid ?
                '<div class="fc-day-grid"/>' +
                    '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '"/>' :
                '') +
            '</td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the axis, if it is known
    AgendaView.prototype.axisStyleAttr = function () {
        if (this.axisWidth != null) {
            return 'style="width:' + this.axisWidth + 'px"';
        }
        return '';
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.getNowIndicatorUnit = function () {
        return this.timeGrid.getNowIndicatorUnit();
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Adjusts the vertical dimensions of the view to the specified values
    AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit;
        var scrollerHeight;
        var scrollbarWidths;
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        // make all axis cells line up, and record the width so newly created axis cells will have it
        this.axisWidth = util_1.matchCellWidths(this.el.find('.fc-axis'));
        // hack to give the view some height prior to timeGrid's columns being rendered
        // TODO: separate setting height from scroller VS timeGrid.
        if (!this.timeGrid.colEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        // set of fake row elements that must compensate when scroller has scrollbars
        var noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');
        // reset all dimensions back to the original state
        this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
        this.scroller.clear(); // sets height to 'auto' and clears overflow
        util_1.uncompensateScroll(noScrollRowEls);
        // limit number of events in the all-day area
        if (this.dayGrid) {
            this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
            eventLimit = this.opt('eventLimit');
            if (eventLimit && typeof eventLimit !== 'number') {
                eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
            }
            if (eventLimit) {
                this.dayGrid.limitRows(eventLimit);
            }
        }
        if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) {
                // make the all-day and header rows lines up
                util_1.compensateScroll(noScrollRowEls, scrollbarWidths);
                // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                // and reapply the desired height to the scroller.
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
            // if there's any space below the slats, show the horizontal rule.
            // this won't cause any new overflow, because lockOverflow already called.
            if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
                this.timeGrid.bottomRuleEl.show();
            }
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    AgendaView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes the initial pre-configured scroll state prior to allowing the user to change it
    AgendaView.prototype.computeInitialDateScroll = function () {
        var scrollTime = moment.duration(this.opt('scrollTime'));
        var top = this.timeGrid.computeTimeTop(scrollTime);
        // zoom can give weird floating-point values. rather scroll a little bit further
        top = Math.ceil(top);
        if (top) {
            top++; // to overcome top border that slots beyond the first have. looks better
        }
        return { top: top };
    };
    AgendaView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    AgendaView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    /* Hit Areas
    ------------------------------------------------------------------------------------------------------------------*/
    // forward all hit-related method calls to the grids (dayGrid might not be defined)
    AgendaView.prototype.getHitFootprint = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitFootprint(hit);
    };
    AgendaView.prototype.getHitEl = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitEl(hit);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.executeEventRender = function (eventsPayload) {
        var dayEventsPayload = {};
        var timedEventsPayload = {};
        var id;
        var eventInstanceGroup;
        // separate the events into all-day and timed
        for (id in eventsPayload) {
            eventInstanceGroup = eventsPayload[id];
            if (eventInstanceGroup.getEventDef().isAllDay()) {
                dayEventsPayload[id] = eventInstanceGroup;
            }
            else {
                timedEventsPayload[id] = eventInstanceGroup;
            }
        }
        this.timeGrid.executeEventRender(timedEventsPayload);
        if (this.dayGrid) {
            this.dayGrid.executeEventRender(dayEventsPayload);
        }
    };
    /* Dragging/Resizing Routing
    ------------------------------------------------------------------------------------------------------------------*/
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        var renderedHelper = false;
        renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;
        }
        return renderedHelper;
    };
    AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        this.timeGrid.renderEventResize(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);
        }
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection
    AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (!componentFootprint.isAllDay) {
            this.timeGrid.renderSelectionFootprint(componentFootprint);
        }
        else if (this.dayGrid) {
            this.dayGrid.renderSelectionFootprint(componentFootprint);
        }
    };
    return AgendaView;
}(View_1.default));
exports.default = AgendaView;
AgendaView.prototype.timeGridClass = TimeGrid_1.default;
AgendaView.prototype.dayGridClass = DayGrid_1.default;
// Will customize the rendering behavior of the AgendaView's timeGrid
agendaTimeGridMethods = {
    // Generates the HTML that will go before the day-of week header cells
    renderHeadIntroHtml: function () {
        var view = this.view;
        var calendar = view.calendar;
        var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);
        var weekText;
        if (this.opt('weekNumbers')) {
            weekText = weekStart.format(this.opt('smallWeekFormat'));
            return '' +
                '<th class="fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '>' +
                view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                { date: weekStart, type: 'week', forceOff: this.colCnt > 1 }, util_1.htmlEscape(weekText) // inner HTML
                ) +
                '</th>';
        }
        else {
            return '<th class="fc-axis ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '></th>';
        }
    },
    // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
    renderBgIntroHtml: function () {
        var view = this.view;
        return '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '></td>';
    },
    // Generates the HTML that goes before all other types of cells.
    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
    renderIntroHtml: function () {
        var view = this.view;
        return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
    }
};
// Will customize the rendering behavior of the AgendaView's dayGrid
agendaDayGridMethods = {
    // Generates the HTML that goes before the all-day cells
    renderBgIntroHtml: function () {
        var view = this.view;
        return '' +
            '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
            '<span>' + // needed for matchCellWidths
            view.getAllDayHtml() +
            '</span>' +
            '</td>';
    },
    // Generates the HTML that goes before all other types of cells.
    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
    renderIntroHtml: function () {
        var view = this.view;
        return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
    }
};
function groupEventFootprintsByAllDay(eventFootprints) {
    var allDay = [];
    var timed = [];
    var i;
    for (i = 0; i < eventFootprints.length; i++) {
        if (eventFootprints[i].componentFootprint.isAllDay) {
            allDay.push(eventFootprints[i]);
        }
        else {
            timed.push(eventFootprints[i]);
        }
    }
    return { allDay: allDay, timed: timed };
}


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var InteractiveDateComponent_1 = __webpack_require__(40);
var BusinessHourRenderer_1 = __webpack_require__(56);
var StandardInteractionsMixin_1 = __webpack_require__(60);
var DayTableMixin_1 = __webpack_require__(55);
var CoordCache_1 = __webpack_require__(53);
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var TimeGridEventRenderer_1 = __webpack_require__(246);
var TimeGridHelperRenderer_1 = __webpack_require__(247);
var TimeGridFillRenderer_1 = __webpack_require__(248);
/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days
// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
    { hours: 1 },
    { minutes: 30 },
    { minutes: 15 },
    { seconds: 30 },
    { seconds: 15 }
];
var TimeGrid = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGrid, _super);
    function TimeGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.processOptions();
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);
        var i;
        for (i = 0; i < segs.length; i++) {
            if (this.isRTL) {
                segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
            }
            else {
                segs[i].col = segs[i].dayIndex;
            }
        }
        return segs;
    };
    /* Date Handling
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {
        var segs = [];
        var segRange;
        var dayIndex;
        for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
            segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);
            if (segRange) {
                segs.push({
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                });
            }
        }
        return segs;
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Parses various options into properties of this object
    TimeGrid.prototype.processOptions = function () {
        var slotDuration = this.opt('slotDuration');
        var snapDuration = this.opt('snapDuration');
        var input;
        slotDuration = moment.duration(slotDuration);
        snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
        this.slotDuration = slotDuration;
        this.snapDuration = snapDuration;
        this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?
        // might be an array value (for TimelineView).
        // if so, getting the most granular entry (the last one probably).
        input = this.opt('slotLabelFormat');
        if ($.isArray(input)) {
            input = input[input.length - 1];
        }
        this.labelFormat = input ||
            this.opt('smallTimeFormat'); // the computed default
        input = this.opt('slotLabelInterval');
        this.labelInterval = input ?
            moment.duration(input) :
            this.computeLabelInterval(slotDuration);
    };
    // Computes an automatic value for slotLabelInterval
    TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
        var i;
        var labelInterval;
        var slotsPerLabel;
        // find the smallest stock label interval that results in more than one slots-per-label
        for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
            labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
            slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);
            if (util_1.isInt(slotsPerLabel) && slotsPerLabel > 1) {
                return labelInterval;
            }
        }
        return moment.duration(slotDuration); // fall back. clone
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderSlats();
        this.renderColumns();
    };
    TimeGrid.prototype.unrenderDates = function () {
        // this.unrenderSlats(); // don't need this because repeated .html() calls clear
        this.unrenderColumns();
    };
    TimeGrid.prototype.renderSkeleton = function () {
        var theme = this.view.calendar.theme;
        this.el.html('<div class="fc-bg"></div>' +
            '<div class="fc-slats"></div>' +
            '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" style="display:none" />');
        this.bottomRuleEl = this.el.find('hr');
    };
    TimeGrid.prototype.renderSlats = function () {
        var theme = this.view.calendar.theme;
        this.slatContainerEl = this.el.find('> .fc-slats')
            .html(// avoids needing ::unrenderSlats()
        '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderSlatRowHtml() +
            '</table>');
        this.slatEls = this.slatContainerEl.find('tr');
        this.slatCoordCache = new CoordCache_1.default({
            els: this.slatEls,
            isVertical: true
        });
    };
    // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
    TimeGrid.prototype.renderSlatRowHtml = function () {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var isRTL = this.isRTL;
        var dateProfile = this.dateProfile;
        var html = '';
        var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations
        var slotIterator = moment.duration(0);
        var slotDate; // will be on the view's first day, but we only care about its time
        var isLabeled;
        var axisHtml;
        // Calculate the time for each slot
        while (slotTime < dateProfile.maxTime) {
            slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);
            isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));
            axisHtml =
                '<td class="fc-axis fc-time ' + theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
                    (isLabeled ?
                        '<span>' + // for matchCellWidths
                            util_1.htmlEscape(slotDate.format(this.labelFormat)) +
                            '</span>' :
                        '') +
                    '</td>';
            html +=
                '<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
                    (isLabeled ? '' : ' class="fc-minor"') +
                    '>' +
                    (!isRTL ? axisHtml : '') +
                    '<td class="' + theme.getClass('widgetContent') + '"/>' +
                    (isRTL ? axisHtml : '') +
                    '</tr>';
            slotTime.add(this.slotDuration);
            slotIterator.add(this.slotDuration);
        }
        return html;
    };
    TimeGrid.prototype.renderColumns = function () {
        var dateProfile = this.dateProfile;
        var theme = this.view.calendar.theme;
        this.dayRanges = this.dayDates.map(function (dayDate) {
            return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));
        });
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        this.el.find('> .fc-bg').html('<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(0) + // row=0
            '</table>');
        this.colEls = this.el.find('.fc-day, .fc-disabled-day');
        this.colCoordCache = new CoordCache_1.default({
            els: this.colEls,
            isHorizontal: true
        });
        this.renderContentSkeleton();
    };
    TimeGrid.prototype.unrenderColumns = function () {
        this.unrenderContentSkeleton();
    };
    /* Content Skeleton
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders the DOM that the view's content will live in
    TimeGrid.prototype.renderContentSkeleton = function () {
        var cellHtml = '';
        var i;
        var skeletonEl;
        for (i = 0; i < this.colCnt; i++) {
            cellHtml +=
                '<td>' +
                    '<div class="fc-content-col">' +
                    '<div class="fc-event-container fc-helper-container"></div>' +
                    '<div class="fc-event-container"></div>' +
                    '<div class="fc-highlight-container"></div>' +
                    '<div class="fc-bgevent-container"></div>' +
                    '<div class="fc-business-container"></div>' +
                    '</div>' +
                    '</td>';
        }
        skeletonEl = this.contentSkeletonEl = $('<div class="fc-content-skeleton">' +
            '<table>' +
            '<tr>' + cellHtml + '</tr>' +
            '</table>' +
            '</div>');
        this.colContainerEls = skeletonEl.find('.fc-content-col');
        this.helperContainerEls = skeletonEl.find('.fc-helper-container');
        this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
        this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
        this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
        this.businessContainerEls = skeletonEl.find('.fc-business-container');
        this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
        this.el.append(skeletonEl);
    };
    TimeGrid.prototype.unrenderContentSkeleton = function () {
        if (this.contentSkeletonEl) {
            this.contentSkeletonEl.remove();
            this.contentSkeletonEl = null;
            this.colContainerEls = null;
            this.helperContainerEls = null;
            this.fgContainerEls = null;
            this.bgContainerEls = null;
            this.highlightContainerEls = null;
            this.businessContainerEls = null;
        }
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
    TimeGrid.prototype.groupSegsByCol = function (segs) {
        var segsByCol = [];
        var i;
        for (i = 0; i < this.colCnt; i++) {
            segsByCol.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segsByCol[segs[i].col].push(segs[i]);
        }
        return segsByCol;
    };
    // Given segments grouped by column, insert the segments' elements into a parallel array of container
    // elements, each living within a column.
    TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
        var col;
        var segs;
        var i;
        for (col = 0; col < this.colCnt; col++) {
            segs = segsByCol[col];
            for (i = 0; i < segs.length; i++) {
                containerEls.eq(col).append(segs[i].el);
            }
        }
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.getNowIndicatorUnit = function () {
        return 'minute'; // will refresh on the minute
    };
    TimeGrid.prototype.renderNowIndicator = function (date) {
        // HACK: if date columns not ready for some reason (scheduler)
        if (!this.colContainerEls) {
            return;
        }
        // seg system might be overkill, but it handles scenario where line needs to be rendered
        //  more than once because of columns with the same date (resources columns for example)
        var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range
        false // all-day
        ));
        var top = this.computeDateTop(date, date);
        var nodes = [];
        var i;
        // render lines within the columns
        for (i = 0; i < segs.length; i++) {
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
                .css('top', top)
                .appendTo(this.colContainerEls.eq(segs[i].col))[0]);
        }
        // render an arrow over the axis
        if (segs.length > 0) {
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
                .css('top', top)
                .appendTo(this.el.find('.fc-content-skeleton'))[0]);
        }
        this.nowIndicatorEls = $(nodes);
    };
    TimeGrid.prototype.unrenderNowIndicator = function () {
        if (this.nowIndicatorEls) {
            this.nowIndicatorEls.remove();
            this.nowIndicatorEls = null;
        }
    };
    /* Coordinates
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        this.slatCoordCache.build();
        if (isResize) {
            this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));
        }
    };
    TimeGrid.prototype.getTotalSlatHeight = function () {
        return this.slatContainerEl.outerHeight();
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given date.
    // `ms` can be a millisecond UTC time OR a UTC moment.
    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
    TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {
        return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
    TimeGrid.prototype.computeTimeTop = function (time) {
        var len = this.slatEls.length;
        var dateProfile = this.dateProfile;
        var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered
        var slatIndex;
        var slatRemainder;
        // compute a floating-point number for how many slats should be progressed through.
        // from 0 to number of slats (inclusive)
        // constrained because minTime/maxTime might be customized.
        slatCoverage = Math.max(0, slatCoverage);
        slatCoverage = Math.min(len, slatCoverage);
        // an integer index of the furthest whole slat
        // from 0 to number slats (*exclusive*, so len-1)
        slatIndex = Math.floor(slatCoverage);
        slatIndex = Math.min(slatIndex, len - 1);
        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
        // could be 1.0 if slatCoverage is covering *all* the slots
        slatRemainder = slatCoverage - slatIndex;
        return this.slatCoordCache.getTopPosition(slatIndex) +
            this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
    };
    // Refreshes the CSS top/bottom coordinates for each segment element.
    // Works when called after initial render, after a window resize/zoom for example.
    TimeGrid.prototype.updateSegVerticals = function (segs) {
        this.computeSegVerticals(segs);
        this.assignSegVerticals(segs);
    };
    // For each segment in an array, computes and assigns its top and bottom properties
    TimeGrid.prototype.computeSegVerticals = function (segs) {
        var eventMinHeight = this.opt('agendaEventMinHeight');
        var i;
        var seg;
        var dayDate;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            dayDate = this.dayDates[seg.dayIndex];
            seg.top = this.computeDateTop(seg.startMs, dayDate);
            seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));
        }
    };
    // Given segments that already have their top/bottom properties computed, applies those values to
    // the segments' elements.
    TimeGrid.prototype.assignSegVerticals = function (segs) {
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateSegVerticalCss(seg));
        }
    };
    // Generates an object with CSS properties for the top/bottom coordinates of a segment element
    TimeGrid.prototype.generateSegVerticalCss = function (seg) {
        return {
            top: seg.top,
            bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
        };
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.slatCoordCache.build();
    };
    TimeGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
    };
    TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {
        var snapsPerSlot = this.snapsPerSlot;
        var colCoordCache = this.colCoordCache;
        var slatCoordCache = this.slatCoordCache;
        if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
            var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
            var slatIndex = slatCoordCache.getVerticalIndex(topOffset);
            if (colIndex != null && slatIndex != null) {
                var slatTop = slatCoordCache.getTopOffset(slatIndex);
                var slatHeight = slatCoordCache.getHeight(slatIndex);
                var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
                var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
                var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;
                return {
                    col: colIndex,
                    snap: snapIndex,
                    component: this,
                    left: colCoordCache.getLeftOffset(colIndex),
                    right: colCoordCache.getRightOffset(colIndex),
                    top: snapTop,
                    bottom: snapBottom
                };
            }
        }
    };
    TimeGrid.prototype.getHitFootprint = function (hit) {
        var start = this.getCellDate(0, hit.col); // row=0
        var time = this.computeSnapTime(hit.snap); // pass in the snap-index
        var end;
        start.time(time);
        end = start.clone().add(this.snapDuration);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?
        );
    };
    // Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
    TimeGrid.prototype.computeSnapTime = function (snapIndex) {
        return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);
    };
    TimeGrid.prototype.getHitEl = function (hit) {
        return this.colEls.eq(hit.col);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being dragged over the specified date(s).
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        if (seg) {
            if (eventFootprints.length) {
                this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
                // signal that a helper has been rendered
                return true;
            }
        }
        else {
            for (i = 0; i < eventFootprints.length; i++) {
                this.renderHighlight(eventFootprints[i].componentFootprint);
            }
        }
    };
    // Unrenders any visual indication of an event being dragged
    TimeGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders any visual indication of an event being resized
    TimeGrid.prototype.unrenderEventResize = function () {
        this.helperRenderer.unrender();
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
    TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (this.opt('selectHelper')) {
            this.helperRenderer.renderComponentFootprint(componentFootprint);
        }
        else {
            this.renderHighlight(componentFootprint);
        }
    };
    // Unrenders any visual indication of a selection
    TimeGrid.prototype.unrenderSelection = function () {
        this.helperRenderer.unrender();
        this.unrenderHighlight();
    };
    return TimeGrid;
}(InteractiveDateComponent_1.default));
exports.default = TimeGrid;
TimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;
TimeGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
TimeGrid.prototype.helperRendererClass = TimeGridHelperRenderer_1.default;
TimeGrid.prototype.fillRendererClass = TimeGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(TimeGrid);
DayTableMixin_1.default.mixInto(TimeGrid);


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(5);
var DateProfileGenerator_1 = __webpack_require__(221);
var BasicViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(BasicViewDateProfileGenerator, _super);
    function BasicViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        // year and month views should be aligned with weeks. this is already done for week
        if (/^(year|month)$/.test(currentRangeUnit)) {
            start.startOf('week');
            // make end-of-week if not already
            if (end.weekday()) {
                end.add(1, 'week').startOf('week'); // exclusively move backwards
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    return BasicViewDateProfileGenerator;
}(DateProfileGenerator_1.default));
exports.default = BasicViewDateProfileGenerator;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var BasicView_1 = __webpack_require__(62);
var MonthViewDateProfileGenerator_1 = __webpack_require__(253);
/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/
var MonthView = /** @class */ (function (_super) {
    tslib_1.__extends(MonthView, _super);
    function MonthView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Overrides the default BasicView behavior to have special multi-week auto-height logic
    MonthView.prototype.setGridHeight = function (height, isAuto) {
        // if auto, make the height of each row the height that it would be if there were 6 weeks
        if (isAuto) {
            height *= this.dayGrid.rowCnt / 6;
        }
        util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
    };
    MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize
    };
    return MonthView;
}(BasicView_1.default));
exports.default = MonthView;
MonthView.prototype.dateProfileGeneratorClass = MonthViewDateProfileGenerator_1.default;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var UnzonedRange_1 = __webpack_require__(5);
var View_1 = __webpack_require__(41);
var Scroller_1 = __webpack_require__(39);
var ListEventRenderer_1 = __webpack_require__(254);
var ListEventPointing_1 = __webpack_require__(255);
/*
Responsible for the scroller, and forwarding event-related actions into the "grid".
*/
var ListView = /** @class */ (function (_super) {
    tslib_1.__extends(ListView, _super);
    function ListView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.segSelector = '.fc-list-item'; // which elements accept event actions
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    ListView.prototype.renderSkeleton = function () {
        this.el.addClass('fc-list-view ' +
            this.calendar.theme.getClass('listView'));
        this.scroller.render();
        this.scroller.el.appendTo(this.el);
        this.contentEl = this.scroller.scrollEl; // shortcut
    };
    ListView.prototype.unrenderSkeleton = function () {
        this.scroller.destroy(); // will remove the Grid too
    };
    ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        this.scroller.clear(); // sets height to 'auto' and clears overflow
        if (!isAuto) {
            this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
        }
    };
    ListView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    ListView.prototype.renderDates = function (dateProfile) {
        var calendar = this.calendar;
        var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);
        var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);
        var dayDates = [];
        var dayRanges = [];
        while (dayStart < viewEnd) {
            dayDates.push(dayStart.clone());
            dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, 'day')));
            dayStart.add(1, 'day');
        }
        this.dayDates = dayDates;
        this.dayRanges = dayRanges;
        // all real rendering happens in EventRenderer
    };
    // slices by day
    ListView.prototype.componentFootprintToSegs = function (footprint) {
        var dayRanges = this.dayRanges;
        var dayIndex;
        var segRange;
        var seg;
        var segs = [];
        for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {
            segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);
            if (segRange) {
                seg = {
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                };
                segs.push(seg);
                // detect when footprint won't go fully into the next day,
                // and mutate the latest seg to the be the end.
                if (!seg.isEnd && !footprint.isAllDay &&
                    dayIndex + 1 < dayRanges.length &&
                    footprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {
                    seg.endMs = footprint.unzonedRange.endMs;
                    seg.isEnd = true;
                    break;
                }
            }
        }
        return segs;
    };
    ListView.prototype.renderEmptyMessage = function () {
        this.contentEl.html('<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
            '<div class="fc-list-empty-wrap1">' +
            '<div class="fc-list-empty">' +
            util_1.htmlEscape(this.opt('noEventsMessage')) +
            '</div>' +
            '</div>' +
            '</div>');
    };
    // render the event segments in the view
    ListView.prototype.renderSegList = function (allSegs) {
        var segsByDay = this.groupSegsByDay(allSegs); // sparse array
        var dayIndex;
        var daySegs;
        var i;
        var tableEl = $('<table class="fc-list-table ' + this.calendar.theme.getClass('tableList') + '"><tbody/></table>');
        var tbodyEl = tableEl.find('tbody');
        for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
            daySegs = segsByDay[dayIndex];
            if (daySegs) {
                // append a day header
                tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));
                this.eventRenderer.sortEventSegs(daySegs);
                for (i = 0; i < daySegs.length; i++) {
                    tbodyEl.append(daySegs[i].el); // append event row
                }
            }
        }
        this.contentEl.empty().append(tableEl);
    };
    // Returns a sparse array of arrays, segs grouped by their dayIndex
    ListView.prototype.groupSegsByDay = function (segs) {
        var segsByDay = []; // sparse array
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
                .push(seg);
        }
        return segsByDay;
    };
    // generates the HTML for the day headers that live amongst the event rows
    ListView.prototype.dayHeaderHtml = function (dayDate) {
        var mainFormat = this.opt('listDayFormat');
        var altFormat = this.opt('listDayAltFormat');
        return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
            '<td class="' + (this.calendar.theme.getClass('tableListHeading') ||
            this.calendar.theme.getClass('widgetHeader')) + '" colspan="3">' +
            (mainFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-main' }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML
                ) :
                '') +
            (altFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-alt' }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML
                ) :
                '') +
            '</td>' +
            '</tr>';
    };
    return ListView;
}(View_1.default));
exports.default = ListView;
ListView.prototype.eventRendererClass = ListEventRenderer_1.default;
ListView.prototype.eventPointingClass = ListEventPointing_1.default;


/***/ }),
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(3);
var exportHooks = __webpack_require__(16);
var util_1 = __webpack_require__(4);
var Calendar_1 = __webpack_require__(220);
// for intentional side-effects
__webpack_require__(10);
__webpack_require__(47);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
$.fullCalendar = exportHooks;
$.fn.fullCalendar = function (options) {
    var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
    var res = this; // what this function will return (this jQuery object by default)
    this.each(function (i, _element) {
        var element = $(_element);
        var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
        var singleRes; // the returned value of this single method call
        // a method call
        if (typeof options === 'string') {
            if (options === 'getCalendar') {
                if (!i) {
                    res = calendar;
                }
            }
            else if (options === 'destroy') {
                if (calendar) {
                    calendar.destroy();
                    element.removeData('fullCalendar');
                }
            }
            else if (!calendar) {
                util_1.warn('Attempting to call a FullCalendar method on an element with no calendar.');
            }
            else if ($.isFunction(calendar[options])) {
                singleRes = calendar[options].apply(calendar, args);
                if (!i) {
                    res = singleRes; // record the first method call result
                }
                if (options === 'destroy') {
                    element.removeData('fullCalendar');
                }
            }
            else {
                util_1.warn("'" + options + "' is an unknown FullCalendar method.");
            }
        }
        else if (!calendar) {
            calendar = new Calendar_1.default(element, options);
            element.data('fullCalendar', calendar);
            calendar.render();
        }
    });
    return res;
};
module.exports = exportHooks;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Model_1 = __webpack_require__(48);
var Component = /** @class */ (function (_super) {
    tslib_1.__extends(Component, _super);
    function Component() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Component.prototype.setElement = function (el) {
        this.el = el;
        this.bindGlobalHandlers();
        this.renderSkeleton();
        this.set('isInDom', true);
    };
    Component.prototype.removeElement = function () {
        this.unset('isInDom');
        this.unrenderSkeleton();
        this.unbindGlobalHandlers();
        this.el.remove();
        // NOTE: don't null-out this.el in case the View was destroyed within an API callback.
        // We don't null-out the View's other jQuery element references upon destroy,
        //  so we shouldn't kill this.el either.
    };
    Component.prototype.bindGlobalHandlers = function () {
        // subclasses can override
    };
    Component.prototype.unbindGlobalHandlers = function () {
        // subclasses can override
    };
    /*
    NOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender
    */
    // Renders the basic structure of the view before any content is rendered
    Component.prototype.renderSkeleton = function () {
        // subclasses should implement
    };
    // Unrenders the basic structure of the view
    Component.prototype.unrenderSkeleton = function () {
        // subclasses should implement
    };
    return Component;
}(Model_1.default));
exports.default = Component;


/***/ }),
/* 238 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Iterator = /** @class */ (function () {
    function Iterator(items) {
        this.items = items || [];
    }
    /* Calls a method on every item passing the arguments through */
    Iterator.prototype.proxyCall = function (methodName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var results = [];
        this.items.forEach(function (item) {
            results.push(item[methodName].apply(item, args));
        });
        return results;
    };
    return Iterator;
}());
exports.default = Iterator;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/
var Toolbar = /** @class */ (function () {
    function Toolbar(calendar, toolbarOptions) {
        this.el = null; // mirrors local `el`
        this.viewsWithButtons = [];
        this.calendar = calendar;
        this.toolbarOptions = toolbarOptions;
    }
    // method to update toolbar-specific options, not calendar-wide options
    Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {
        this.toolbarOptions = newToolbarOptions;
    };
    // can be called repeatedly and will rerender
    Toolbar.prototype.render = function () {
        var sections = this.toolbarOptions.layout;
        var el = this.el;
        if (sections) {
            if (!el) {
                el = this.el = $("<div class='fc-toolbar " + this.toolbarOptions.extraClasses + "'/>");
            }
            else {
                el.empty();
            }
            el.append(this.renderSection('left'))
                .append(this.renderSection('right'))
                .append(this.renderSection('center'))
                .append('<div class="fc-clear"/>');
        }
        else {
            this.removeElement();
        }
    };
    Toolbar.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    Toolbar.prototype.renderSection = function (position) {
        var _this = this;
        var calendar = this.calendar;
        var theme = calendar.theme;
        var optionsManager = calendar.optionsManager;
        var viewSpecManager = calendar.viewSpecManager;
        var sectionEl = $('<div class="fc-' + position + '"/>');
        var buttonStr = this.toolbarOptions.layout[position];
        var calendarCustomButtons = optionsManager.get('customButtons') || {};
        var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
        var calendarButtonText = optionsManager.get('buttonText') || {};
        if (buttonStr) {
            $.each(buttonStr.split(' '), function (i, buttonGroupStr) {
                var groupChildren = $();
                var isOnlyButtons = true;
                var groupEl;
                $.each(buttonGroupStr.split(','), function (j, buttonName) {
                    var customButtonProps;
                    var viewSpec;
                    var buttonClick;
                    var buttonIcon; // only one of these will be set
                    var buttonText; // "
                    var buttonInnerHtml;
                    var buttonClasses;
                    var buttonEl;
                    var buttonAriaAttr;
                    if (buttonName === 'title') {
                        groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
                        isOnlyButtons = false;
                    }
                    else {
                        if ((customButtonProps = calendarCustomButtons[buttonName])) {
                            buttonClick = function (ev) {
                                if (customButtonProps.click) {
                                    customButtonProps.click.call(buttonEl[0], ev);
                                }
                            };
                            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = customButtonProps.text);
                        }
                        else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {
                            _this.viewsWithButtons.push(buttonName);
                            buttonClick = function () {
                                calendar.changeView(buttonName);
                            };
                            (buttonText = viewSpec.buttonTextOverride) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = viewSpec.buttonTextDefault);
                        }
                        else if (calendar[buttonName]) {
                            buttonClick = function () {
                                calendar[buttonName]();
                            };
                            (buttonText = calendarButtonTextOverrides[buttonName]) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = calendarButtonText[buttonName]);
                            //            ^ everything else is considered default
                        }
                        if (buttonClick) {
                            buttonClasses = [
                                'fc-' + buttonName + '-button',
                                theme.getClass('button'),
                                theme.getClass('stateDefault')
                            ];
                            if (buttonText) {
                                buttonInnerHtml = util_1.htmlEscape(buttonText);
                                buttonAriaAttr = '';
                            }
                            else if (buttonIcon) {
                                buttonInnerHtml = "<span class='" + buttonIcon + "'></span>";
                                buttonAriaAttr = ' aria-label="' + buttonName + '"';
                            }
                            buttonEl = $(// type="button" so that it doesn't submit a form
                            '<button type="button" class="' + buttonClasses.join(' ') + '"' +
                                buttonAriaAttr +
                                '>' + buttonInnerHtml + '</button>')
                                .click(function (ev) {
                                // don't process clicks for disabled buttons
                                if (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                    buttonClick(ev);
                                    // after the click action, if the button becomes the "active" tab, or disabled,
                                    // it should never have a hover class, so remove it now.
                                    if (buttonEl.hasClass(theme.getClass('stateActive')) ||
                                        buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                        buttonEl.removeClass(theme.getClass('stateHover'));
                                    }
                                }
                            })
                                .mousedown(function () {
                                // the *down* effect (mouse pressed in).
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateDown'));
                            })
                                .mouseup(function () {
                                // undo the *down* effect
                                buttonEl.removeClass(theme.getClass('stateDown'));
                            })
                                .hover(function () {
                                // the *hover* effect.
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateHover'));
                            }, function () {
                                // undo the *hover* effect
                                buttonEl
                                    .removeClass(theme.getClass('stateHover'))
                                    .removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup
                            });
                            groupChildren = groupChildren.add(buttonEl);
                        }
                    }
                });
                if (isOnlyButtons) {
                    groupChildren
                        .first().addClass(theme.getClass('cornerLeft')).end()
                        .last().addClass(theme.getClass('cornerRight')).end();
                }
                if (groupChildren.length > 1) {
                    groupEl = $('<div/>');
                    if (isOnlyButtons) {
                        groupEl.addClass(theme.getClass('buttonGroup'));
                    }
                    groupEl.append(groupChildren);
                    sectionEl.append(groupEl);
                }
                else {
                    sectionEl.append(groupChildren); // 1 or 0 children
                }
            });
        }
        return sectionEl;
    };
    Toolbar.prototype.updateTitle = function (text) {
        if (this.el) {
            this.el.find('h2').text(text);
        }
    };
    Toolbar.prototype.activateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .addClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.deactivateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .removeClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.disableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', true)
                .addClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.enableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', false)
                .removeClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.getViewsWithButtons = function () {
        return this.viewsWithButtons;
    };
    return Toolbar;
}());
exports.default = Toolbar;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var options_1 = __webpack_require__(32);
var locale_1 = __webpack_require__(31);
var Model_1 = __webpack_require__(48);
var OptionsManager = /** @class */ (function (_super) {
    tslib_1.__extends(OptionsManager, _super);
    function OptionsManager(_calendar, overrides) {
        var _this = _super.call(this) || this;
        _this._calendar = _calendar;
        _this.overrides = $.extend({}, overrides); // make a copy
        _this.dynamicOverrides = {};
        _this.compute();
        return _this;
    }
    OptionsManager.prototype.add = function (newOptionHash) {
        var optionCnt = 0;
        var optionName;
        this.recordOverrides(newOptionHash); // will trigger this model's watchers
        for (optionName in newOptionHash) {
            optionCnt++;
        }
        // special-case handling of single option change.
        // if only one option change, `optionName` will be its name.
        if (optionCnt === 1) {
            if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
                this._calendar.updateViewSize(true); // isResize=true
                return;
            }
            else if (optionName === 'defaultDate') {
                return; // can't change date this way. use gotoDate instead
            }
            else if (optionName === 'businessHours') {
                return; // this model already reacts to this
            }
            else if (/^(event|select)(Overlap|Constraint|Allow)$/.test(optionName)) {
                return; // doesn't affect rendering. only interactions.
            }
            else if (optionName === 'timezone') {
                this._calendar.view.flash('initialEvents');
                return;
            }
        }
        // catch-all. rerender the header and footer and rebuild/rerender the current view
        this._calendar.renderHeader();
        this._calendar.renderFooter();
        // even non-current views will be affected by this option change. do before rerender
        // TODO: detangle
        this._calendar.viewsByType = {};
        this._calendar.reinitView();
    };
    // Computes the flattened options hash for the calendar and assigns to `this.options`.
    // Assumes this.overrides and this.dynamicOverrides have already been initialized.
    OptionsManager.prototype.compute = function () {
        var locale;
        var localeDefaults;
        var isRTL;
        var dirDefaults;
        var rawOptions;
        locale = util_1.firstDefined(// explicit locale option given?
        this.dynamicOverrides.locale, this.overrides.locale);
        localeDefaults = locale_1.localeOptionHash[locale];
        if (!localeDefaults) {
            locale = options_1.globalDefaults.locale;
            localeDefaults = locale_1.localeOptionHash[locale] || {};
        }
        isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?
        this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);
        dirDefaults = isRTL ? options_1.rtlDefaults : {};
        this.dirDefaults = dirDefaults;
        this.localeDefaults = localeDefaults;
        rawOptions = options_1.mergeOptions([
            options_1.globalDefaults,
            dirDefaults,
            localeDefaults,
            this.overrides,
            this.dynamicOverrides
        ]);
        locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options
        this.reset(rawOptions);
    };
    // stores the new options internally, but does not rerender anything.
    OptionsManager.prototype.recordOverrides = function (newOptionHash) {
        var optionName;
        for (optionName in newOptionHash) {
            this.dynamicOverrides[optionName] = newOptionHash[optionName];
        }
        this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it
        this.compute(); // this.options needs to be recomputed after the dynamic override
    };
    return OptionsManager;
}(Model_1.default));
exports.default = OptionsManager;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
var ViewRegistry_1 = __webpack_require__(22);
var util_1 = __webpack_require__(4);
var options_1 = __webpack_require__(32);
var locale_1 = __webpack_require__(31);
var ViewSpecManager = /** @class */ (function () {
    function ViewSpecManager(optionsManager, _calendar) {
        this.optionsManager = optionsManager;
        this._calendar = _calendar;
        this.clearCache();
    }
    ViewSpecManager.prototype.clearCache = function () {
        this.viewSpecCache = {};
    };
    // Gets information about how to create a view. Will use a cache.
    ViewSpecManager.prototype.getViewSpec = function (viewType) {
        var cache = this.viewSpecCache;
        return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
    };
    // Given a duration singular unit, like "week" or "day", finds a matching view spec.
    // Preference is given to views that have corresponding buttons.
    ViewSpecManager.prototype.getUnitViewSpec = function (unit) {
        var viewTypes;
        var i;
        var spec;
        if ($.inArray(unit, util_1.unitsDesc) !== -1) {
            // put views that have buttons first. there will be duplicates, but oh well
            viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?
            $.each(ViewRegistry_1.viewHash, function (viewType) {
                viewTypes.push(viewType);
            });
            for (i = 0; i < viewTypes.length; i++) {
                spec = this.getViewSpec(viewTypes[i]);
                if (spec) {
                    if (spec.singleUnit === unit) {
                        return spec;
                    }
                }
            }
        }
    };
    // Builds an object with information on how to create a given view
    ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {
        var viewOverrides = this.optionsManager.overrides.views || {};
        var specChain = []; // for the view. lowest to highest priority
        var defaultsChain = []; // for the view. lowest to highest priority
        var overridesChain = []; // for the view. lowest to highest priority
        var viewType = requestedViewType;
        var spec; // for the view
        var overrides; // for the view
        var durationInput;
        var duration;
        var unit;
        // iterate from the specific view definition to a more general one until we hit an actual View class
        while (viewType) {
            spec = ViewRegistry_1.viewHash[viewType];
            overrides = viewOverrides[viewType];
            viewType = null; // clear. might repopulate for another iteration
            if (typeof spec === 'function') {
                spec = { 'class': spec };
            }
            if (spec) {
                specChain.unshift(spec);
                defaultsChain.unshift(spec.defaults || {});
                durationInput = durationInput || spec.duration;
                viewType = viewType || spec.type;
            }
            if (overrides) {
                overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
                durationInput = durationInput || overrides.duration;
                viewType = viewType || overrides.type;
            }
        }
        spec = util_1.mergeProps(specChain);
        spec.type = requestedViewType;
        if (!spec['class']) {
            return false;
        }
        // fall back to top-level `duration` option
        durationInput = durationInput ||
            this.optionsManager.dynamicOverrides.duration ||
            this.optionsManager.overrides.duration;
        if (durationInput) {
            duration = moment.duration(durationInput);
            if (duration.valueOf()) {
                unit = util_1.computeDurationGreatestUnit(duration, durationInput);
                spec.duration = duration;
                spec.durationUnit = unit;
                // view is a single-unit duration, like "week" or "day"
                // incorporate options for this. lowest priority
                if (duration.as(unit) === 1) {
                    spec.singleUnit = unit;
                    overridesChain.unshift(viewOverrides[unit] || {});
                }
            }
        }
        spec.defaults = options_1.mergeOptions(defaultsChain);
        spec.overrides = options_1.mergeOptions(overridesChain);
        this.buildViewSpecOptions(spec);
        this.buildViewSpecButtonText(spec, requestedViewType);
        return spec;
    };
    // Builds and assigns a view spec's options object from its already-assigned defaults and overrides
    ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {
        var optionsManager = this.optionsManager;
        spec.options = options_1.mergeOptions([
            options_1.globalDefaults,
            spec.defaults,
            optionsManager.dirDefaults,
            optionsManager.localeDefaults,
            optionsManager.overrides,
            spec.overrides,
            optionsManager.dynamicOverrides // dynamically set via setter. highest precedence
        ]);
        locale_1.populateInstanceComputableOptions(spec.options);
    };
    // Computes and assigns a view spec's buttonText-related options
    ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {
        var optionsManager = this.optionsManager;
        // given an options object with a possible `buttonText` hash, lookup the buttonText for the
        // requested view, falling back to a generic unit entry like "week" or "day"
        function queryButtonText(options) {
            var buttonText = options.buttonText || {};
            return buttonText[requestedViewType] ||
                // view can decide to look up a certain key
                (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
                // a key like "month"
                (spec.singleUnit ? buttonText[spec.singleUnit] : null);
        }
        // highest to lowest priority
        spec.buttonTextOverride =
            queryButtonText(optionsManager.dynamicOverrides) ||
                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
                spec.overrides.buttonText; // `buttonText` for view-specific options is a string
        // highest to lowest priority. mirrors buildViewSpecOptions
        spec.buttonTextDefault =
            queryButtonText(optionsManager.localeDefaults) ||
                queryButtonText(optionsManager.dirDefaults) ||
                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
                queryButtonText(options_1.globalDefaults) ||
                (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like "3 days"
                requestedViewType; // fall back to given view name
    };
    return ViewSpecManager;
}());
exports.default = ViewSpecManager;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventPeriod_1 = __webpack_require__(243);
var ArrayEventSource_1 = __webpack_require__(52);
var EventSource_1 = __webpack_require__(6);
var EventSourceParser_1 = __webpack_require__(38);
var SingleEventDef_1 = __webpack_require__(13);
var EventInstanceGroup_1 = __webpack_require__(18);
var EmitterMixin_1 = __webpack_require__(11);
var ListenerMixin_1 = __webpack_require__(7);
var EventManager = /** @class */ (function () {
    function EventManager(calendar) {
        this.calendar = calendar;
        this.stickySource = new ArrayEventSource_1.default(calendar);
        this.otherSources = [];
    }
    EventManager.prototype.requestEvents = function (start, end, timezone, force) {
        if (force ||
            !this.currentPeriod ||
            !this.currentPeriod.isWithinRange(start, end) ||
            timezone !== this.currentPeriod.timezone) {
            this.setPeriod(// will change this.currentPeriod
            new EventPeriod_1.default(start, end, timezone));
        }
        return this.currentPeriod.whenReleased();
    };
    // Source Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.addSource = function (eventSource) {
        this.otherSources.push(eventSource);
        if (this.currentPeriod) {
            this.currentPeriod.requestSource(eventSource); // might release
        }
    };
    EventManager.prototype.removeSource = function (doomedSource) {
        util_1.removeExact(this.otherSources, doomedSource);
        if (this.currentPeriod) {
            this.currentPeriod.purgeSource(doomedSource); // might release
        }
    };
    EventManager.prototype.removeAllSources = function () {
        this.otherSources = [];
        if (this.currentPeriod) {
            this.currentPeriod.purgeAllSources(); // might release
        }
    };
    // Source Refetching
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.refetchSource = function (eventSource) {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeSource(eventSource);
            currentPeriod.requestSource(eventSource);
            currentPeriod.thaw();
        }
    };
    EventManager.prototype.refetchAllSources = function () {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeAllSources();
            currentPeriod.requestSources(this.getSources());
            currentPeriod.thaw();
        }
    };
    // Source Querying
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getSources = function () {
        return [this.stickySource].concat(this.otherSources);
    };
    // like querySources, but accepts multple match criteria (like multiple IDs)
    EventManager.prototype.multiQuerySources = function (matchInputs) {
        // coerce into an array
        if (!matchInputs) {
            matchInputs = [];
        }
        else if (!$.isArray(matchInputs)) {
            matchInputs = [matchInputs];
        }
        var matchingSources = [];
        var i;
        // resolve raw inputs to real event source objects
        for (i = 0; i < matchInputs.length; i++) {
            matchingSources.push.apply(// append
            matchingSources, this.querySources(matchInputs[i]));
        }
        return matchingSources;
    };
    // matchInput can either by a real event source object, an ID, or the function/URL for the source.
    // returns an array of matching source objects.
    EventManager.prototype.querySources = function (matchInput) {
        var sources = this.otherSources;
        var i;
        var source;
        // given a proper event source object
        for (i = 0; i < sources.length; i++) {
            source = sources[i];
            if (source === matchInput) {
                return [source];
            }
        }
        // an ID match
        source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));
        if (source) {
            return [source];
        }
        // parse as an event source
        matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);
        if (matchInput) {
            return $.grep(sources, function (source) {
                return isSourcesEquivalent(matchInput, source);
            });
        }
    };
    /*
    ID assumed to already be normalized
    */
    EventManager.prototype.getSourceById = function (id) {
        return $.grep(this.otherSources, function (source) {
            return source.id && source.id === id;
        })[0];
    };
    // Event-Period
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.setPeriod = function (eventPeriod) {
        if (this.currentPeriod) {
            this.unbindPeriod(this.currentPeriod);
            this.currentPeriod = null;
        }
        this.currentPeriod = eventPeriod;
        this.bindPeriod(eventPeriod);
        eventPeriod.requestSources(this.getSources());
    };
    EventManager.prototype.bindPeriod = function (eventPeriod) {
        this.listenTo(eventPeriod, 'release', function (eventsPayload) {
            this.trigger('release', eventsPayload);
        });
    };
    EventManager.prototype.unbindPeriod = function (eventPeriod) {
        this.stopListeningTo(eventPeriod);
    };
    // Event Getting/Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getEventDefByUid = function (uid) {
        if (this.currentPeriod) {
            return this.currentPeriod.getEventDefByUid(uid);
        }
    };
    EventManager.prototype.addEventDef = function (eventDef, isSticky) {
        if (isSticky) {
            this.stickySource.addEventDef(eventDef);
        }
        if (this.currentPeriod) {
            this.currentPeriod.addEventDef(eventDef); // might release
        }
    };
    EventManager.prototype.removeEventDefsById = function (eventId) {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeEventDefsById(eventId);
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeEventDefsById(eventId); // might release
        }
    };
    EventManager.prototype.removeAllEventDefs = function () {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeAllEventDefs();
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeAllEventDefs();
        }
    };
    // Event Mutating
    // -----------------------------------------------------------------------------------------------------------------
    /*
    Returns an undo function.
    */
    EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {
        var currentPeriod = this.currentPeriod;
        var eventDefs;
        var undoFuncs = [];
        if (currentPeriod) {
            currentPeriod.freeze();
            eventDefs = currentPeriod.getEventDefsById(eventDefId);
            eventDefs.forEach(function (eventDef) {
                // add/remove esp because id might change
                currentPeriod.removeEventDef(eventDef);
                undoFuncs.push(eventDefMutation.mutateSingle(eventDef));
                currentPeriod.addEventDef(eventDef);
            });
            currentPeriod.thaw();
            return function () {
                currentPeriod.freeze();
                for (var i = 0; i < eventDefs.length; i++) {
                    currentPeriod.removeEventDef(eventDefs[i]);
                    undoFuncs[i]();
                    currentPeriod.addEventDef(eventDefs[i]);
                }
                currentPeriod.thaw();
            };
        }
        return function () { };
    };
    /*
    copies and then mutates
    */
    EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {
        var eventDefs = this.getEventDefsById(eventDefId);
        var i;
        var defCopy;
        var allInstances = [];
        for (i = 0; i < eventDefs.length; i++) {
            defCopy = eventDefs[i].clone();
            if (defCopy instanceof SingleEventDef_1.default) {
                eventDefMutation.mutateSingle(defCopy);
                allInstances.push.apply(allInstances, // append
                defCopy.buildInstances());
            }
        }
        return new EventInstanceGroup_1.default(allInstances);
    };
    // Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.freeze = function () {
        if (this.currentPeriod) {
            this.currentPeriod.freeze();
        }
    };
    EventManager.prototype.thaw = function () {
        if (this.currentPeriod) {
            this.currentPeriod.thaw();
        }
    };
    // methods that simply forward to EventPeriod
    EventManager.prototype.getEventDefsById = function (eventDefId) {
        return this.currentPeriod.getEventDefsById(eventDefId);
    };
    EventManager.prototype.getEventInstances = function () {
        return this.currentPeriod.getEventInstances();
    };
    EventManager.prototype.getEventInstancesWithId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithId(eventDefId);
    };
    EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithoutId(eventDefId);
    };
    return EventManager;
}());
exports.default = EventManager;
EmitterMixin_1.default.mixInto(EventManager);
ListenerMixin_1.default.mixInto(EventManager);
function isSourcesEquivalent(source0, source1) {
    return source0.getPrimitive() === source1.getPrimitive();
}


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Promise_1 = __webpack_require__(20);
var EmitterMixin_1 = __webpack_require__(11);
var UnzonedRange_1 = __webpack_require__(5);
var EventInstanceGroup_1 = __webpack_require__(18);
var EventPeriod = /** @class */ (function () {
    function EventPeriod(start, end, timezone) {
        this.pendingCnt = 0;
        this.freezeDepth = 0;
        this.stuntedReleaseCnt = 0;
        this.releaseCnt = 0;
        this.start = start;
        this.end = end;
        this.timezone = timezone;
        this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());
        this.requestsByUid = {};
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
    }
    EventPeriod.prototype.isWithinRange = function (start, end) {
        // TODO: use a range util function?
        return !start.isBefore(this.start) && !end.isAfter(this.end);
    };
    // Requesting and Purging
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.requestSources = function (sources) {
        this.freeze();
        for (var i = 0; i < sources.length; i++) {
            this.requestSource(sources[i]);
        }
        this.thaw();
    };
    EventPeriod.prototype.requestSource = function (source) {
        var _this = this;
        var request = { source: source, status: 'pending', eventDefs: null };
        this.requestsByUid[source.uid] = request;
        this.pendingCnt += 1;
        source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {
            if (request.status !== 'cancelled') {
                request.status = 'completed';
                request.eventDefs = eventDefs;
                _this.addEventDefs(eventDefs);
                _this.pendingCnt--;
                _this.tryRelease();
            }
        }, function () {
            if (request.status !== 'cancelled') {
                request.status = 'failed';
                _this.pendingCnt--;
                _this.tryRelease();
            }
        });
    };
    EventPeriod.prototype.purgeSource = function (source) {
        var request = this.requestsByUid[source.uid];
        if (request) {
            delete this.requestsByUid[source.uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
                this.pendingCnt--;
                this.tryRelease();
            }
            else if (request.status === 'completed') {
                request.eventDefs.forEach(this.removeEventDef.bind(this));
            }
        }
    };
    EventPeriod.prototype.purgeAllSources = function () {
        var requestsByUid = this.requestsByUid;
        var uid;
        var request;
        var completedCnt = 0;
        for (uid in requestsByUid) {
            request = requestsByUid[uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
            }
            else if (request.status === 'completed') {
                completedCnt++;
            }
        }
        this.requestsByUid = {};
        this.pendingCnt = 0;
        if (completedCnt) {
            this.removeAllEventDefs(); // might release
        }
    };
    // Event Definitions
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {
        return this.eventDefsByUid[eventDefUid];
    };
    EventPeriod.prototype.getEventDefsById = function (eventDefId) {
        var a = this.eventDefsById[eventDefId];
        if (a) {
            return a.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.addEventDefs = function (eventDefs) {
        for (var i = 0; i < eventDefs.length; i++) {
            this.addEventDef(eventDefs[i]);
        }
    };
    EventPeriod.prototype.addEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefId = eventDef.id;
        var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);
        var eventInstances = eventDef.buildInstances(this.unzonedRange);
        var i;
        eventDefs.push(eventDef);
        this.eventDefsByUid[eventDef.uid] = eventDef;
        for (i = 0; i < eventInstances.length; i++) {
            this.addEventInstance(eventInstances[i], eventDefId);
        }
    };
    EventPeriod.prototype.removeEventDefsById = function (eventDefId) {
        var _this = this;
        this.getEventDefsById(eventDefId).forEach(function (eventDef) {
            _this.removeEventDef(eventDef);
        });
    };
    EventPeriod.prototype.removeAllEventDefs = function () {
        var isEmpty = $.isEmptyObject(this.eventDefsByUid);
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
        if (!isEmpty) {
            this.tryRelease();
        }
    };
    EventPeriod.prototype.removeEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefs = eventDefsById[eventDef.id];
        delete this.eventDefsByUid[eventDef.uid];
        if (eventDefs) {
            util_1.removeExact(eventDefs, eventDef);
            if (!eventDefs.length) {
                delete eventDefsById[eventDef.id];
            }
            this.removeEventInstancesForDef(eventDef);
        }
    };
    // Event Instances
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventInstances = function () {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            eventInstances.push.apply(eventInstances, // append
            eventInstanceGroupsById[id].eventInstances);
        }
        return eventInstances;
    };
    EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {
        var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];
        if (eventInstanceGroup) {
            return eventInstanceGroup.eventInstances.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var matchingInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            if (id !== eventDefId) {
                matchingInstances.push.apply(matchingInstances, // append
                eventInstanceGroupsById[id].eventInstances);
            }
        }
        return matchingInstances;
    };
    EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||
            (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());
        eventInstanceGroup.eventInstances.push(eventInstance);
        this.tryRelease();
    };
    EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];
        var removeCnt;
        if (eventInstanceGroup) {
            removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {
                return currentEventInstance.def === eventDef;
            });
            if (!eventInstanceGroup.eventInstances.length) {
                delete eventInstanceGroupsById[eventDef.id];
            }
            if (removeCnt) {
                this.tryRelease();
            }
        }
    };
    // Releasing and Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.tryRelease = function () {
        if (!this.pendingCnt) {
            if (!this.freezeDepth) {
                this.release();
            }
            else {
                this.stuntedReleaseCnt++;
            }
        }
    };
    EventPeriod.prototype.release = function () {
        this.releaseCnt++;
        this.trigger('release', this.eventInstanceGroupsById);
    };
    EventPeriod.prototype.whenReleased = function () {
        var _this = this;
        if (this.releaseCnt) {
            return Promise_1.default.resolve(this.eventInstanceGroupsById);
        }
        else {
            return Promise_1.default.construct(function (onResolve) {
                _this.one('release', onResolve);
            });
        }
    };
    EventPeriod.prototype.freeze = function () {
        if (!(this.freezeDepth++)) {
            this.stuntedReleaseCnt = 0;
        }
    };
    EventPeriod.prototype.thaw = function () {
        if (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {
            this.release();
        }
    };
    return EventPeriod;
}());
exports.default = EventPeriod;
EmitterMixin_1.default.mixInto(EventPeriod);


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ListenerMixin_1 = __webpack_require__(7);
/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/
var MouseFollower = /** @class */ (function () {
    function MouseFollower(sourceEl, options) {
        this.isFollowing = false;
        this.isHidden = false;
        this.isAnimating = false; // doing the revert animation?
        this.options = options = options || {};
        this.sourceEl = sourceEl;
        this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
    }
    // Causes the element to start following the mouse
    MouseFollower.prototype.start = function (ev) {
        if (!this.isFollowing) {
            this.isFollowing = true;
            this.y0 = util_1.getEvY(ev);
            this.x0 = util_1.getEvX(ev);
            this.topDelta = 0;
            this.leftDelta = 0;
            if (!this.isHidden) {
                this.updatePosition();
            }
            if (util_1.getEvIsTouch(ev)) {
                this.listenTo($(document), 'touchmove', this.handleMove);
            }
            else {
                this.listenTo($(document), 'mousemove', this.handleMove);
            }
        }
    };
    // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
    // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
    MouseFollower.prototype.stop = function (shouldRevert, callback) {
        var _this = this;
        var revertDuration = this.options.revertDuration;
        var complete = function () {
            _this.isAnimating = false;
            _this.removeElement();
            _this.top0 = _this.left0 = null; // reset state for future updatePosition calls
            if (callback) {
                callback();
            }
        };
        if (this.isFollowing && !this.isAnimating) {
            this.isFollowing = false;
            this.stopListeningTo($(document));
            if (shouldRevert && revertDuration && !this.isHidden) {
                this.isAnimating = true;
                this.el.animate({
                    top: this.top0,
                    left: this.left0
                }, {
                    duration: revertDuration,
                    complete: complete
                });
            }
            else {
                complete();
            }
        }
    };
    // Gets the tracking element. Create it if necessary
    MouseFollower.prototype.getEl = function () {
        var el = this.el;
        if (!el) {
            el = this.el = this.sourceEl.clone()
                .addClass(this.options.additionalClass || '')
                .css({
                position: 'absolute',
                visibility: '',
                display: this.isHidden ? 'none' : '',
                margin: 0,
                right: 'auto',
                bottom: 'auto',
                width: this.sourceEl.width(),
                height: this.sourceEl.height(),
                opacity: this.options.opacity || '',
                zIndex: this.options.zIndex
            });
            // we don't want long taps or any mouse interaction causing selection/menus.
            // would use preventSelection(), but that prevents selectstart, causing problems.
            el.addClass('fc-unselectable');
            el.appendTo(this.parentEl);
        }
        return el;
    };
    // Removes the tracking element if it has already been created
    MouseFollower.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    // Update the CSS position of the tracking element
    MouseFollower.prototype.updatePosition = function () {
        var sourceOffset;
        var origin;
        this.getEl(); // ensure this.el
        // make sure origin info was computed
        if (this.top0 == null) {
            sourceOffset = this.sourceEl.offset();
            origin = this.el.offsetParent().offset();
            this.top0 = sourceOffset.top - origin.top;
            this.left0 = sourceOffset.left - origin.left;
        }
        this.el.css({
            top: this.top0 + this.topDelta,
            left: this.left0 + this.leftDelta
        });
    };
    // Gets called when the user moves the mouse
    MouseFollower.prototype.handleMove = function (ev) {
        this.topDelta = util_1.getEvY(ev) - this.y0;
        this.leftDelta = util_1.getEvX(ev) - this.x0;
        if (!this.isHidden) {
            this.updatePosition();
        }
    };
    // Temporarily makes the tracking element invisible. Can be called before following starts
    MouseFollower.prototype.hide = function () {
        if (!this.isHidden) {
            this.isHidden = true;
            if (this.el) {
                this.el.hide();
            }
        }
    };
    // Show the tracking element after it has been temporarily hidden
    MouseFollower.prototype.show = function () {
        if (this.isHidden) {
            this.isHidden = false;
            this.updatePosition();
            this.getEl().show();
        }
    };
    return MouseFollower;
}());
exports.default = MouseFollower;
ListenerMixin_1.default.mixInto(MouseFollower);


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var HitDragListener_1 = __webpack_require__(23);
var Interaction_1 = __webpack_require__(15);
var DateClicking = /** @class */ (function (_super) {
    tslib_1.__extends(DateClicking, _super);
    /*
    component must implement:
      - bindDateHandlerToEl
      - getSafeHitFootprint
      - getHitEl
    */
    function DateClicking(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateClicking.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateClicking.prototype.bindToEl = function (el) {
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (!component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev);
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (!component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev);
            }
        });
    };
    // Creates a listener that tracks the user's drag across day elements, for day clicking.
    DateClicking.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var dayClickHit; // null if invalid dayClick
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                dayClickHit = dragListener.origHit;
            },
            hitOver: function (hit, isOrig, origHit) {
                // if user dragged to another cell at any point, it can no longer be a dayClick
                if (!isOrig) {
                    dayClickHit = null;
                }
            },
            hitOut: function () {
                dayClickHit = null;
            },
            interactionEnd: function (ev, isCancelled) {
                var componentFootprint;
                if (!isCancelled && dayClickHit) {
                    componentFootprint = component.getSafeHitFootprint(dayClickHit);
                    if (componentFootprint) {
                        _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);
                    }
                }
            }
        });
        // because dragListener won't be called with any time delay, "dragging" will begin immediately,
        // which will kill any touchmoving/scrolling. Prevent this.
        dragListener.shouldCancelTouchScroll = false;
        dragListener.scrollAlwaysKills = true;
        return dragListener;
    };
    return DateClicking;
}(Interaction_1.default));
exports.default = DateClicking;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var EventRenderer_1 = __webpack_require__(42);
/*
Only handles foreground segs.
Does not own rendering. Use for low-level util methods by TimeGrid.
*/
var TimeGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridEventRenderer, _super);
    function TimeGridEventRenderer(timeGrid, fillRenderer) {
        var _this = _super.call(this, timeGrid, fillRenderer) || this;
        _this.timeGrid = timeGrid;
        return _this;
    }
    TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {
        this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);
    };
    // Given an array of foreground segments, render a DOM element for each, computes position,
    // and attaches to the column inner-container elements.
    TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {
        var segsByCol;
        var col;
        segsByCol = this.timeGrid.groupSegsByCol(segs);
        for (col = 0; col < this.timeGrid.colCnt; col++) {
            this.updateFgSegCoords(segsByCol[col]);
        }
        this.timeGrid.attachSegsByCol(segsByCol, containerEls);
    };
    TimeGridEventRenderer.prototype.unrenderFgSegs = function () {
        if (this.fgSegs) {
            this.fgSegs.forEach(function (seg) {
                seg.el.remove();
            });
        }
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    // Renders the HTML for a single event segment's default rendering
    TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var calendar = view.calendar;
        var componentFootprint = seg.footprint.componentFootprint;
        var isAllDay = componentFootprint.isAllDay;
        var eventDef = seg.footprint.eventDef;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeText;
        var fullTimeText; // more verbose time text. for the print stylesheet
        var startTimeText; // just the start time text
        classes.unshift('fc-time-grid-event', 'fc-v-event');
        // if the event appears to span more than one day...
        if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            // Don't display time text on segments that run entirely through a day.
            // That would appear as midnight-midnight and would look dumb.
            // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
            if (seg.isStart || seg.isEnd) {
                var zonedStart = calendar.msToMoment(seg.startMs);
                var zonedEnd = calendar.msToMoment(seg.endMs);
                timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);
                fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');
                startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeText = this.getTimeText(seg.footprint);
            fullTimeText = this.getTimeText(seg.footprint, 'LT');
            startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false
        }
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (timeText ?
                '<div class="fc-time"' +
                    ' data-start="' + util_1.htmlEscape(startTimeText) + '"' +
                    ' data-full="' + util_1.htmlEscape(fullTimeText) + '"' +
                    '>' +
                    '<span>' + util_1.htmlEscape(timeText) + '</span>' +
                    '</div>' :
                '') +
            (eventDef.title ?
                '<div class="fc-title">' +
                    util_1.htmlEscape(eventDef.title) +
                    '</div>' :
                '') +
            '</div>' +
            '<div class="fc-bg"/>' +
            /* TODO: write CSS for this
            (isResizableFromStart ?
              '<div class="fc-resizer fc-start-resizer" />' :
              ''
              ) +
            */
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer" />' :
                '') +
            '</a>';
    };
    // Given segments that are assumed to all live in the *same column*,
    // compute their verical/horizontal coordinates and assign to their elements.
    TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {
        this.timeGrid.computeSegVerticals(segs); // horizontals relies on this
        this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
        this.timeGrid.assignSegVerticals(segs);
        this.assignFgSegHorizontals(segs);
    };
    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
    // NOTE: Also reorders the given array by date!
    TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {
        var levels;
        var level0;
        var i;
        this.sortEventSegs(segs); // order by certain criteria
        levels = buildSlotSegLevels(segs);
        computeForwardSlotSegs(levels);
        if ((level0 = levels[0])) {
            for (i = 0; i < level0.length; i++) {
                computeSlotSegPressures(level0[i]);
            }
            for (i = 0; i < level0.length; i++) {
                this.computeFgSegForwardBack(level0[i], 0, 0);
            }
        }
    };
    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
    // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
    //
    // The segment might be part of a "series", which means consecutive segments with the same pressure
    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
    // coordinate of the first segment in the series.
    TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
        var forwardSegs = seg.forwardSegs;
        var i;
        if (seg.forwardCoord === undefined) {
            if (!forwardSegs.length) {
                // if there are no forward segments, this segment should butt up against the edge
                seg.forwardCoord = 1;
            }
            else {
                // sort highest pressure first
                this.sortForwardSegs(forwardSegs);
                // this segment's forwardCoord will be calculated from the backwardCoord of the
                // highest-pressure forward segment.
                this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                seg.forwardCoord = forwardSegs[0].backwardCoord;
            }
            // calculate the backwardCoord from the forwardCoord. consider the series
            seg.backwardCoord = seg.forwardCoord -
                (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                    (seriesBackwardPressure + 1); // # of segments in the series
            // use this segment's coordinates to computed the coordinates of the less-pressurized
            // forward segments
            for (i = 0; i < forwardSegs.length; i++) {
                this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
            }
        }
    };
    TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
        forwardSegs.sort(util_1.proxy(this, 'compareForwardSegs'));
    };
    // A cmp function for determining which forward segment to rely on more when computing coordinates.
    TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {
        // put higher-pressure first
        return seg2.forwardPressure - seg1.forwardPressure ||
            // put segments that are closer to initial edge first (and favor ones with no coords yet)
            (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
            // do normal sorting...
            this.compareEventSegs(seg1, seg2);
    };
    // Given foreground event segments that have already had their position coordinates computed,
    // assigns position-related CSS values to their elements.
    TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateFgSegHorizontalCss(seg));
            // if the height is short, add a className for alternate styling
            if (seg.bottom - seg.top < 30) {
                seg.el.addClass('fc-short');
            }
        }
    };
    // Generates an object with CSS properties/values that should be applied to an event segment element.
    // Contains important positioning-related properties that should be applied to any event element, customized or not.
    TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {
        var shouldOverlap = this.opt('slotEventOverlap');
        var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
        var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
        var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first
        var isRTL = this.timeGrid.isRTL;
        var left; // amount of space from left edge, a fraction of the total width
        var right; // amount of space from right edge, a fraction of the total width
        if (shouldOverlap) {
            // double the width, but don't go beyond the maximum forward coordinate (1.0)
            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
        }
        if (isRTL) {
            left = 1 - forwardCoord;
            right = backwardCoord;
        }
        else {
            left = backwardCoord;
            right = 1 - forwardCoord;
        }
        props.zIndex = seg.level + 1; // convert from 0-base to 1-based
        props.left = left * 100 + '%';
        props.right = right * 100 + '%';
        if (shouldOverlap && seg.forwardPressure) {
            // add padding to the edge so that forward stacked events don't cover the resizer's icon
            props[isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
        }
        return props;
    };
    return TimeGridEventRenderer;
}(EventRenderer_1.default));
exports.default = TimeGridEventRenderer;
// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
    var levels = [];
    var i;
    var seg;
    var j;
    for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        // go through all the levels and stop on the first level where there are no collisions
        for (j = 0; j < levels.length; j++) {
            if (!computeSlotSegCollisions(seg, levels[j]).length) {
                break;
            }
        }
        seg.level = j;
        (levels[j] || (levels[j] = [])).push(seg);
    }
    return levels;
}
// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
    var i;
    var level;
    var j;
    var seg;
    var k;
    for (i = 0; i < levels.length; i++) {
        level = levels[i];
        for (j = 0; j < level.length; j++) {
            seg = level[j];
            seg.forwardSegs = [];
            for (k = i + 1; k < levels.length; k++) {
                computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
            }
        }
    }
}
// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
    var forwardSegs = seg.forwardSegs;
    var forwardPressure = 0;
    var i;
    var forwardSeg;
    if (seg.forwardPressure === undefined) {
        for (i = 0; i < forwardSegs.length; i++) {
            forwardSeg = forwardSegs[i];
            // figure out the child's maximum forward path
            computeSlotSegPressures(forwardSeg);
            // either use the existing maximum, or use the child's forward pressure
            // plus one (for the forwardSeg itself)
            forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
        }
        seg.forwardPressure = forwardPressure;
    }
}
// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
    if (results === void 0) { results = []; }
    for (var i = 0; i < otherSegs.length; i++) {
        if (isSlotSegCollision(seg, otherSegs[i])) {
            results.push(otherSegs[i]);
        }
    }
    return results;
}
// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var HelperRenderer_1 = __webpack_require__(58);
var TimeGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridHelperRenderer, _super);
    function TimeGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var i;
        var seg;
        var sourceEl;
        // TODO: not good to call eventRenderer this way
        this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);
        // Try to make the segment that is in the same row as sourceSeg look the same
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (sourceSeg && sourceSeg.col === seg.col) {
                sourceEl = sourceSeg.el;
                seg.el.css({
                    left: sourceEl.css('left'),
                    right: sourceEl.css('right'),
                    'margin-left': sourceEl.css('margin-left'),
                    'margin-right': sourceEl.css('margin-right')
                });
            }
            helperNodes.push(seg.el[0]);
        }
        return $(helperNodes); // must return the elements rendered
    };
    return TimeGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = TimeGridHelperRenderer;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var FillRenderer_1 = __webpack_require__(57);
var TimeGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridFillRenderer, _super);
    function TimeGridFillRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var timeGrid = this.component;
        var containerEls;
        // TODO: more efficient lookup
        if (type === 'bgEvent') {
            containerEls = timeGrid.bgContainerEls;
        }
        else if (type === 'businessHours') {
            containerEls = timeGrid.businessContainerEls;
        }
        else if (type === 'highlight') {
            containerEls = timeGrid.highlightContainerEls;
        }
        timeGrid.updateSegVerticals(segs);
        timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
        return segs.map(function (seg) {
            return seg.el[0];
        });
    };
    return TimeGridFillRenderer;
}(FillRenderer_1.default));
exports.default = TimeGridFillRenderer;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
  - className (string)
  - content (HTML string or jQuery element set)
  - parentEl
  - top
  - left
  - right (the x coord of where the right edge should be. not a "CSS" right)
  - autoHide (boolean)
  - show (callback)
  - hide (callback)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ListenerMixin_1 = __webpack_require__(7);
var Popover = /** @class */ (function () {
    function Popover(options) {
        this.isHidden = true;
        this.margin = 10; // the space required between the popover and the edges of the scroll container
        this.options = options || {};
    }
    // Shows the popover on the specified position. Renders it if not already
    Popover.prototype.show = function () {
        if (this.isHidden) {
            if (!this.el) {
                this.render();
            }
            this.el.show();
            this.position();
            this.isHidden = false;
            this.trigger('show');
        }
    };
    // Hides the popover, through CSS, but does not remove it from the DOM
    Popover.prototype.hide = function () {
        if (!this.isHidden) {
            this.el.hide();
            this.isHidden = true;
            this.trigger('hide');
        }
    };
    // Creates `this.el` and renders content inside of it
    Popover.prototype.render = function () {
        var _this = this;
        var options = this.options;
        this.el = $('<div class="fc-popover"/>')
            .addClass(options.className || '')
            .css({
            // position initially to the top left to avoid creating scrollbars
            top: 0,
            left: 0
        })
            .append(options.content)
            .appendTo(options.parentEl);
        // when a click happens on anything inside with a 'fc-close' className, hide the popover
        this.el.on('click', '.fc-close', function () {
            _this.hide();
        });
        if (options.autoHide) {
            this.listenTo($(document), 'mousedown', this.documentMousedown);
        }
    };
    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
    Popover.prototype.documentMousedown = function (ev) {
        // only hide the popover if the click happened outside the popover
        if (this.el && !$(ev.target).closest(this.el).length) {
            this.hide();
        }
    };
    // Hides and unregisters any handlers
    Popover.prototype.removeElement = function () {
        this.hide();
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
        this.stopListeningTo($(document), 'mousedown');
    };
    // Positions the popover optimally, using the top/left/right options
    Popover.prototype.position = function () {
        var options = this.options;
        var origin = this.el.offsetParent().offset();
        var width = this.el.outerWidth();
        var height = this.el.outerHeight();
        var windowEl = $(window);
        var viewportEl = util_1.getScrollParent(this.el);
        var viewportTop;
        var viewportLeft;
        var viewportOffset;
        var top; // the "position" (not "offset") values for the popover
        var left; //
        // compute top and left
        top = options.top || 0;
        if (options.left !== undefined) {
            left = options.left;
        }
        else if (options.right !== undefined) {
            left = options.right - width; // derive the left value from the right value
        }
        else {
            left = 0;
        }
        if (viewportEl.is(window) || viewportEl.is(document)) {
            viewportEl = windowEl;
            viewportTop = 0; // the window is always at the top left
            viewportLeft = 0; // (and .offset() won't work if called here)
        }
        else {
            viewportOffset = viewportEl.offset();
            viewportTop = viewportOffset.top;
            viewportLeft = viewportOffset.left;
        }
        // if the window is scrolled, it causes the visible area to be further down
        viewportTop += windowEl.scrollTop();
        viewportLeft += windowEl.scrollLeft();
        // constrain to the view port. if constrained by two edges, give precedence to top/left
        if (options.viewportConstrain !== false) {
            top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
            top = Math.max(top, viewportTop + this.margin);
            left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
            left = Math.max(left, viewportLeft + this.margin);
        }
        this.el.css({
            top: top - origin.top,
            left: left - origin.left
        });
    };
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    // TODO: better code reuse for this. Repeat code
    Popover.prototype.trigger = function (name) {
        if (this.options[name]) {
            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
        }
    };
    return Popover;
}());
exports.default = Popover;
ListenerMixin_1.default.mixInto(Popover);


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventRenderer_1 = __webpack_require__(42);
/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/
var DayGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridEventRenderer, _super);
    function DayGridEventRenderer(dayGrid, fillRenderer) {
        var _this = _super.call(this, dayGrid, fillRenderer) || this;
        _this.dayGrid = dayGrid;
        return _this;
    }
    DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {
        // don't render timed background events
        eventRanges = $.grep(eventRanges, function (eventRange) {
            return eventRange.eventDef.isAllDay();
        });
        _super.prototype.renderBgRanges.call(this, eventRanges);
    };
    // Renders the given foreground event segments onto the grid
    DayGridEventRenderer.prototype.renderFgSegs = function (segs) {
        var rowStructs = this.rowStructs = this.renderSegRows(segs);
        // append to each row's content skeleton
        this.dayGrid.rowEls.each(function (i, rowNode) {
            $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);
        });
    };
    // Unrenders all currently rendered foreground event segments
    DayGridEventRenderer.prototype.unrenderFgSegs = function () {
        var rowStructs = this.rowStructs || [];
        var rowStruct;
        while ((rowStruct = rowStructs.pop())) {
            rowStruct.tbodyEl.remove();
        }
        this.rowStructs = null;
    };
    // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`
    DayGridEventRenderer.prototype.renderSegRows = function (segs) {
        var rowStructs = [];
        var segRows;
        var row;
        segRows = this.groupSegRows(segs); // group into nested arrays
        // iterate each row of segment groupings
        for (row = 0; row < segRows.length; row++) {
            rowStructs.push(this.renderSegRow(row, segRows[row]));
        }
        return rowStructs;
    };
    // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
    // the segments. Returns object with a bunch of internal data about how the render was calculated.
    // NOTE: modifies rowSegs
    DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
        var colCnt = this.dayGrid.colCnt;
        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
        var tbody = $('<tbody/>');
        var segMatrix = []; // lookup for which segments are rendered into which level+col cells
        var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
        var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
        var i;
        var levelSegs;
        var col;
        var tr;
        var j;
        var seg;
        var td;
        // populates empty cells from the current column (`col`) to `endCol`
        function emptyCellsUntil(endCol) {
            while (col < endCol) {
                // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                td = (loneCellMatrix[i - 1] || [])[col];
                if (td) {
                    td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);
                }
                else {
                    td = $('<td/>');
                    tr.append(td);
                }
                cellMatrix[i][col] = td;
                loneCellMatrix[i][col] = td;
                col++;
            }
        }
        for (i = 0; i < levelCnt; i++) {
            levelSegs = segLevels[i];
            col = 0;
            tr = $('<tr/>');
            segMatrix.push([]);
            cellMatrix.push([]);
            loneCellMatrix.push([]);
            // levelCnt might be 1 even though there are no actual levels. protect against this.
            // this single empty row is useful for styling.
            if (levelSegs) {
                for (j = 0; j < levelSegs.length; j++) {
                    seg = levelSegs[j];
                    emptyCellsUntil(seg.leftCol);
                    // create a container that occupies or more columns. append the event element.
                    td = $('<td class="fc-event-container"/>').append(seg.el);
                    if (seg.leftCol !== seg.rightCol) {
                        td.attr('colspan', seg.rightCol - seg.leftCol + 1);
                    }
                    else {
                        loneCellMatrix[i][col] = td;
                    }
                    while (col <= seg.rightCol) {
                        cellMatrix[i][col] = td;
                        segMatrix[i][col] = seg;
                        col++;
                    }
                    tr.append(td);
                }
            }
            emptyCellsUntil(colCnt); // finish off the row
            this.dayGrid.bookendCells(tr);
            tbody.append(tr);
        }
        return {
            row: row,
            tbodyEl: tbody,
            cellMatrix: cellMatrix,
            segMatrix: segMatrix,
            segLevels: segLevels,
            segs: rowSegs
        };
    };
    // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
    // NOTE: modifies segs
    DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
        var levels = [];
        var i;
        var seg;
        var j;
        // Give preference to elements with certain criteria, so they have
        // a chance to be closer to the top.
        this.sortEventSegs(segs);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            // loop through levels, starting with the topmost, until the segment doesn't collide with other segments
            for (j = 0; j < levels.length; j++) {
                if (!isDaySegCollision(seg, levels[j])) {
                    break;
                }
            }
            // `j` now holds the desired subrow index
            seg.level = j;
            // create new level array if needed and append segment
            (levels[j] || (levels[j] = [])).push(seg);
        }
        // order segments left-to-right. very important if calendar is RTL
        for (j = 0; j < levels.length; j++) {
            levels[j].sort(compareDaySegCols);
        }
        return levels;
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
    DayGridEventRenderer.prototype.groupSegRows = function (segs) {
        var segRows = [];
        var i;
        for (i = 0; i < this.dayGrid.rowCnt; i++) {
            segRows.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segRows[segs[i].row].push(segs[i]);
        }
        return segRows;
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    DayGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day
    };
    // Builds the HTML to be used for the default element for an individual segment
    DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var isAllDay = seg.footprint.componentFootprint.isAllDay;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && isAllDay &&
            seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && isAllDay &&
            seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeHtml = '';
        var timeText;
        var titleHtml;
        classes.unshift('fc-day-grid-event', 'fc-h-event');
        // Only display a timed events time if it is the starting segment
        if (seg.isStart) {
            timeText = this.getTimeText(seg.footprint);
            if (timeText) {
                timeHtml = '<span class="fc-time">' + util_1.htmlEscape(timeText) + '</span>';
            }
        }
        titleHtml =
            '<span class="fc-title">' +
                (util_1.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height
                '</span>';
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (this.dayGrid.isRTL ?
                titleHtml + ' ' + timeHtml : // put a natural space in between
                timeHtml + ' ' + titleHtml //
            ) +
            '</div>' +
            (isResizableFromStart ?
                '<div class="fc-resizer fc-start-resizer" />' :
                '') +
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer" />' :
                '') +
            '</a>';
    };
    return DayGridEventRenderer;
}(EventRenderer_1.default));
exports.default = DayGridEventRenderer;
// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
    var i;
    var otherSeg;
    for (i = 0; i < otherSegs.length; i++) {
        otherSeg = otherSegs[i];
        if (otherSeg.leftCol <= seg.rightCol &&
            otherSeg.rightCol >= seg.leftCol) {
            return true;
        }
    }
    return false;
}
// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
    return a.leftCol - b.leftCol;
}


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var HelperRenderer_1 = __webpack_require__(58);
var DayGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridHelperRenderer, _super);
    function DayGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
    DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var rowStructs;
        // TODO: not good to call eventRenderer this way
        rowStructs = this.eventRenderer.renderSegRows(segs);
        // inject each new event skeleton into each associated row
        this.component.rowEls.each(function (row, rowNode) {
            var rowEl = $(rowNode); // the .fc-row
            var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
            var skeletonTopEl;
            var skeletonTop;
            // If there is an original segment, match the top position. Otherwise, put it at the row's top level
            if (sourceSeg && sourceSeg.row === row) {
                skeletonTop = sourceSeg.el.position().top;
            }
            else {
                skeletonTopEl = rowEl.find('.fc-content-skeleton tbody');
                if (!skeletonTopEl.length) {
                    skeletonTopEl = rowEl.find('.fc-content-skeleton table');
                }
                skeletonTop = skeletonTopEl.position().top;
            }
            skeletonEl.css('top', skeletonTop)
                .find('table')
                .append(rowStructs[row].tbodyEl);
            rowEl.append(skeletonEl);
            helperNodes.push(skeletonEl[0]);
        });
        return $(helperNodes); // must return the elements rendered
    };
    return DayGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = DayGridHelperRenderer;


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var FillRenderer_1 = __webpack_require__(57);
var DayGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridFillRenderer, _super);
    function DayGridFillRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fillSegTag = 'td'; // override the default tag name
        return _this;
    }
    DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var nodes = [];
        var i;
        var seg;
        var skeletonEl;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            skeletonEl = this.renderFillRow(type, seg);
            this.component.rowEls.eq(seg.row).append(skeletonEl);
            nodes.push(skeletonEl[0]);
        }
        return nodes;
    };
    // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
    DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
        var colCnt = this.component.colCnt;
        var startCol = seg.leftCol;
        var endCol = seg.rightCol + 1;
        var className;
        var skeletonEl;
        var trEl;
        if (type === 'businessHours') {
            className = 'bgevent';
        }
        else {
            className = type.toLowerCase();
        }
        skeletonEl = $('<div class="fc-' + className + '-skeleton">' +
            '<table><tr/></table>' +
            '</div>');
        trEl = skeletonEl.find('tr');
        if (startCol > 0) {
            trEl.append('<td colspan="' + startCol + '"/>');
        }
        trEl.append(seg.el.attr('colspan', endCol - startCol));
        if (endCol < colCnt) {
            trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
        }
        this.component.bookendCells(trEl);
        return skeletonEl;
    };
    return DayGridFillRenderer;
}(FillRenderer_1.default));
exports.default = DayGridFillRenderer;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var BasicViewDateProfileGenerator_1 = __webpack_require__(228);
var UnzonedRange_1 = __webpack_require__(5);
var MonthViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(MonthViewDateProfileGenerator, _super);
    function MonthViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        var rowCnt;
        // ensure 6 weeks
        if (this.opt('fixedWeekCount')) {
            rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
            end.diff(start, 'weeks', true) // dontRound=true
            );
            end.add(6 - rowCnt, 'weeks');
        }
        return new UnzonedRange_1.default(start, end);
    };
    return MonthViewDateProfileGenerator;
}(BasicViewDateProfileGenerator_1.default));
exports.default = MonthViewDateProfileGenerator;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var EventRenderer_1 = __webpack_require__(42);
var ListEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventRenderer, _super);
    function ListEventRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListEventRenderer.prototype.renderFgSegs = function (segs) {
        if (!segs.length) {
            this.component.renderEmptyMessage();
        }
        else {
            this.component.renderSegList(segs);
        }
    };
    // generates the HTML for a single event row
    ListEventRenderer.prototype.fgSegHtml = function (seg) {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var eventFootprint = seg.footprint;
        var eventDef = eventFootprint.eventDef;
        var componentFootprint = eventFootprint.componentFootprint;
        var url = eventDef.url;
        var classes = ['fc-list-item'].concat(this.getClasses(eventDef));
        var bgColor = this.getBgColor(eventDef);
        var timeHtml;
        if (componentFootprint.isAllDay) {
            timeHtml = view.getAllDayHtml();
        }
        else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            if (seg.isStart || seg.isEnd) {
                timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));
            }
            else {
                timeHtml = view.getAllDayHtml();
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));
        }
        if (url) {
            classes.push('fc-has-url');
        }
        return '<tr class="' + classes.join(' ') + '">' +
            (this.displayEventTime ?
                '<td class="fc-list-item-time ' + theme.getClass('widgetContent') + '">' +
                    (timeHtml || '') +
                    '</td>' :
                '') +
            '<td class="fc-list-item-marker ' + theme.getClass('widgetContent') + '">' +
            '<span class="fc-event-dot"' +
            (bgColor ?
                ' style="background-color:' + bgColor + '"' :
                '') +
            '></span>' +
            '</td>' +
            '<td class="fc-list-item-title ' + theme.getClass('widgetContent') + '">' +
            '<a' + (url ? ' href="' + util_1.htmlEscape(url) + '"' : '') + '>' +
            util_1.htmlEscape(eventDef.title || '') +
            '</a>' +
            '</td>' +
            '</tr>';
    };
    // like "4:00am"
    ListEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('mediumTimeFormat');
    };
    return ListEventRenderer;
}(EventRenderer_1.default));
exports.default = ListEventRenderer;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var EventPointing_1 = __webpack_require__(59);
var ListEventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventPointing, _super);
    function ListEventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // for events with a url, the whole <tr> should be clickable,
    // but it's impossible to wrap with an <a> tag. simulate this.
    ListEventPointing.prototype.handleClick = function (seg, ev) {
        var url;
        _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action
        // not clicking on or within an <a> with an href
        if (!$(ev.target).closest('a[href]').length) {
            url = seg.footprint.eventDef.url;
            if (url && !ev.isDefaultPrevented()) {
                window.location.href = url; // simulate link click
            }
        }
    };
    return ListEventPointing;
}(EventPointing_1.default));
exports.default = ListEventPointing;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventSourceParser_1 = __webpack_require__(38);
var ArrayEventSource_1 = __webpack_require__(52);
var FuncEventSource_1 = __webpack_require__(215);
var JsonFeedEventSource_1 = __webpack_require__(216);
EventSourceParser_1.default.registerClass(ArrayEventSource_1.default);
EventSourceParser_1.default.registerClass(FuncEventSource_1.default);
EventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ThemeRegistry_1 = __webpack_require__(51);
var StandardTheme_1 = __webpack_require__(213);
var JqueryUiTheme_1 = __webpack_require__(214);
var Bootstrap3Theme_1 = __webpack_require__(258);
var Bootstrap4Theme_1 = __webpack_require__(259);
ThemeRegistry_1.defineThemeSystem('standard', StandardTheme_1.default);
ThemeRegistry_1.defineThemeSystem('jquery-ui', JqueryUiTheme_1.default);
ThemeRegistry_1.defineThemeSystem('bootstrap3', Bootstrap3Theme_1.default);
ThemeRegistry_1.defineThemeSystem('bootstrap4', Bootstrap4Theme_1.default);


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(19);
var Bootstrap3Theme = /** @class */ (function (_super) {
    tslib_1.__extends(Bootstrap3Theme, _super);
    function Bootstrap3Theme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Bootstrap3Theme;
}(Theme_1.default));
exports.default = Bootstrap3Theme;
Bootstrap3Theme.prototype.classes = {
    widget: 'fc-bootstrap3',
    tableGrid: 'table-bordered',
    tableList: 'table',
    tableListHeading: 'active',
    buttonGroup: 'btn-group',
    button: 'btn btn-default',
    stateActive: 'active',
    stateDisabled: 'disabled',
    today: 'alert alert-info',
    popover: 'panel panel-default',
    popoverHeader: 'panel-heading',
    popoverContent: 'panel-body',
    // day grid
    // for left/right border color when border is inset from edges (all-day in agenda view)
    // avoid `panel` class b/c don't want margins/radius. only border color.
    headerRow: 'panel-default',
    dayRow: 'panel-default',
    // list view
    listView: 'panel panel-default'
};
Bootstrap3Theme.prototype.baseIconClass = 'glyphicon';
Bootstrap3Theme.prototype.iconClasses = {
    close: 'glyphicon-remove',
    prev: 'glyphicon-chevron-left',
    next: 'glyphicon-chevron-right',
    prevYear: 'glyphicon-backward',
    nextYear: 'glyphicon-forward'
};
Bootstrap3Theme.prototype.iconOverrideOption = 'bootstrapGlyphicons';
Bootstrap3Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapGlyphicon';
Bootstrap3Theme.prototype.iconOverridePrefix = 'glyphicon-';


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(19);
var Bootstrap4Theme = /** @class */ (function (_super) {
    tslib_1.__extends(Bootstrap4Theme, _super);
    function Bootstrap4Theme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Bootstrap4Theme;
}(Theme_1.default));
exports.default = Bootstrap4Theme;
Bootstrap4Theme.prototype.classes = {
    widget: 'fc-bootstrap4',
    tableGrid: 'table-bordered',
    tableList: 'table',
    tableListHeading: 'table-active',
    buttonGroup: 'btn-group',
    button: 'btn btn-primary',
    stateActive: 'active',
    stateDisabled: 'disabled',
    today: 'alert alert-info',
    popover: 'card card-primary',
    popoverHeader: 'card-header',
    popoverContent: 'card-body',
    // day grid
    // for left/right border color when border is inset from edges (all-day in agenda view)
    // avoid `table` class b/c don't want margins/padding/structure. only border color.
    headerRow: 'table-bordered',
    dayRow: 'table-bordered',
    // list view
    listView: 'card card-primary'
};
Bootstrap4Theme.prototype.baseIconClass = 'fa';
Bootstrap4Theme.prototype.iconClasses = {
    close: 'fa-times',
    prev: 'fa-chevron-left',
    next: 'fa-chevron-right',
    prevYear: 'fa-angle-double-left',
    nextYear: 'fa-angle-double-right'
};
Bootstrap4Theme.prototype.iconOverrideOption = 'bootstrapFontAwesome';
Bootstrap4Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';
Bootstrap4Theme.prototype.iconOverridePrefix = 'fa-';


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ViewRegistry_1 = __webpack_require__(22);
var BasicView_1 = __webpack_require__(62);
var MonthView_1 = __webpack_require__(229);
ViewRegistry_1.defineView('basic', {
    'class': BasicView_1.default
});
ViewRegistry_1.defineView('basicDay', {
    type: 'basic',
    duration: { days: 1 }
});
ViewRegistry_1.defineView('basicWeek', {
    type: 'basic',
    duration: { weeks: 1 }
});
ViewRegistry_1.defineView('month', {
    'class': MonthView_1.default,
    duration: { months: 1 },
    defaults: {
        fixedWeekCount: true
    }
});


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ViewRegistry_1 = __webpack_require__(22);
var AgendaView_1 = __webpack_require__(226);
ViewRegistry_1.defineView('agenda', {
    'class': AgendaView_1.default,
    defaults: {
        allDaySlot: true,
        slotDuration: '00:30:00',
        slotEventOverlap: true // a bad name. confused with overlap/constraint system
    }
});
ViewRegistry_1.defineView('agendaDay', {
    type: 'agenda',
    duration: { days: 1 }
});
ViewRegistry_1.defineView('agendaWeek', {
    type: 'agenda',
    duration: { weeks: 1 }
});


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ViewRegistry_1 = __webpack_require__(22);
var ListView_1 = __webpack_require__(230);
ViewRegistry_1.defineView('list', {
    'class': ListView_1.default,
    buttonTextKey: 'list',
    defaults: {
        buttonText: 'list',
        listDayFormat: 'LL',
        noEventsMessage: 'No events to display'
    }
});
ViewRegistry_1.defineView('listDay', {
    type: 'list',
    duration: { days: 1 },
    defaults: {
        listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
    }
});
ViewRegistry_1.defineView('listWeek', {
    type: 'list',
    duration: { weeks: 1 },
    defaults: {
        listDayFormat: 'dddd',
        listDayAltFormat: 'LL'
    }
});
ViewRegistry_1.defineView('listMonth', {
    type: 'list',
    duration: { month: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
});
ViewRegistry_1.defineView('listYear', {
    type: 'list',
    duration: { year: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
});


/***/ }),
/* 263 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });


/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/moment/locale sync recursive ^\\.\\/.*$":
/*!**************************************************!*\
  !*** ./node_modules/moment/locale sync ^\.\/.*$ ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": "./node_modules/moment/locale/af.js",
	"./af.js": "./node_modules/moment/locale/af.js",
	"./ar": "./node_modules/moment/locale/ar.js",
	"./ar-dz": "./node_modules/moment/locale/ar-dz.js",
	"./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
	"./ar-kw": "./node_modules/moment/locale/ar-kw.js",
	"./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
	"./ar-ly": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ma": "./node_modules/moment/locale/ar-ma.js",
	"./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
	"./ar-sa": "./node_modules/moment/locale/ar-sa.js",
	"./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
	"./ar-tn": "./node_modules/moment/locale/ar-tn.js",
	"./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
	"./ar.js": "./node_modules/moment/locale/ar.js",
	"./az": "./node_modules/moment/locale/az.js",
	"./az.js": "./node_modules/moment/locale/az.js",
	"./be": "./node_modules/moment/locale/be.js",
	"./be.js": "./node_modules/moment/locale/be.js",
	"./bg": "./node_modules/moment/locale/bg.js",
	"./bg.js": "./node_modules/moment/locale/bg.js",
	"./bm": "./node_modules/moment/locale/bm.js",
	"./bm.js": "./node_modules/moment/locale/bm.js",
	"./bn": "./node_modules/moment/locale/bn.js",
	"./bn.js": "./node_modules/moment/locale/bn.js",
	"./bo": "./node_modules/moment/locale/bo.js",
	"./bo.js": "./node_modules/moment/locale/bo.js",
	"./br": "./node_modules/moment/locale/br.js",
	"./br.js": "./node_modules/moment/locale/br.js",
	"./bs": "./node_modules/moment/locale/bs.js",
	"./bs.js": "./node_modules/moment/locale/bs.js",
	"./ca": "./node_modules/moment/locale/ca.js",
	"./ca.js": "./node_modules/moment/locale/ca.js",
	"./cs": "./node_modules/moment/locale/cs.js",
	"./cs.js": "./node_modules/moment/locale/cs.js",
	"./cv": "./node_modules/moment/locale/cv.js",
	"./cv.js": "./node_modules/moment/locale/cv.js",
	"./cy": "./node_modules/moment/locale/cy.js",
	"./cy.js": "./node_modules/moment/locale/cy.js",
	"./da": "./node_modules/moment/locale/da.js",
	"./da.js": "./node_modules/moment/locale/da.js",
	"./de": "./node_modules/moment/locale/de.js",
	"./de-at": "./node_modules/moment/locale/de-at.js",
	"./de-at.js": "./node_modules/moment/locale/de-at.js",
	"./de-ch": "./node_modules/moment/locale/de-ch.js",
	"./de-ch.js": "./node_modules/moment/locale/de-ch.js",
	"./de.js": "./node_modules/moment/locale/de.js",
	"./dv": "./node_modules/moment/locale/dv.js",
	"./dv.js": "./node_modules/moment/locale/dv.js",
	"./el": "./node_modules/moment/locale/el.js",
	"./el.js": "./node_modules/moment/locale/el.js",
	"./en-au": "./node_modules/moment/locale/en-au.js",
	"./en-au.js": "./node_modules/moment/locale/en-au.js",
	"./en-ca": "./node_modules/moment/locale/en-ca.js",
	"./en-ca.js": "./node_modules/moment/locale/en-ca.js",
	"./en-gb": "./node_modules/moment/locale/en-gb.js",
	"./en-gb.js": "./node_modules/moment/locale/en-gb.js",
	"./en-ie": "./node_modules/moment/locale/en-ie.js",
	"./en-ie.js": "./node_modules/moment/locale/en-ie.js",
	"./en-il": "./node_modules/moment/locale/en-il.js",
	"./en-il.js": "./node_modules/moment/locale/en-il.js",
	"./en-nz": "./node_modules/moment/locale/en-nz.js",
	"./en-nz.js": "./node_modules/moment/locale/en-nz.js",
	"./eo": "./node_modules/moment/locale/eo.js",
	"./eo.js": "./node_modules/moment/locale/eo.js",
	"./es": "./node_modules/moment/locale/es.js",
	"./es-do": "./node_modules/moment/locale/es-do.js",
	"./es-do.js": "./node_modules/moment/locale/es-do.js",
	"./es-us": "./node_modules/moment/locale/es-us.js",
	"./es-us.js": "./node_modules/moment/locale/es-us.js",
	"./es.js": "./node_modules/moment/locale/es.js",
	"./et": "./node_modules/moment/locale/et.js",
	"./et.js": "./node_modules/moment/locale/et.js",
	"./eu": "./node_modules/moment/locale/eu.js",
	"./eu.js": "./node_modules/moment/locale/eu.js",
	"./fa": "./node_modules/moment/locale/fa.js",
	"./fa.js": "./node_modules/moment/locale/fa.js",
	"./fi": "./node_modules/moment/locale/fi.js",
	"./fi.js": "./node_modules/moment/locale/fi.js",
	"./fo": "./node_modules/moment/locale/fo.js",
	"./fo.js": "./node_modules/moment/locale/fo.js",
	"./fr": "./node_modules/moment/locale/fr.js",
	"./fr-ca": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ch": "./node_modules/moment/locale/fr-ch.js",
	"./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
	"./fr.js": "./node_modules/moment/locale/fr.js",
	"./fy": "./node_modules/moment/locale/fy.js",
	"./fy.js": "./node_modules/moment/locale/fy.js",
	"./gd": "./node_modules/moment/locale/gd.js",
	"./gd.js": "./node_modules/moment/locale/gd.js",
	"./gl": "./node_modules/moment/locale/gl.js",
	"./gl.js": "./node_modules/moment/locale/gl.js",
	"./gom-latn": "./node_modules/moment/locale/gom-latn.js",
	"./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
	"./gu": "./node_modules/moment/locale/gu.js",
	"./gu.js": "./node_modules/moment/locale/gu.js",
	"./he": "./node_modules/moment/locale/he.js",
	"./he.js": "./node_modules/moment/locale/he.js",
	"./hi": "./node_modules/moment/locale/hi.js",
	"./hi.js": "./node_modules/moment/locale/hi.js",
	"./hr": "./node_modules/moment/locale/hr.js",
	"./hr.js": "./node_modules/moment/locale/hr.js",
	"./hu": "./node_modules/moment/locale/hu.js",
	"./hu.js": "./node_modules/moment/locale/hu.js",
	"./hy-am": "./node_modules/moment/locale/hy-am.js",
	"./hy-am.js": "./node_modules/moment/locale/hy-am.js",
	"./id": "./node_modules/moment/locale/id.js",
	"./id.js": "./node_modules/moment/locale/id.js",
	"./is": "./node_modules/moment/locale/is.js",
	"./is.js": "./node_modules/moment/locale/is.js",
	"./it": "./node_modules/moment/locale/it.js",
	"./it.js": "./node_modules/moment/locale/it.js",
	"./ja": "./node_modules/moment/locale/ja.js",
	"./ja.js": "./node_modules/moment/locale/ja.js",
	"./jv": "./node_modules/moment/locale/jv.js",
	"./jv.js": "./node_modules/moment/locale/jv.js",
	"./ka": "./node_modules/moment/locale/ka.js",
	"./ka.js": "./node_modules/moment/locale/ka.js",
	"./kk": "./node_modules/moment/locale/kk.js",
	"./kk.js": "./node_modules/moment/locale/kk.js",
	"./km": "./node_modules/moment/locale/km.js",
	"./km.js": "./node_modules/moment/locale/km.js",
	"./kn": "./node_modules/moment/locale/kn.js",
	"./kn.js": "./node_modules/moment/locale/kn.js",
	"./ko": "./node_modules/moment/locale/ko.js",
	"./ko.js": "./node_modules/moment/locale/ko.js",
	"./ku": "./node_modules/moment/locale/ku.js",
	"./ku.js": "./node_modules/moment/locale/ku.js",
	"./ky": "./node_modules/moment/locale/ky.js",
	"./ky.js": "./node_modules/moment/locale/ky.js",
	"./lb": "./node_modules/moment/locale/lb.js",
	"./lb.js": "./node_modules/moment/locale/lb.js",
	"./lo": "./node_modules/moment/locale/lo.js",
	"./lo.js": "./node_modules/moment/locale/lo.js",
	"./lt": "./node_modules/moment/locale/lt.js",
	"./lt.js": "./node_modules/moment/locale/lt.js",
	"./lv": "./node_modules/moment/locale/lv.js",
	"./lv.js": "./node_modules/moment/locale/lv.js",
	"./me": "./node_modules/moment/locale/me.js",
	"./me.js": "./node_modules/moment/locale/me.js",
	"./mi": "./node_modules/moment/locale/mi.js",
	"./mi.js": "./node_modules/moment/locale/mi.js",
	"./mk": "./node_modules/moment/locale/mk.js",
	"./mk.js": "./node_modules/moment/locale/mk.js",
	"./ml": "./node_modules/moment/locale/ml.js",
	"./ml.js": "./node_modules/moment/locale/ml.js",
	"./mn": "./node_modules/moment/locale/mn.js",
	"./mn.js": "./node_modules/moment/locale/mn.js",
	"./mr": "./node_modules/moment/locale/mr.js",
	"./mr.js": "./node_modules/moment/locale/mr.js",
	"./ms": "./node_modules/moment/locale/ms.js",
	"./ms-my": "./node_modules/moment/locale/ms-my.js",
	"./ms-my.js": "./node_modules/moment/locale/ms-my.js",
	"./ms.js": "./node_modules/moment/locale/ms.js",
	"./mt": "./node_modules/moment/locale/mt.js",
	"./mt.js": "./node_modules/moment/locale/mt.js",
	"./my": "./node_modules/moment/locale/my.js",
	"./my.js": "./node_modules/moment/locale/my.js",
	"./nb": "./node_modules/moment/locale/nb.js",
	"./nb.js": "./node_modules/moment/locale/nb.js",
	"./ne": "./node_modules/moment/locale/ne.js",
	"./ne.js": "./node_modules/moment/locale/ne.js",
	"./nl": "./node_modules/moment/locale/nl.js",
	"./nl-be": "./node_modules/moment/locale/nl-be.js",
	"./nl-be.js": "./node_modules/moment/locale/nl-be.js",
	"./nl.js": "./node_modules/moment/locale/nl.js",
	"./nn": "./node_modules/moment/locale/nn.js",
	"./nn.js": "./node_modules/moment/locale/nn.js",
	"./pa-in": "./node_modules/moment/locale/pa-in.js",
	"./pa-in.js": "./node_modules/moment/locale/pa-in.js",
	"./pl": "./node_modules/moment/locale/pl.js",
	"./pl.js": "./node_modules/moment/locale/pl.js",
	"./pt": "./node_modules/moment/locale/pt.js",
	"./pt-br": "./node_modules/moment/locale/pt-br.js",
	"./pt-br.js": "./node_modules/moment/locale/pt-br.js",
	"./pt.js": "./node_modules/moment/locale/pt.js",
	"./ro": "./node_modules/moment/locale/ro.js",
	"./ro.js": "./node_modules/moment/locale/ro.js",
	"./ru": "./node_modules/moment/locale/ru.js",
	"./ru.js": "./node_modules/moment/locale/ru.js",
	"./sd": "./node_modules/moment/locale/sd.js",
	"./sd.js": "./node_modules/moment/locale/sd.js",
	"./se": "./node_modules/moment/locale/se.js",
	"./se.js": "./node_modules/moment/locale/se.js",
	"./si": "./node_modules/moment/locale/si.js",
	"./si.js": "./node_modules/moment/locale/si.js",
	"./sk": "./node_modules/moment/locale/sk.js",
	"./sk.js": "./node_modules/moment/locale/sk.js",
	"./sl": "./node_modules/moment/locale/sl.js",
	"./sl.js": "./node_modules/moment/locale/sl.js",
	"./sq": "./node_modules/moment/locale/sq.js",
	"./sq.js": "./node_modules/moment/locale/sq.js",
	"./sr": "./node_modules/moment/locale/sr.js",
	"./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr.js": "./node_modules/moment/locale/sr.js",
	"./ss": "./node_modules/moment/locale/ss.js",
	"./ss.js": "./node_modules/moment/locale/ss.js",
	"./sv": "./node_modules/moment/locale/sv.js",
	"./sv.js": "./node_modules/moment/locale/sv.js",
	"./sw": "./node_modules/moment/locale/sw.js",
	"./sw.js": "./node_modules/moment/locale/sw.js",
	"./ta": "./node_modules/moment/locale/ta.js",
	"./ta.js": "./node_modules/moment/locale/ta.js",
	"./te": "./node_modules/moment/locale/te.js",
	"./te.js": "./node_modules/moment/locale/te.js",
	"./tet": "./node_modules/moment/locale/tet.js",
	"./tet.js": "./node_modules/moment/locale/tet.js",
	"./tg": "./node_modules/moment/locale/tg.js",
	"./tg.js": "./node_modules/moment/locale/tg.js",
	"./th": "./node_modules/moment/locale/th.js",
	"./th.js": "./node_modules/moment/locale/th.js",
	"./tl-ph": "./node_modules/moment/locale/tl-ph.js",
	"./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
	"./tlh": "./node_modules/moment/locale/tlh.js",
	"./tlh.js": "./node_modules/moment/locale/tlh.js",
	"./tr": "./node_modules/moment/locale/tr.js",
	"./tr.js": "./node_modules/moment/locale/tr.js",
	"./tzl": "./node_modules/moment/locale/tzl.js",
	"./tzl.js": "./node_modules/moment/locale/tzl.js",
	"./tzm": "./node_modules/moment/locale/tzm.js",
	"./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm.js": "./node_modules/moment/locale/tzm.js",
	"./ug-cn": "./node_modules/moment/locale/ug-cn.js",
	"./ug-cn.js": "./node_modules/moment/locale/ug-cn.js",
	"./uk": "./node_modules/moment/locale/uk.js",
	"./uk.js": "./node_modules/moment/locale/uk.js",
	"./ur": "./node_modules/moment/locale/ur.js",
	"./ur.js": "./node_modules/moment/locale/ur.js",
	"./uz": "./node_modules/moment/locale/uz.js",
	"./uz-latn": "./node_modules/moment/locale/uz-latn.js",
	"./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
	"./uz.js": "./node_modules/moment/locale/uz.js",
	"./vi": "./node_modules/moment/locale/vi.js",
	"./vi.js": "./node_modules/moment/locale/vi.js",
	"./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
	"./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
	"./yo": "./node_modules/moment/locale/yo.js",
	"./yo.js": "./node_modules/moment/locale/yo.js",
	"./zh-cn": "./node_modules/moment/locale/zh-cn.js",
	"./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
	"./zh-hk": "./node_modules/moment/locale/zh-hk.js",
	"./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
	"./zh-tw": "./node_modules/moment/locale/zh-tw.js",
	"./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/moment/locale sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./vendor/cl/course/js/Calendar/Calendar.js":
/*!**************************************************!*\
  !*** ./vendor/cl/course/js/Calendar/Calendar.js ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var fullcalendar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js");
/* harmony import */ var fullcalendar__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fullcalendar__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _calendar_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_calendar.scss */ "./vendor/cl/course/js/Calendar/_calendar.scss");
/* harmony import */ var _calendar_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_calendar_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);



/**
 * A calendar with course events in it.
 *
 * Replaces div.cl-calendar
 *
 * The div contains JSON for the events as an array of objects like this:
 * {title: 'Step 1', start: '2018-05-17', url: '/step1'},
 * @constructor
*/

var Calendar = function Calendar() {
  var sel = 'div.cl-calendar';
  Site.Site.ready(function () {
    var calendars = document.querySelectorAll(sel);

    for (var i = 0; i < calendars.length; i++) {
      var calendar = calendars[i];
      var events = JSON.parse(calendar.textContent);
      calendar.textContent = '';
      jquery__WEBPACK_IMPORTED_MODULE_2___default()(calendar).fullCalendar({
        header: {
          left: '',
          center: 'title',
          right: 'prev,next today'
        },
        eventLimit: true,
        // allow "more" link when too many events
        events: events
      });
      calendar.style.display = 'block';
      jquery__WEBPACK_IMPORTED_MODULE_2___default()(calendar).fullCalendar('render');
    }
  });
};

new Calendar();

/***/ }),

/***/ "./vendor/cl/course/js/Calendar/_calendar.scss":
/*!*****************************************************!*\
  !*** ./vendor/cl/course/js/Calendar/_calendar.scss ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../../node_modules/css-loader!../../../../../node_modules/resolve-url-loader!../../../../../node_modules/sass-loader/lib/loader.js?sourceMap!./_calendar.scss */ "./node_modules/css-loader/index.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/lib/loader.js?sourceMap!./vendor/cl/course/js/Calendar/_calendar.scss");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("4a8f959a", content, false, {});
// Hot Module Replacement
if(true) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept(/*! !../../../../../node_modules/css-loader!../../../../../node_modules/resolve-url-loader!../../../../../node_modules/sass-loader/lib/loader.js?sourceMap!./_calendar.scss */ "./node_modules/css-loader/index.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/lib/loader.js?sourceMap!./vendor/cl/course/js/Calendar/_calendar.scss", function() {
     var newContent = __webpack_require__(/*! !../../../../../node_modules/css-loader!../../../../../node_modules/resolve-url-loader!../../../../../node_modules/sass-loader/lib/loader.js?sourceMap!./_calendar.scss */ "./node_modules/css-loader/index.js!./node_modules/resolve-url-loader/index.js!./node_modules/sass-loader/lib/loader.js?sourceMap!./vendor/cl/course/js/Calendar/_calendar.scss");
     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ })

},[["./vendor/cl/course/js/Calendar/Calendar.js","runtime","vendor"]]]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9mdWxsY2FsZW5kYXIuY3NzIiwid2VicGFjazovL1tuYW1lXS8uL3ZlbmRvci9jbC9jb3Vyc2UvanMvQ2FsZW5kYXIvX2NhbGVuZGFyLnNjc3MiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2Z1bGxjYWxlbmRhci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZSBzeW5jIF5cXC5cXC8uKiQiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vdmVuZG9yL2NsL2NvdXJzZS9qcy9DYWxlbmRhci9DYWxlbmRhci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi92ZW5kb3IvY2wvY291cnNlL2pzL0NhbGVuZGFyL19jYWxlbmRhci5zY3NzPzkxYTIiXSwibmFtZXMiOlsiQ2FsZW5kYXIiLCJzZWwiLCJTaXRlIiwicmVhZHkiLCJjYWxlbmRhcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwibGVuZ3RoIiwiY2FsZW5kYXIiLCJldmVudHMiLCJKU09OIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsIiQiLCJmdWxsQ2FsZW5kYXIiLCJoZWFkZXIiLCJsZWZ0IiwiY2VudGVyIiwicmlnaHQiLCJldmVudExpbWl0Iiwic3R5bGUiLCJkaXNwbGF5Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7O0FDVkEsMkJBQTJCLG1CQUFPLENBQUMsbUZBQWtDO0FBQ3JFOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyw4R0FBOEcsbUJBQW1CLHFCQUFxQixFQUFFLGFBQWEsc0JBQXNCLEVBQUUsY0FBYyw4REFBOEQs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsOENBQThDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDLG1DQUFtQyxFQUFFO0FBQ3JD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OztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGdEQUFnRDtBQUNoRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEMscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsOERBQThEO0FBQzlELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx3REFBd0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrREFBa0Q7OztBQUdsRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsa0RBQWtEO0FBQ2xE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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkU7Ozs7Ozs7Ozs7OztBQzlRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7O0FBU0EsSUFBTUEsUUFBUSxHQUFHLFNBQVhBLFFBQVcsR0FBWTtBQUN6QixNQUFJQyxHQUFHLEdBQUcsaUJBQVY7QUFDQUMsTUFBSSxDQUFDQSxJQUFMLENBQVVDLEtBQVYsQ0FBZ0IsWUFBTTtBQUNsQixRQUFJQyxTQUFTLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEJMLEdBQTFCLENBQWhCOztBQUNBLFNBQUksSUFBSU0sQ0FBQyxHQUFDLENBQVYsRUFBYUEsQ0FBQyxHQUFDSCxTQUFTLENBQUNJLE1BQXpCLEVBQWlDRCxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDLFVBQUlFLFFBQVEsR0FBR0wsU0FBUyxDQUFDRyxDQUFELENBQXhCO0FBRUEsVUFBSUcsTUFBTSxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0gsUUFBUSxDQUFDSSxXQUFwQixDQUFiO0FBQ0FKLGNBQVEsQ0FBQ0ksV0FBVCxHQUF1QixFQUF2QjtBQUVBQyxtREFBQyxDQUFDTCxRQUFELENBQUQsQ0FBWU0sWUFBWixDQUF5QjtBQUNyQkMsY0FBTSxFQUFFO0FBQ0pDLGNBQUksRUFBRSxFQURGO0FBRUpDLGdCQUFNLEVBQUUsT0FGSjtBQUdKQyxlQUFLLEVBQUU7QUFISCxTQURhO0FBTXJCQyxrQkFBVSxFQUFFLElBTlM7QUFNSDtBQUNsQlYsY0FBTSxFQUFFQTtBQVBhLE9BQXpCO0FBVUFELGNBQVEsQ0FBQ1ksS0FBVCxDQUFlQyxPQUFmLEdBQXlCLE9BQXpCO0FBQ0FSLG1EQUFDLENBQUNMLFFBQUQsQ0FBRCxDQUFZTSxZQUFaLENBQXlCLFFBQXpCO0FBQ0g7QUFDSixHQXJCRDtBQXNCSCxDQXhCRDs7QUEwQkEsSUFBSWYsUUFBSixHOzs7Ozs7Ozs7OztBQ3hDQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywrVkFBNEw7QUFDbE4sNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxtSUFBc0U7QUFDeEYsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxJQUFVO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQiwrVkFBNEw7QUFDak4sc0JBQXNCLG1CQUFPLENBQUMsK1ZBQTRMO0FBQzFOLHVEQUF1RCxRQUFTO0FBQ2hFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEMiLCJmaWxlIjoiY2FsZW5kYXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJDYWxlbmRhclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJDYWxlbmRhclwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIEZ1bGxDYWxlbmRhciB2My45LjBcXG4gKiBEb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXFxuICogKGMpIDIwMTggQWRhbSBTaGF3XFxuICovXFxuLmZjIHtcXG4gIGRpcmVjdGlvbjogbHRyO1xcbiAgdGV4dC1hbGlnbjogbGVmdDsgfVxcblxcbi5mYy1ydGwge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG5ib2R5IC5mYyB7XFxuICAvKiBleHRyYSBwcmVjZWRlbmNlIHRvIG92ZXJjb21lIGpxdWkgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyB9XFxuXFxuLyogQ29sb3JzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1oaWdobGlnaHQge1xcbiAgLyogd2hlbiB1c2VyIGlzIHNlbGVjdGluZyBjZWxscyAqL1xcbiAgYmFja2dyb3VuZDogI2JjZThmMTtcXG4gIG9wYWNpdHk6IC4zOyB9XFxuXFxuLmZjLWJnZXZlbnQge1xcbiAgLyogZGVmYXVsdCBsb29rIGZvciBiYWNrZ3JvdW5kIGV2ZW50cyAqL1xcbiAgYmFja2dyb3VuZDogIzhmZGY4MjtcXG4gIG9wYWNpdHk6IC4zOyB9XFxuXFxuLmZjLW5vbmJ1c2luZXNzIHtcXG4gIC8qIGRlZmF1bHQgbG9vayBmb3Igbm9uLWJ1c2luZXNzLWhvdXJzIGFyZWFzICovXFxuICAvKiB3aWxsIGluaGVyaXQgLmZjLWJnZXZlbnQncyBzdHlsZXMgKi9cXG4gIGJhY2tncm91bmQ6ICNkN2Q3ZDc7IH1cXG5cXG4vKiBCdXR0b25zIChzdHlsZWQgPGJ1dHRvbj4gdGFncywgbm9ybWFsaXplZCB0byB3b3JrIGNyb3NzLWJyb3dzZXIpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYyBidXR0b24ge1xcbiAgLyogZm9yY2UgaGVpZ2h0IHRvIGluY2x1ZGUgdGhlIGJvcmRlciBhbmQgcGFkZGluZyAqL1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC8qIGRpbWVuc2lvbnMgKi9cXG4gIG1hcmdpbjogMDtcXG4gIGhlaWdodDogMi4xZW07XFxuICBwYWRkaW5nOiAwIC42ZW07XFxuICAvKiB0ZXh0ICYgY3Vyc29yICovXFxuICBmb250LXNpemU6IDFlbTtcXG4gIC8qIG5vcm1hbGl6ZSAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGN1cnNvcjogcG9pbnRlcjsgfVxcblxcbi8qIEZpcmVmb3ggaGFzIGFuIGFubm95aW5nIGlubmVyIGJvcmRlciAqL1xcbi5mYyBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDsgfVxcblxcbi5mYy1zdGF0ZS1kZWZhdWx0IHtcXG4gIC8qIG5vbi10aGVtZSAqL1xcbiAgYm9yZGVyOiAxcHggc29saWQ7IH1cXG5cXG4uZmMtc3RhdGUtZGVmYXVsdC5mYy1jb3JuZXItbGVmdCB7XFxuICAvKiBub24tdGhlbWUgKi9cXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDsgfVxcblxcbi5mYy1zdGF0ZS1kZWZhdWx0LmZjLWNvcm5lci1yaWdodCB7XFxuICAvKiBub24tdGhlbWUgKi9cXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4OyB9XFxuXFxuLyogaWNvbnMgaW4gYnV0dG9ucyAqL1xcbi5mYyBidXR0b24gLmZjLWljb24ge1xcbiAgLyogbm9uLXRoZW1lICovXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IC0wLjA1ZW07XFxuICAvKiBzZWVtcyB0byBiZSBhIGdvb2QgYWRqdXN0bWVudCBhY3Jvc3MgYnJvd3NlcnMgKi9cXG4gIG1hcmdpbjogMCAuMmVtO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcblxcbi8qXFxuICBidXR0b24gc3RhdGVzXFxuICBib3Jyb3dlZCBmcm9tIHR3aXR0ZXIgYm9vdHN0cmFwIChodHRwOi8vdHdpdHRlci5naXRodWIuY29tL2Jvb3RzdHJhcC8pXFxuKi9cXG4uZmMtc3RhdGUtZGVmYXVsdCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNWY1O1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAjZmZmZmZmLCAjZTZlNmU2KTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCAwIDAsIDAgMTAwJSwgZnJvbSgjZmZmZmZmKSwgdG8oI2U2ZTZlNikpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAjZmZmZmZmLCAjZTZlNmU2KTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICNmZmZmZmYsICNlNmU2ZTYpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgI2ZmZmZmZiwgI2U2ZTZlNik7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXg7XFxuICBib3JkZXItY29sb3I6ICNlNmU2ZTYgI2U2ZTZlNiAjYmZiZmJmO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSkgcmdiYSgwLCAwLCAwLCAwLjEpIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICBjb2xvcjogIzMzMztcXG4gIHRleHQtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwIDFweCAycHggcmdiYSgwLCAwLCAwLCAwLjA1KTsgfVxcblxcbi5mYy1zdGF0ZS1ob3ZlcixcXG4uZmMtc3RhdGUtZG93bixcXG4uZmMtc3RhdGUtYWN0aXZlLFxcbi5mYy1zdGF0ZS1kaXNhYmxlZCB7XFxuICBjb2xvcjogIzMzMzMzMztcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7IH1cXG5cXG4uZmMtc3RhdGUtaG92ZXIge1xcbiAgY29sb3I6ICMzMzMzMzM7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIC0xNXB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLXBvc2l0aW9uIDAuMXMgbGluZWFyO1xcbiAgLW1vei10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLXBvc2l0aW9uIDAuMXMgbGluZWFyO1xcbiAgLW8tdHJhbnNpdGlvbjogYmFja2dyb3VuZC1wb3NpdGlvbiAwLjFzIGxpbmVhcjtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtcG9zaXRpb24gMC4xcyBsaW5lYXI7IH1cXG5cXG4uZmMtc3RhdGUtZG93bixcXG4uZmMtc3RhdGUtYWN0aXZlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjY2NjY2M7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lO1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAycHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xNSksIDAgMXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMDUpOyB9XFxuXFxuLmZjLXN0YXRlLWRpc2FibGVkIHtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxuICBvcGFjaXR5OiAwLjY1O1xcbiAgYm94LXNoYWRvdzogbm9uZTsgfVxcblxcbi8qIEJ1dHRvbnMgR3JvdXBzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1idXR0b24tZ3JvdXAge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuXFxuLypcXG5ldmVyeSBidXR0b24gdGhhdCBpcyBub3QgZmlyc3QgaW4gYSBidXR0b24gZ3JvdXAgc2hvdWxkIHNjb290Y2ggb3ZlciBvbmUgcGl4ZWwgYW5kIGNvdmVyIHRoZVxcbnByZXZpb3VzIGJ1dHRvbidzIGJvcmRlci4uLlxcbiovXFxuLmZjIC5mYy1idXR0b24tZ3JvdXAgPiAqIHtcXG4gIC8qIGV4dHJhIHByZWNlZGVuY2UgYi9jIGJ1dHRvbnMgaGF2ZSBtYXJnaW4gc2V0IHRvIHplcm8gKi9cXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luOiAwIDAgMCAtMXB4OyB9XFxuXFxuLmZjIC5mYy1idXR0b24tZ3JvdXAgPiA6Zmlyc3QtY2hpbGQge1xcbiAgLyogc2FtZSAqL1xcbiAgbWFyZ2luLWxlZnQ6IDA7IH1cXG5cXG4vKiBQb3BvdmVyXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1wb3BvdmVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJveC1zaGFkb3c6IDAgMnB4IDZweCByZ2JhKDAsIDAsIDAsIDAuMTUpOyB9XFxuXFxuLmZjLXBvcG92ZXIgLmZjLWhlYWRlciB7XFxuICAvKiBUT0RPOiBiZSBtb3JlIGNvbnNpc3RlbnQgd2l0aCBmYy1oZWFkL2ZjLWJvZHkgKi9cXG4gIHBhZGRpbmc6IDJweCA0cHg7IH1cXG5cXG4uZmMtcG9wb3ZlciAuZmMtaGVhZGVyIC5mYy10aXRsZSB7XFxuICBtYXJnaW46IDAgMnB4OyB9XFxuXFxuLmZjLXBvcG92ZXIgLmZjLWhlYWRlciAuZmMtY2xvc2Uge1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuLmZjLWx0ciAuZmMtcG9wb3ZlciAuZmMtaGVhZGVyIC5mYy10aXRsZSxcXG4uZmMtcnRsIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLWNsb3NlIHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLmZjLXJ0bCAuZmMtcG9wb3ZlciAuZmMtaGVhZGVyIC5mYy10aXRsZSxcXG4uZmMtbHRyIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLWNsb3NlIHtcXG4gIGZsb2F0OiByaWdodDsgfVxcblxcbi8qIE1pc2MgUmV1c2FibGUgQ29tcG9uZW50c1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtZGl2aWRlciB7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7IH1cXG5cXG5oci5mYy1kaXZpZGVyIHtcXG4gIGhlaWdodDogMDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDAgMCAycHg7XFxuICAvKiBoZWlnaHQgaXMgdW5yZWxpYWJsZSBhY3Jvc3MgYnJvd3NlcnMsIHNvIHVzZSBwYWRkaW5nICovXFxuICBib3JkZXItd2lkdGg6IDFweCAwOyB9XFxuXFxuLmZjLWNsZWFyIHtcXG4gIGNsZWFyOiBib3RoOyB9XFxuXFxuLmZjLWJnLFxcbi5mYy1iZ2V2ZW50LXNrZWxldG9uLFxcbi5mYy1oaWdobGlnaHQtc2tlbGV0b24sXFxuLmZjLWhlbHBlci1za2VsZXRvbiB7XFxuICAvKiB0aGVzZSBlbGVtZW50IHNob3VsZCBhbHdheXMgY2xpbmcgdG8gdG9wLWxlZnQvcmlnaHQgY29ybmVycyAqL1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLmZjLWJnIHtcXG4gIGJvdHRvbTogMDtcXG4gIC8qIHN0cmVjaCBiZyB0byBib3R0b20gZWRnZSAqLyB9XFxuXFxuLmZjLWJnIHRhYmxlIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIC8qIHN0cmVjaCBiZyB0byBib3R0b20gZWRnZSAqLyB9XFxuXFxuLyogVGFibGVzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYyB0YWJsZSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAvKiBmaXggc2Nyb2xsYmFyIGlzc3VlIGluIGZpcmVmb3ggKi9cXG4gIHRhYmxlLWxheW91dDogZml4ZWQ7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICBmb250LXNpemU6IDFlbTtcXG4gIC8qIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyICovIH1cXG5cXG4uZmMgdGgge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuXFxuLmZjIHRoLFxcbi5mYyB0ZCB7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICBwYWRkaW5nOiAwO1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcblxcbi5mYyB0ZC5mYy10b2RheSB7XFxuICBib3JkZXItc3R5bGU6IGRvdWJsZTtcXG4gIC8qIG92ZXJjb21lIG5laWdoYm9yaW5nIGJvcmRlcnMgKi8gfVxcblxcbi8qIEludGVybmFsIE5hdiBMaW5rc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5hW2RhdGEtZ290b10ge1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuYVtkYXRhLWdvdG9dOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuXFxuLyogRmFrZSBUYWJsZSBSb3dzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYyAuZmMtcm93IHtcXG4gIC8qIGV4dHJhIHByZWNlZGVuY2UgdG8gb3ZlcmNvbWUgdGhlbWVzIHcvIC51aS13aWRnZXQtY29udGVudCBmb3JjaW5nIGEgMXB4IGJvcmRlciAqL1xcbiAgLyogbm8gdmlzaWJsZSBib3JkZXIgYnkgZGVmYXVsdC4gYnV0IG1ha2UgYXZhaWxhYmxlIGlmIG5lZWQgYmUgKHNjcm9sbGJhciB3aWR0aCBjb21wZW5zYXRpb24pICovXFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuXFxuLmZjLXJvdyB0YWJsZSB7XFxuICAvKiBkb24ndCBwdXQgbGVmdC9yaWdodCBib3JkZXIgb24gYW55dGhpbmcgd2l0aGluIGEgZmFrZSByb3cuXFxuICAgICB0aGUgb3V0ZXIgdGJvZHkgd2lsbCB3b3JyeSBhYm91dCB0aGlzICovXFxuICBib3JkZXItbGVmdDogMCBoaWRkZW4gdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmlnaHQ6IDAgaGlkZGVuIHRyYW5zcGFyZW50O1xcbiAgLyogbm8gYm90dG9tIGJvcmRlcnMgb24gcm93cyAqL1xcbiAgYm9yZGVyLWJvdHRvbTogMCBoaWRkZW4gdHJhbnNwYXJlbnQ7IH1cXG5cXG4uZmMtcm93OmZpcnN0LWNoaWxkIHRhYmxlIHtcXG4gIGJvcmRlci10b3A6IDAgaGlkZGVuIHRyYW5zcGFyZW50O1xcbiAgLyogbm8gdG9wIGJvcmRlciBvbiBmaXJzdCByb3cgKi8gfVxcblxcbi8qIERheSBSb3cgKHVzZWQgd2l0aGluIHRoZSBoZWFkZXIgYW5kIHRoZSBEYXlHcmlkKVxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtcm93IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcblxcbi5mYy1yb3cgLmZjLWJnIHtcXG4gIHotaW5kZXg6IDE7IH1cXG5cXG4vKiBoaWdobGlnaHRpbmcgY2VsbHMgJiBiYWNrZ3JvdW5kIGV2ZW50IHNrZWxldG9uICovXFxuLmZjLXJvdyAuZmMtYmdldmVudC1za2VsZXRvbixcXG4uZmMtcm93IC5mYy1oaWdobGlnaHQtc2tlbGV0b24ge1xcbiAgYm90dG9tOiAwO1xcbiAgLyogc3RyZXRjaCBza2VsZXRvbiB0byBib3R0b20gb2Ygcm93ICovIH1cXG5cXG4uZmMtcm93IC5mYy1iZ2V2ZW50LXNrZWxldG9uIHRhYmxlLFxcbi5mYy1yb3cgLmZjLWhpZ2hsaWdodC1za2VsZXRvbiB0YWJsZSB7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICAvKiBzdHJldGNoIHNrZWxldG9uIHRvIGJvdHRvbSBvZiByb3cgKi8gfVxcblxcbi5mYy1yb3cgLmZjLWhpZ2hsaWdodC1za2VsZXRvbiB0ZCxcXG4uZmMtcm93IC5mYy1iZ2V2ZW50LXNrZWxldG9uIHRkIHtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG5cXG4uZmMtcm93IC5mYy1iZ2V2ZW50LXNrZWxldG9uIHtcXG4gIHotaW5kZXg6IDI7IH1cXG5cXG4uZmMtcm93IC5mYy1oaWdobGlnaHQtc2tlbGV0b24ge1xcbiAgei1pbmRleDogMzsgfVxcblxcbi8qXFxucm93IGNvbnRlbnQgKHdoaWNoIGNvbnRhaW5zIGRheS93ZWVrIG51bWJlcnMgYW5kIGV2ZW50cykgYXMgd2VsbCBhcyBcXFwiaGVscGVyXFxcIiAod2hpY2ggY29udGFpbnNcXG50ZW1wb3JhcnkgcmVuZGVyZWQgZXZlbnRzKS5cXG4qL1xcbi5mYy1yb3cgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogNDtcXG4gIHBhZGRpbmctYm90dG9tOiAycHg7XFxuICAvKiBtYXRjaGVzIHRoZSBzcGFjZSBhYm92ZSB0aGUgZXZlbnRzICovIH1cXG5cXG4uZmMtcm93IC5mYy1oZWxwZXItc2tlbGV0b24ge1xcbiAgei1pbmRleDogNTsgfVxcblxcbi5mYyAuZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRhYmxlLFxcbi5mYyAuZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRkLFxcbi5mYyAuZmMtcm93IC5mYy1oZWxwZXItc2tlbGV0b24gdGQge1xcbiAgLyogc2VlLXRocm91Z2ggdG8gdGhlIGJhY2tncm91bmQgYmVsb3cgKi9cXG4gIC8qIGV4dHJhIHByZWNlZGVuY2UgdG8gcHJldmVudCB0aGVtZS1wcm92aWRlZCBiYWNrZ3JvdW5kcyAqL1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIC8qIGluIGNhc2UgPHRkPnMgYXJlIGdsb2JhbGx5IHN0eWxlZCAqL1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcblxcbi5mYy1yb3cgLmZjLWNvbnRlbnQtc2tlbGV0b24gdGQsXFxuLmZjLXJvdyAuZmMtaGVscGVyLXNrZWxldG9uIHRkIHtcXG4gIC8qIGRvbid0IHB1dCBhIGJvcmRlciBiZXR3ZWVuIGV2ZW50cyBhbmQvb3IgdGhlIGRheSBudW1iZXIgKi9cXG4gIGJvcmRlci1ib3R0b206IDA7IH1cXG5cXG4uZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRib2R5IHRkLFxcbi5mYy1yb3cgLmZjLWhlbHBlci1za2VsZXRvbiB0Ym9keSB0ZCB7XFxuICAvKiBkb24ndCBwdXQgYSBib3JkZXIgYmV0d2VlbiBldmVudCBjZWxscyAqL1xcbiAgYm9yZGVyLXRvcDogMDsgfVxcblxcbi8qIFNjcm9sbGluZyBDb250YWluZXJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXNjcm9sbGVyIHtcXG4gIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDsgfVxcblxcbi8qIFRPRE86IG1vdmUgdG8gYWdlbmRhL2Jhc2ljICovXFxuLmZjLXNjcm9sbGVyID4gLmZjLWRheS1ncmlkLFxcbi5mYy1zY3JvbGxlciA+IC5mYy10aW1lLWdyaWQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLyogcmUtc2NvcGUgYWxsIHBvc2l0aW9ucyAqL1xcbiAgd2lkdGg6IDEwMCU7XFxuICAvKiBoYWNrIHRvIGZvcmNlIHJlLXNpemluZyB0aGlzIGlubmVyIGVsZW1lbnQgd2hlbiBzY3JvbGxiYXJzIGFwcGVhci9kaXNhcHBlYXIgKi8gfVxcblxcbi8qIEdsb2JhbCBFdmVudCBTdHlsZXNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLWV2ZW50IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC8qIGZvciByZXNpemUgaGFuZGxlIGFuZCBvdGhlciBpbm5lciBwb3NpdGlvbmluZyAqL1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICAvKiBtYWtlIHRoZSA8YT4gdGFnIGJsb2NrICovXFxuICBmb250LXNpemU6IC44NWVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMztcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICMzYTg3YWQ7XFxuICAvKiBkZWZhdWx0IEJPUkRFUiBjb2xvciAqLyB9XFxuXFxuLmZjLWV2ZW50LFxcbi5mYy1ldmVudC1kb3Qge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNhODdhZDtcXG4gIC8qIGRlZmF1bHQgQkFDS0dST1VORCBjb2xvciAqLyB9XFxuXFxuLmZjLWV2ZW50LFxcbi5mYy1ldmVudDpob3ZlciB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIC8qIGRlZmF1bHQgVEVYVCBjb2xvciAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgLyogaWYgPGE+IGhhcyBhbiBocmVmICovIH1cXG5cXG4uZmMtZXZlbnRbaHJlZl0sXFxuLmZjLWV2ZW50LmZjLWRyYWdnYWJsZSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICAvKiBnaXZlIGV2ZW50cyB3aXRoIGxpbmtzIGFuZCBkcmFnZ2FibGUgZXZlbnRzIGEgaGFuZCBtb3VzZSBwb2ludGVyICovIH1cXG5cXG4uZmMtbm90LWFsbG93ZWQsXFxuLmZjLW5vdC1hbGxvd2VkIC5mYy1ldmVudCB7XFxuICAvKiB0byBvdmVycmlkZSBhbiBldmVudCdzIGN1c3RvbSBjdXJzb3IgKi9cXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG5cXG4uZmMtZXZlbnQgLmZjLWJnIHtcXG4gIC8qIHRoZSBnZW5lcmljIC5mYy1iZyBhbHJlYWR5IGRvZXMgcG9zaXRpb24gKi9cXG4gIHotaW5kZXg6IDE7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgb3BhY2l0eTogLjI1OyB9XFxuXFxuLmZjLWV2ZW50IC5mYy1jb250ZW50IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDI7IH1cXG5cXG4vKiByZXNpemVyIChjdXJzb3IgQU5EIHRvdWNoIGRldmljZXMpICovXFxuLmZjLWV2ZW50IC5mYy1yZXNpemVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDQ7IH1cXG5cXG4vKiByZXNpemVyICh0b3VjaCBkZXZpY2VzKSAqL1xcbi5mYy1ldmVudCAuZmMtcmVzaXplciB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLmZjLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtcmVzaXplcixcXG4uZmMtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLXJlc2l6ZXIge1xcbiAgLyogb25seSBzaG93IHdoZW4gaG92ZXJpbmcgb3Igc2VsZWN0ZWQgKHdpdGggdG91Y2gpICovXFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi8qIGhpdCBhcmVhICovXFxuLmZjLWV2ZW50LmZjLXNlbGVjdGVkIC5mYy1yZXNpemVyOmJlZm9yZSB7XFxuICAvKiA0MHg0MCB0b3VjaCBhcmVhICovXFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDk5OTk7XFxuICAvKiB1c2VyIG9mIHRoaXMgdXRpbCBjYW4gc2NvcGUgd2l0aGluIGEgbG93ZXIgei1pbmRleCAqL1xcbiAgdG9wOiA1MCU7XFxuICBsZWZ0OiA1MCU7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIG1hcmdpbi1sZWZ0OiAtMjBweDtcXG4gIG1hcmdpbi10b3A6IC0yMHB4OyB9XFxuXFxuLyogRXZlbnQgU2VsZWN0aW9uIChvbmx5IGZvciB0b3VjaCBkZXZpY2VzKVxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtZXZlbnQuZmMtc2VsZWN0ZWQge1xcbiAgei1pbmRleDogOTk5OSAhaW1wb3J0YW50O1xcbiAgLyogb3ZlcmNvbWVzIGlubGluZSB6LWluZGV4ICovXFxuICBib3gtc2hhZG93OiAwIDJweCA1cHggcmdiYSgwLCAwLCAwLCAwLjIpOyB9XFxuXFxuLmZjLWV2ZW50LmZjLXNlbGVjdGVkLmZjLWRyYWdnaW5nIHtcXG4gIGJveC1zaGFkb3c6IDAgMnB4IDdweCByZ2JhKDAsIDAsIDAsIDAuMyk7IH1cXG5cXG4vKiBIb3Jpem9udGFsIEV2ZW50c1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4vKiBiaWdnZXIgdG91Y2ggYXJlYSB3aGVuIHNlbGVjdGVkICovXFxuLmZjLWgtZXZlbnQuZmMtc2VsZWN0ZWQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMztcXG4gIC8qIGJlbG93IHJlc2l6ZXJzICovXFxuICB0b3A6IC0xMHB4O1xcbiAgYm90dG9tOiAtMTBweDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDsgfVxcblxcbi8qIGV2ZW50cyB0aGF0IGFyZSBjb250aW51aW5nIHRvL2Zyb20gYW5vdGhlciB3ZWVrLiBraWxsIHJvdW5kZWQgY29ybmVycyBhbmQgYnV0dCB1cCBhZ2FpbnN0IGVkZ2UgKi9cXG4uZmMtbHRyIC5mYy1oLWV2ZW50LmZjLW5vdC1zdGFydCxcXG4uZmMtcnRsIC5mYy1oLWV2ZW50LmZjLW5vdC1lbmQge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBib3JkZXItbGVmdC13aWR0aDogMDtcXG4gIHBhZGRpbmctbGVmdDogMXB4O1xcbiAgLyogcmVwbGFjZSB0aGUgYm9yZGVyIHdpdGggcGFkZGluZyAqL1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7IH1cXG5cXG4uZmMtbHRyIC5mYy1oLWV2ZW50LmZjLW5vdC1lbmQsXFxuLmZjLXJ0bCAuZmMtaC1ldmVudC5mYy1ub3Qtc3RhcnQge1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbiAgcGFkZGluZy1yaWdodDogMXB4O1xcbiAgLyogcmVwbGFjZSB0aGUgYm9yZGVyIHdpdGggcGFkZGluZyAqL1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDsgfVxcblxcbi8qIHJlc2l6ZXIgKGN1cnNvciBBTkQgdG91Y2ggZGV2aWNlcykgKi9cXG4vKiBsZWZ0IHJlc2l6ZXIgICovXFxuLmZjLWx0ciAuZmMtaC1ldmVudCAuZmMtc3RhcnQtcmVzaXplcixcXG4uZmMtcnRsIC5mYy1oLWV2ZW50IC5mYy1lbmQtcmVzaXplciB7XFxuICBjdXJzb3I6IHctcmVzaXplO1xcbiAgbGVmdDogLTFweDtcXG4gIC8qIG92ZXJjb21lIGJvcmRlciAqLyB9XFxuXFxuLyogcmlnaHQgcmVzaXplciAqL1xcbi5mYy1sdHIgLmZjLWgtZXZlbnQgLmZjLWVuZC1yZXNpemVyLFxcbi5mYy1ydGwgLmZjLWgtZXZlbnQgLmZjLXN0YXJ0LXJlc2l6ZXIge1xcbiAgY3Vyc29yOiBlLXJlc2l6ZTtcXG4gIHJpZ2h0OiAtMXB4O1xcbiAgLyogb3ZlcmNvbWUgYm9yZGVyICovIH1cXG5cXG4vKiByZXNpemVyIChtb3VzZSBkZXZpY2VzKSAqL1xcbi5mYy1oLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtcmVzaXplciB7XFxuICB3aWR0aDogN3B4O1xcbiAgdG9wOiAtMXB4O1xcbiAgLyogb3ZlcmNvbWUgdG9wIGJvcmRlciAqL1xcbiAgYm90dG9tOiAtMXB4O1xcbiAgLyogb3ZlcmNvbWUgYm90dG9tIGJvcmRlciAqLyB9XFxuXFxuLyogcmVzaXplciAodG91Y2ggZGV2aWNlcykgKi9cXG4uZmMtaC1ldmVudC5mYy1zZWxlY3RlZCAuZmMtcmVzaXplciB7XFxuICAvKiA4eDggbGl0dGxlIGRvdCAqL1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICB3aWR0aDogNnB4O1xcbiAgaGVpZ2h0OiA2cHg7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLWNvbG9yOiBpbmhlcml0O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIC8qIHZlcnRpY2FsbHkgY2VudGVyICovXFxuICB0b3A6IDUwJTtcXG4gIG1hcmdpbi10b3A6IC00cHg7IH1cXG5cXG4vKiBsZWZ0IHJlc2l6ZXIgICovXFxuLmZjLWx0ciAuZmMtaC1ldmVudC5mYy1zZWxlY3RlZCAuZmMtc3RhcnQtcmVzaXplcixcXG4uZmMtcnRsIC5mYy1oLWV2ZW50LmZjLXNlbGVjdGVkIC5mYy1lbmQtcmVzaXplciB7XFxuICBtYXJnaW4tbGVmdDogLTRweDtcXG4gIC8qIGNlbnRlcnMgdGhlIDh4OCBkb3Qgb24gdGhlIGxlZnQgZWRnZSAqLyB9XFxuXFxuLyogcmlnaHQgcmVzaXplciAqL1xcbi5mYy1sdHIgLmZjLWgtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLWVuZC1yZXNpemVyLFxcbi5mYy1ydGwgLmZjLWgtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLXN0YXJ0LXJlc2l6ZXIge1xcbiAgbWFyZ2luLXJpZ2h0OiAtNHB4O1xcbiAgLyogY2VudGVycyB0aGUgOHg4IGRvdCBvbiB0aGUgcmlnaHQgZWRnZSAqLyB9XFxuXFxuLyogRGF5R3JpZCBldmVudHNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuV2UgdXNlIHRoZSBmdWxsIFxcXCJmYy1kYXktZ3JpZC1ldmVudFxcXCIgY2xhc3MgaW5zdGVhZCBvZiB1c2luZyBkZXNjZW5kYW50cyBiZWNhdXNlIHRoZSBldmVudCB3b24ndFxcbmJlIGEgZGVzY2VuZGFudCBvZiB0aGUgZ3JpZCB3aGVuIGl0IGlzIGJlaW5nIGRyYWdnZWQuXFxuKi9cXG4uZmMtZGF5LWdyaWQtZXZlbnQge1xcbiAgbWFyZ2luOiAxcHggMnB4IDA7XFxuICAvKiBzcGFjaW5nIGJldHdlZW4gZXZlbnRzIGFuZCBlZGdlcyAqL1xcbiAgcGFkZGluZzogMCAxcHg7IH1cXG5cXG50cjpmaXJzdC1jaGlsZCA+IHRkID4gLmZjLWRheS1ncmlkLWV2ZW50IHtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIC8qIGEgbGl0dGxlIGJpdCBtb3JlIHNwYWNlIGJlZm9yZSB0aGUgZmlyc3QgZXZlbnQgKi8gfVxcblxcbi5mYy1kYXktZ3JpZC1ldmVudC5mYy1zZWxlY3RlZDphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDE7XFxuICAvKiBzYW1lIHotaW5kZXggYXMgZmMtYmcsIGJlaGluZCB0ZXh0ICovXFxuICAvKiBvdmVyY29tZSB0aGUgYm9yZGVycyAqL1xcbiAgdG9wOiAtMXB4O1xcbiAgcmlnaHQ6IC0xcHg7XFxuICBib3R0b206IC0xcHg7XFxuICBsZWZ0OiAtMXB4O1xcbiAgLyogZGFya2VuaW5nIGVmZmVjdCAqL1xcbiAgYmFja2dyb3VuZDogIzAwMDtcXG4gIG9wYWNpdHk6IC4yNTsgfVxcblxcbi5mYy1kYXktZ3JpZC1ldmVudCAuZmMtY29udGVudCB7XFxuICAvKiBmb3JjZSBldmVudHMgdG8gYmUgb25lLWxpbmUgdGFsbCAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG4uZmMtZGF5LWdyaWQtZXZlbnQgLmZjLXRpbWUge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7IH1cXG5cXG4vKiByZXNpemVyIChjdXJzb3IgZGV2aWNlcykgKi9cXG4vKiBsZWZ0IHJlc2l6ZXIgICovXFxuLmZjLWx0ciAuZmMtZGF5LWdyaWQtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1zdGFydC1yZXNpemVyLFxcbi5mYy1ydGwgLmZjLWRheS1ncmlkLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtZW5kLXJlc2l6ZXIge1xcbiAgbWFyZ2luLWxlZnQ6IC0ycHg7XFxuICAvKiB0byB0aGUgZGF5IGNlbGwncyBlZGdlICovIH1cXG5cXG4vKiByaWdodCByZXNpemVyICovXFxuLmZjLWx0ciAuZmMtZGF5LWdyaWQtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1lbmQtcmVzaXplcixcXG4uZmMtcnRsIC5mYy1kYXktZ3JpZC1ldmVudC5mYy1hbGxvdy1tb3VzZS1yZXNpemUgLmZjLXN0YXJ0LXJlc2l6ZXIge1xcbiAgbWFyZ2luLXJpZ2h0OiAtMnB4O1xcbiAgLyogdG8gdGhlIGRheSBjZWxsJ3MgZWRnZSAqLyB9XFxuXFxuLyogRXZlbnQgTGltaXRpbmdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLyogXFxcIm1vcmVcXFwiIGxpbmsgdGhhdCByZXByZXNlbnRzIGhpZGRlbiBldmVudHMgKi9cXG5hLmZjLW1vcmUge1xcbiAgbWFyZ2luOiAxcHggM3B4O1xcbiAgZm9udC1zaXplOiAuODVlbTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcblxcbmEuZmMtbW9yZTpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgfVxcblxcbi5mYy1saW1pdGVkIHtcXG4gIC8qIHJvd3MgYW5kIGNlbGxzIHRoYXQgYXJlIGhpZGRlbiBiZWNhdXNlIG9mIGEgXFxcIm1vcmVcXFwiIGxpbmsgKi9cXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG4vKiBwb3BvdmVyIHRoYXQgYXBwZWFycyB3aGVuIFxcXCJtb3JlXFxcIiBsaW5rIGlzIGNsaWNrZWQgKi9cXG4uZmMtZGF5LWdyaWQgLmZjLXJvdyB7XFxuICB6LWluZGV4OiAxO1xcbiAgLyogbWFrZSB0aGUgXFxcIm1vcmVcXFwiIHBvcG92ZXIgb25lIGhpZ2hlciB0aGFuIHRoaXMgKi8gfVxcblxcbi5mYy1tb3JlLXBvcG92ZXIge1xcbiAgei1pbmRleDogMjtcXG4gIHdpZHRoOiAyMjBweDsgfVxcblxcbi5mYy1tb3JlLXBvcG92ZXIgLmZjLWV2ZW50LWNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiAxMHB4OyB9XFxuXFxuLyogTm93IEluZGljYXRvclxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtbm93LWluZGljYXRvciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3JkZXI6IDAgc29saWQgcmVkOyB9XFxuXFxuLyogVXRpbGl0aWVzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy11bnNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG5cXG4vKlxcblRPRE86IG1vcmUgZGlzdGluY3Rpb24gYmV0d2VlbiB0aGlzIGZpbGUgYW5kIGNvbW1vbi5jc3NcXG4qL1xcbi8qIENvbG9yc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtdW50aGVtZWQgdGgsXFxuLmZjLXVudGhlbWVkIHRkLFxcbi5mYy11bnRoZW1lZCB0aGVhZCxcXG4uZmMtdW50aGVtZWQgdGJvZHksXFxuLmZjLXVudGhlbWVkIC5mYy1kaXZpZGVyLFxcbi5mYy11bnRoZW1lZCAuZmMtcm93LFxcbi5mYy11bnRoZW1lZCAuZmMtY29udGVudCxcXG4uZmMtdW50aGVtZWQgLmZjLXBvcG92ZXIsXFxuLmZjLXVudGhlbWVkIC5mYy1saXN0LXZpZXcsXFxuLmZjLXVudGhlbWVkIC5mYy1saXN0LWhlYWRpbmcgdGQge1xcbiAgYm9yZGVyLWNvbG9yOiAjZGRkOyB9XFxuXFxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7IH1cXG5cXG4uZmMtdW50aGVtZWQgLmZjLWRpdmlkZXIsXFxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIsXFxuLmZjLXVudGhlbWVkIC5mYy1saXN0LWhlYWRpbmcgdGQge1xcbiAgYmFja2dyb3VuZDogI2VlZTsgfVxcblxcbi5mYy11bnRoZW1lZCAuZmMtcG9wb3ZlciAuZmMtaGVhZGVyIC5mYy1jbG9zZSB7XFxuICBjb2xvcjogIzY2NjsgfVxcblxcbi5mYy11bnRoZW1lZCB0ZC5mYy10b2RheSB7XFxuICBiYWNrZ3JvdW5kOiAjZmNmOGUzOyB9XFxuXFxuLmZjLXVudGhlbWVkIC5mYy1kaXNhYmxlZC1kYXkge1xcbiAgYmFja2dyb3VuZDogI2Q3ZDdkNztcXG4gIG9wYWNpdHk6IC4zOyB9XFxuXFxuLyogSWNvbnMgKGlubGluZSBlbGVtZW50cyB3aXRoIHN0eWxlZCB0ZXh0IHRoYXQgbW9jayBhcnJvdyBpY29ucylcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLWljb24ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBsaW5lLWhlaWdodDogMWVtO1xcbiAgZm9udC1zaXplOiAxZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJDb3VyaWVyIE5ld1xcXCIsIENvdXJpZXIsIG1vbm9zcGFjZTtcXG4gIC8qIGRvbid0IGFsbG93IGJyb3dzZXIgdGV4dC1zZWxlY3Rpb24gKi9cXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4vKlxcbkFjY2VwdGFibGUgZm9udC1mYW1pbHkgb3ZlcnJpZGVzIGZvciBpbmRpdmlkdWFsIGljb25zOlxcbiAgXFxcIkFyaWFsXFxcIiwgc2Fucy1zZXJpZlxcbiAgXFxcIlRpbWVzIE5ldyBSb21hblxcXCIsIHNlcmlmXFxuXFxuTk9URTogdXNlIHBlcmNlbnRhZ2UgZm9udCBzaXplcyBvciBlbHNlIG9sZCBJRSBjaG9rZXNcXG4qL1xcbi5mYy1pY29uOmFmdGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcblxcbi5mYy1pY29uLWxlZnQtc2luZ2xlLWFycm93OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMjAzOVxcXCI7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc2l6ZTogMjAwJTtcXG4gIHRvcDogLTclOyB9XFxuXFxuLmZjLWljb24tcmlnaHQtc2luZ2xlLWFycm93OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMjAzQVxcXCI7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc2l6ZTogMjAwJTtcXG4gIHRvcDogLTclOyB9XFxuXFxuLmZjLWljb24tbGVmdC1kb3VibGUtYXJyb3c6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFxBQlxcXCI7XFxuICBmb250LXNpemU6IDE2MCU7XFxuICB0b3A6IC03JTsgfVxcblxcbi5mYy1pY29uLXJpZ2h0LWRvdWJsZS1hcnJvdzphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcXEJCXFxcIjtcXG4gIGZvbnQtc2l6ZTogMTYwJTtcXG4gIHRvcDogLTclOyB9XFxuXFxuLmZjLWljb24tbGVmdC10cmlhbmdsZTphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcXDI1QzRcXFwiO1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgdG9wOiAzJTsgfVxcblxcbi5mYy1pY29uLXJpZ2h0LXRyaWFuZ2xlOmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMjVCQVxcXCI7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICB0b3A6IDMlOyB9XFxuXFxuLmZjLWljb24tZG93bi10cmlhbmdsZTphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcXDI1QkNcXFwiO1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgdG9wOiAyJTsgfVxcblxcbi5mYy1pY29uLXg6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFxEN1xcXCI7XFxuICBmb250LXNpemU6IDIwMCU7XFxuICB0b3A6IDYlOyB9XFxuXFxuLyogUG9wb3Zlclxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtdW50aGVtZWQgLmZjLXBvcG92ZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkOyB9XFxuXFxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLWNsb3NlIHtcXG4gIGZvbnQtc2l6ZTogLjllbTtcXG4gIG1hcmdpbi10b3A6IDJweDsgfVxcblxcbi8qIExpc3QgVmlld1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtdW50aGVtZWQgLmZjLWxpc3QtaXRlbTpob3ZlciB0ZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNWY1OyB9XFxuXFxuLyogQ29sb3JzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi51aS13aWRnZXQgLmZjLWRpc2FibGVkLWRheSB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyB9XFxuXFxuLyogUG9wb3Zlclxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtcG9wb3ZlciA+IC51aS13aWRnZXQtaGVhZGVyICsgLnVpLXdpZGdldC1jb250ZW50IHtcXG4gIGJvcmRlci10b3A6IDA7XFxuICAvKiB3aGVyZSB0aGV5IG1lZXQsIGxldCB0aGUgaGVhZGVyIGhhdmUgdGhlIGJvcmRlciAqLyB9XFxuXFxuLyogR2xvYmFsIEV2ZW50IFN0eWxlc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4udWktd2lkZ2V0IC5mYy1ldmVudCB7XFxuICAvKiBvdmVycG93ZXIganF1aSdzIHN0eWxlcyBvbiA8YT4gdGFncy4gVE9ETzogbW9yZSBEUlkgKi9cXG4gIGNvbG9yOiAjZmZmO1xcbiAgLyogZGVmYXVsdCBURVhUIGNvbG9yICovXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAvKiBpZiA8YT4gaGFzIGFuIGhyZWYgKi9cXG4gIC8qIHVuZG8gdWktd2lkZ2V0LWhlYWRlciBib2xkICovXFxuICBmb250LXdlaWdodDogbm9ybWFsOyB9XFxuXFxuLyogVGltZUdyaWQgYXhpcyBydW5uaW5nIGRvd24gdGhlIHNpZGUgKGZvciBib3RoIHRoZSBhbGwtZGF5IGFyZWEgYW5kIHRoZSBzbG90IGFyZWEpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi51aS13aWRnZXQgdGQuZmMtYXhpcyB7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgLyogb3ZlcmNvbWUgYm9sZCAqLyB9XFxuXFxuLyogVGltZUdyaWQgU2xhdHMgKGxpbmVzIHRoYXQgcnVuIGhvcml6b250YWxseSlcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXRpbWUtZ3JpZCAuZmMtc2xhdHMgLnVpLXdpZGdldC1jb250ZW50IHtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICAvKiBzZWUgdGhyb3VnaCB0byBmYy1iZyAqLyB9XFxuXFxuLmZjLmZjLWJvb3RzdHJhcDMgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG5cXG4uZmMuZmMtYm9vdHN0cmFwMyBhW2RhdGEtZ290b106aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IH1cXG5cXG4uZmMtYm9vdHN0cmFwMyBoci5mYy1kaXZpZGVyIHtcXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgfVxcblxcbi5mYy1ib290c3RyYXAzIC5mYy10b2RheS5hbGVydCB7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuXFxuLyogUG9wb3Zlclxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtYm9vdHN0cmFwMyAuZmMtcG9wb3ZlciAucGFuZWwtYm9keSB7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuLyogVGltZUdyaWQgU2xhdHMgKGxpbmVzIHRoYXQgcnVuIGhvcml6b250YWxseSlcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLWJvb3RzdHJhcDMgLmZjLXRpbWUtZ3JpZCAuZmMtc2xhdHMgdGFibGUge1xcbiAgLyogc29tZSB0aGVtZXMgaGF2ZSBiYWNrZ3JvdW5kIGNvbG9yLiBzZWUgdGhyb3VnaCB0byBzbGF0cyAqL1xcbiAgYmFja2dyb3VuZDogbm9uZTsgfVxcblxcbi5mYy5mYy1ib290c3RyYXA0IGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuXFxuLmZjLmZjLWJvb3RzdHJhcDQgYVtkYXRhLWdvdG9dOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuXFxuLmZjLWJvb3RzdHJhcDQgaHIuZmMtZGl2aWRlciB7XFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7IH1cXG5cXG4uZmMtYm9vdHN0cmFwNCAuZmMtdG9kYXkuYWxlcnQge1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcblxcbi5mYy1ib290c3RyYXA0IGEuZmMtZXZlbnQ6bm90KFtocmVmXSk6bm90KFt0YWJpbmRleF0pIHtcXG4gIGNvbG9yOiAjZmZmOyB9XFxuXFxuLmZjLWJvb3RzdHJhcDQgLmZjLXBvcG92ZXIuY2FyZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7IH1cXG5cXG4vKiBQb3BvdmVyXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1ib290c3RyYXA0IC5mYy1wb3BvdmVyIC5jYXJkLWJvZHkge1xcbiAgcGFkZGluZzogMDsgfVxcblxcbi8qIFRpbWVHcmlkIFNsYXRzIChsaW5lcyB0aGF0IHJ1biBob3Jpem9udGFsbHkpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1ib290c3RyYXA0IC5mYy10aW1lLWdyaWQgLmZjLXNsYXRzIHRhYmxlIHtcXG4gIC8qIHNvbWUgdGhlbWVzIGhhdmUgYmFja2dyb3VuZCBjb2xvci4gc2VlIHRocm91Z2ggdG8gc2xhdHMgKi9cXG4gIGJhY2tncm91bmQ6IG5vbmU7IH1cXG5cXG4vKiBUb29sYmFyXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy10b29sYmFyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcblxcbi5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFyIHtcXG4gIG1hcmdpbi1ib3R0b206IDFlbTsgfVxcblxcbi5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFyIHtcXG4gIG1hcmdpbi10b3A6IDFlbTsgfVxcblxcbi5mYy10b29sYmFyIC5mYy1sZWZ0IHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLmZjLXRvb2xiYXIgLmZjLXJpZ2h0IHtcXG4gIGZsb2F0OiByaWdodDsgfVxcblxcbi5mYy10b29sYmFyIC5mYy1jZW50ZXIge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuXFxuLyogdGhlIHRoaW5ncyB3aXRoaW4gZWFjaCBsZWZ0L3JpZ2h0L2NlbnRlciBzZWN0aW9uICovXFxuLmZjIC5mYy10b29sYmFyID4gKiA+ICoge1xcbiAgLyogZXh0cmEgcHJlY2VkZW5jZSB0byBvdmVycmlkZSBidXR0b24gYm9yZGVyIG1hcmdpbnMgKi9cXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLWxlZnQ6IC43NWVtOyB9XFxuXFxuLyogdGhlIGZpcnN0IHRoaW5nIHdpdGhpbiBlYWNoIGxlZnQvY2VudGVyL3JpZ2h0IHNlY3Rpb24gKi9cXG4uZmMgLmZjLXRvb2xiYXIgPiAqID4gOmZpcnN0LWNoaWxkIHtcXG4gIC8qIGV4dHJhIHByZWNlZGVuY2UgdG8gb3ZlcnJpZGUgYnV0dG9uIGJvcmRlciBtYXJnaW5zICovXFxuICBtYXJnaW4tbGVmdDogMDsgfVxcblxcbi8qIHRpdGxlIHRleHQgKi9cXG4uZmMtdG9vbGJhciBoMiB7XFxuICBtYXJnaW46IDA7IH1cXG5cXG4vKiBidXR0b24gbGF5ZXJpbmcgKGZvciBib3JkZXIgcHJlY2VkZW5jZSkgKi9cXG4uZmMtdG9vbGJhciBidXR0b24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLmZjLXRvb2xiYXIgLmZjLXN0YXRlLWhvdmVyLFxcbi5mYy10b29sYmFyIC51aS1zdGF0ZS1ob3ZlciB7XFxuICB6LWluZGV4OiAyOyB9XFxuXFxuLmZjLXRvb2xiYXIgLmZjLXN0YXRlLWRvd24ge1xcbiAgei1pbmRleDogMzsgfVxcblxcbi5mYy10b29sYmFyIC5mYy1zdGF0ZS1hY3RpdmUsXFxuLmZjLXRvb2xiYXIgLnVpLXN0YXRlLWFjdGl2ZSB7XFxuICB6LWluZGV4OiA0OyB9XFxuXFxuLmZjLXRvb2xiYXIgYnV0dG9uOmZvY3VzIHtcXG4gIHotaW5kZXg6IDU7IH1cXG5cXG4vKiBWaWV3IFN0cnVjdHVyZVxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4vKiB1bmRvIHR3aXR0ZXIgYm9vdHN0cmFwJ3MgYm94LXNpemluZyBydWxlcy4gbm9ybWFsaXplcyBwb3NpdGlvbmluZyB0ZWNobmlxdWVzICovXFxuLyogZG9uJ3QgZG8gdGhpcyBmb3IgdGhlIHRvb2xiYXIgYmVjYXVzZSB3ZSdsbCB3YW50IGJvb3RzdHJhcCB0byBzdHlsZSB0aG9zZSBidXR0b25zIGFzIHNvbWUgcHQgKi9cXG4uZmMtdmlldy1jb250YWluZXIgKixcXG4uZmMtdmlldy1jb250YWluZXIgKjpiZWZvcmUsXFxuLmZjLXZpZXctY29udGFpbmVyICo6YWZ0ZXIge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gIC1tb3otYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDsgfVxcblxcbi5mYy12aWV3LFxcbi5mYy12aWV3ID4gdGFibGUge1xcbiAgLyogc28gZHJhZ2dlZCBlbGVtZW50cyBjYW4gYmUgYWJvdmUgdGhlIHZpZXcncyBtYWluIGVsZW1lbnQgKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDE7IH1cXG5cXG4vKiBCYXNpY1ZpZXdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLyogZGF5IHJvdyBzdHJ1Y3R1cmUgKi9cXG4uZmMtYmFzaWNXZWVrLXZpZXcgLmZjLWNvbnRlbnQtc2tlbGV0b24sXFxuLmZjLWJhc2ljRGF5LXZpZXcgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xcbiAgLyogdGhlcmUgbWF5IGJlIHdlZWsgbnVtYmVycyBpbiB0aGVzZSB2aWV3cywgc28gbm8gcGFkZGluZy10b3AgKi9cXG4gIHBhZGRpbmctYm90dG9tOiAxZW07XFxuICAvKiBlbnN1cmUgYSBzcGFjZSBhdCBib3R0b20gb2YgY2VsbCBmb3IgdXNlciBzZWxlY3RpbmcvY2xpY2tpbmcgKi8gfVxcblxcbi5mYy1iYXNpYy12aWV3IC5mYy1ib2R5IC5mYy1yb3cge1xcbiAgbWluLWhlaWdodDogNGVtO1xcbiAgLyogZW5zdXJlIHRoYXQgYWxsIHJvd3MgYXJlIGF0IGxlYXN0IHRoaXMgdGFsbCAqLyB9XFxuXFxuLyogYSBcXFwicmlnaWRcXFwiIHJvdyB3aWxsIHRha2UgdXAgYSBjb25zdGFudCBhbW91bnQgb2YgaGVpZ2h0IGJlY2F1c2UgY29udGVudC1za2VsZXRvbiBpcyBhYnNvbHV0ZSAqL1xcbi5mYy1yb3cuZmMtcmlnaWQge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi5mYy1yb3cuZmMtcmlnaWQgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLyogd2VlayBhbmQgZGF5IG51bWJlciBzdHlsaW5nICovXFxuLmZjLWRheS10b3AuZmMtb3RoZXItbW9udGgge1xcbiAgb3BhY2l0eTogMC4zOyB9XFxuXFxuLmZjLWJhc2ljLXZpZXcgLmZjLXdlZWstbnVtYmVyLFxcbi5mYy1iYXNpYy12aWV3IC5mYy1kYXktbnVtYmVyIHtcXG4gIHBhZGRpbmc6IDJweDsgfVxcblxcbi5mYy1iYXNpYy12aWV3IHRoLmZjLXdlZWstbnVtYmVyLFxcbi5mYy1iYXNpYy12aWV3IHRoLmZjLWRheS1udW1iZXIge1xcbiAgcGFkZGluZzogMCAycHg7XFxuICAvKiBjb2x1bW4gaGVhZGVycyBjYW4ndCBoYXZlIGFzIG11Y2ggdiBzcGFjZSAqLyB9XFxuXFxuLmZjLWx0ciAuZmMtYmFzaWMtdmlldyAuZmMtZGF5LXRvcCAuZmMtZGF5LW51bWJlciB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4uZmMtcnRsIC5mYy1iYXNpYy12aWV3IC5mYy1kYXktdG9wIC5mYy1kYXktbnVtYmVyIHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLmZjLWx0ciAuZmMtYmFzaWMtdmlldyAuZmMtZGF5LXRvcCAuZmMtd2Vlay1udW1iZXIge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBib3JkZXItcmFkaXVzOiAwIDAgM3B4IDA7IH1cXG5cXG4uZmMtcnRsIC5mYy1iYXNpYy12aWV3IC5mYy1kYXktdG9wIC5mYy13ZWVrLW51bWJlciB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBib3JkZXItcmFkaXVzOiAwIDAgMCAzcHg7IH1cXG5cXG4uZmMtYmFzaWMtdmlldyAuZmMtZGF5LXRvcCAuZmMtd2Vlay1udW1iZXIge1xcbiAgbWluLXdpZHRoOiAxLjVlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMmYyZjI7XFxuICBjb2xvcjogIzgwODA4MDsgfVxcblxcbi8qIHdoZW4gd2Vlay9kYXkgbnVtYmVyIGhhdmUgb3duIGNvbHVtbiAqL1xcbi5mYy1iYXNpYy12aWV3IHRkLmZjLXdlZWstbnVtYmVyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcblxcbi5mYy1iYXNpYy12aWV3IHRkLmZjLXdlZWstbnVtYmVyID4gKiB7XFxuICAvKiB3b3JrIGFyb3VuZCB0aGUgd2F5IHdlIGRvIGNvbHVtbiByZXNpemluZyBhbmQgZW5zdXJlIGEgbWluaW11bSB3aWR0aCAqL1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWluLXdpZHRoOiAxLjI1ZW07IH1cXG5cXG4vKiBBZ2VuZGFWaWV3IGFsbC1kYXkgYXJlYVxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtYWdlbmRhLXZpZXcgLmZjLWRheS1ncmlkIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDI7XFxuICAvKiBzbyB0aGUgXFxcIm1vcmUuLlxcXCIgcG9wb3ZlciB3aWxsIGJlIG92ZXIgdGhlIHRpbWUgZ3JpZCAqLyB9XFxuXFxuLmZjLWFnZW5kYS12aWV3IC5mYy1kYXktZ3JpZCAuZmMtcm93IHtcXG4gIG1pbi1oZWlnaHQ6IDNlbTtcXG4gIC8qIGFsbC1kYXkgc2VjdGlvbiB3aWxsIG5ldmVyIGdldCBzaG9ydGVyIHRoYW4gdGhpcyAqLyB9XFxuXFxuLmZjLWFnZW5kYS12aWV3IC5mYy1kYXktZ3JpZCAuZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxZW07XFxuICAvKiBnaXZlIHNwYWNlIHVuZGVybmVhdGggZXZlbnRzIGZvciBjbGlja2luZy9zZWxlY3RpbmcgZGF5cyAqLyB9XFxuXFxuLyogVGltZUdyaWQgYXhpcyBydW5uaW5nIGRvd24gdGhlIHNpZGUgKGZvciBib3RoIHRoZSBhbGwtZGF5IGFyZWEgYW5kIHRoZSBzbG90IGFyZWEpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYyAuZmMtYXhpcyB7XFxuICAvKiAuZmMgdG8gb3ZlcmNvbWUgZGVmYXVsdCBjZWxsIHN0eWxlcyAqL1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIHBhZGRpbmc6IDAgNHB4O1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfVxcblxcbi5mYy1sdHIgLmZjLWF4aXMge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4uZmMtcnRsIC5mYy1heGlzIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7IH1cXG5cXG4vKiBUaW1lR3JpZCBTdHJ1Y3R1cmVcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXRpbWUtZ3JpZC1jb250YWluZXIsXFxuLmZjLXRpbWUtZ3JpZCB7XFxuICAvKiBzbyBzbGF0cy9iZy9jb250ZW50L2V0YyBwb3NpdGlvbnMgZ2V0IHNjb3BlZCB3aXRoaW4gaGVyZSAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMTsgfVxcblxcbi5mYy10aW1lLWdyaWQge1xcbiAgbWluLWhlaWdodDogMTAwJTtcXG4gIC8qIHNvIGlmIGhlaWdodCBzZXR0aW5nIGlzICdhdXRvJywgLmZjLWJnIHN0cmV0Y2hlcyB0byBmaWxsIGhlaWdodCAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZCB0YWJsZSB7XFxuICAvKiBkb24ndCBwdXQgb3V0ZXIgYm9yZGVycyBvbiBzbGF0cy9iZy9jb250ZW50L2V0YyAqL1xcbiAgYm9yZGVyOiAwIGhpZGRlbiB0cmFuc3BhcmVudDsgfVxcblxcbi5mYy10aW1lLWdyaWQgPiAuZmMtYmcge1xcbiAgei1pbmRleDogMTsgfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLXNsYXRzLFxcbi5mYy10aW1lLWdyaWQgPiBociB7XFxuICAvKiB0aGUgPGhyPiBBZ2VuZGFWaWV3IGluamVjdHMgd2hlbiBncmlkIGlzIHNob3J0ZXIgdGhhbiBzY3JvbGxlciAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMjsgfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLWNvbnRlbnQtY29sIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC8qIGJlY2F1c2Ugbm93LWluZGljYXRvciBsaXZlcyBkaXJlY3RseSBpbnNpZGUgKi8gfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMztcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDsgfVxcblxcbi8qIGRpdnMgd2l0aGluIGEgY2VsbCB3aXRoaW4gdGhlIGZjLWNvbnRlbnQtc2tlbGV0b24gKi9cXG4uZmMtdGltZS1ncmlkIC5mYy1idXNpbmVzcy1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMTsgfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLWJnZXZlbnQtY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDI7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1oaWdobGlnaHQtY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDM7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1ldmVudC1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogNDsgfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLW5vdy1pbmRpY2F0b3ItbGluZSB7XFxuICB6LWluZGV4OiA1OyB9XFxuXFxuLmZjLXRpbWUtZ3JpZCAuZmMtaGVscGVyLWNvbnRhaW5lciB7XFxuICAvKiBhbHNvIGlzIGZjLWV2ZW50LWNvbnRhaW5lciAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogNjsgfVxcblxcbi8qIFRpbWVHcmlkIFNsYXRzIChsaW5lcyB0aGF0IHJ1biBob3Jpem9udGFsbHkpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy10aW1lLWdyaWQgLmZjLXNsYXRzIHRkIHtcXG4gIGhlaWdodDogMS41ZW07XFxuICBib3JkZXItYm90dG9tOiAwO1xcbiAgLyogZWFjaCBjZWxsIGlzIHJlc3BvbnNpYmxlIGZvciBpdHMgdG9wIGJvcmRlciAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZCAuZmMtc2xhdHMgLmZjLW1pbm9yIHRkIHtcXG4gIGJvcmRlci10b3Atc3R5bGU6IGRvdHRlZDsgfVxcblxcbi8qIFRpbWVHcmlkIEhpZ2hsaWdodGluZyBTbG90c1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtdGltZS1ncmlkIC5mYy1oaWdobGlnaHQtY29udGFpbmVyIHtcXG4gIC8qIGEgZGl2IHdpdGhpbiBhIGNlbGwgd2l0aGluIHRoZSBmYy1oaWdobGlnaHQtc2tlbGV0b24gKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC8qIHNjb3BlcyB0aGUgbGVmdC9yaWdodCBvZiB0aGUgZmMtaGlnaGxpZ2h0IHRvIGJlIGluIHRoZSBjb2x1bW4gKi8gfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLWhpZ2hsaWdodCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICAvKiB0b3AgYW5kIGJvdHRvbSB3aWxsIGJlIGluIGJ5IEpTICovIH1cXG5cXG4vKiBUaW1lR3JpZCBFdmVudCBDb250YWlubWVudFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtbHRyIC5mYy10aW1lLWdyaWQgLmZjLWV2ZW50LWNvbnRhaW5lciB7XFxuICAvKiBzcGFjZSBvbiB0aGUgc2lkZXMgb2YgZXZlbnRzIGZvciBMVFIgKGRlZmF1bHQpICovXFxuICBtYXJnaW46IDAgMi41JSAwIDJweDsgfVxcblxcbi5mYy1ydGwgLmZjLXRpbWUtZ3JpZCAuZmMtZXZlbnQtY29udGFpbmVyIHtcXG4gIC8qIHNwYWNlIG9uIHRoZSBzaWRlcyBvZiBldmVudHMgZm9yIFJUTCAqL1xcbiAgbWFyZ2luOiAwIDJweCAwIDIuNSU7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1ldmVudCxcXG4uZmMtdGltZS1ncmlkIC5mYy1iZ2V2ZW50IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDE7XFxuICAvKiBzY29wZSBpbm5lciB6LWluZGV4J3MgKi8gfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLWJnZXZlbnQge1xcbiAgLyogYmFja2dyb3VuZCBldmVudHMgYWx3YXlzIHNwYW4gZnVsbCB3aWR0aCAqL1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLyogR2VuZXJpYyBWZXJ0aWNhbCBFdmVudFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtdi1ldmVudC5mYy1ub3Qtc3RhcnQge1xcbiAgLyogZXZlbnRzIHRoYXQgYXJlIGNvbnRpbnVpbmcgZnJvbSBhbm90aGVyIGRheSAqL1xcbiAgLyogcmVwbGFjZSBzcGFjZSBtYWRlIGJ5IHRoZSB0b3AgYm9yZGVyIHdpdGggcGFkZGluZyAqL1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMDtcXG4gIHBhZGRpbmctdG9wOiAxcHg7XFxuICAvKiByZW1vdmUgdG9wIHJvdW5kZWQgY29ybmVycyAqL1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwOyB9XFxuXFxuLmZjLXYtZXZlbnQuZmMtbm90LWVuZCB7XFxuICAvKiByZXBsYWNlIHNwYWNlIG1hZGUgYnkgdGhlIHRvcCBib3JkZXIgd2l0aCBwYWRkaW5nICovXFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgcGFkZGluZy1ib3R0b206IDFweDtcXG4gIC8qIHJlbW92ZSBib3R0b20gcm91bmRlZCBjb3JuZXJzICovXFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7IH1cXG5cXG4vKiBUaW1lR3JpZCBFdmVudCBTdHlsaW5nXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbldlIHVzZSB0aGUgZnVsbCBcXFwiZmMtdGltZS1ncmlkLWV2ZW50XFxcIiBjbGFzcyBpbnN0ZWFkIG9mIHVzaW5nIGRlc2NlbmRhbnRzIGJlY2F1c2UgdGhlIGV2ZW50IHdvbid0XFxuYmUgYSBkZXNjZW5kYW50IG9mIHRoZSBncmlkIHdoZW4gaXQgaXMgYmVpbmcgZHJhZ2dlZC5cXG4qL1xcbi5mYy10aW1lLWdyaWQtZXZlbnQge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIC8qIGRvbid0IGxldCB0aGUgYmcgZmxvdyBvdmVyIHJvdW5kZWQgY29ybmVycyAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zZWxlY3RlZCB7XFxuICAvKiBuZWVkIHRvIGFsbG93IHRvdWNoIHJlc2l6ZXJzIHRvIGV4dGVuZCBvdXRzaWRlIGV2ZW50J3MgYm91bmRpbmcgYm94ICovXFxuICAvKiBjb21tb24gZmMtc2VsZWN0ZWQgc3R5bGVzIGhpZGUgdGhlIGZjLWJnLCBzbyBkb24ndCBuZWVkIHRoaXMgYW55d2F5ICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTsgfVxcblxcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLWJnIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICAvKiBoaWRlIHNlbWktd2hpdGUgYmFja2dyb3VuZCwgdG8gYXBwZWFyIGRhcmtlciAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudCAuZmMtY29udGVudCB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgLyogZm9yIHdoZW4gLmZjLXNlbGVjdGVkICovIH1cXG5cXG4uZmMtdGltZS1ncmlkLWV2ZW50IC5mYy10aW1lLFxcbi5mYy10aW1lLWdyaWQtZXZlbnQgLmZjLXRpdGxlIHtcXG4gIHBhZGRpbmc6IDAgMXB4OyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudCAuZmMtdGltZSB7XFxuICBmb250LXNpemU6IC44NWVtO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfVxcblxcbi8qIHNob3J0IG1vZGUsIHdoZXJlIHRpbWUgYW5kIHRpdGxlIGFyZSBvbiB0aGUgc2FtZSBsaW5lICovXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zaG9ydCAuZmMtY29udGVudCB7XFxuICAvKiBkb24ndCB3cmFwIHRvIHNlY29uZCBsaW5lIChub3cgdGhhdCBjb250ZW50cyB3aWxsIGJlIGlubGluZSkgKi9cXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7IH1cXG5cXG4uZmMtdGltZS1ncmlkLWV2ZW50LmZjLXNob3J0IC5mYy10aW1lLFxcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2hvcnQgLmZjLXRpdGxlIHtcXG4gIC8qIHB1dCB0aGUgdGltZSBhbmQgdGl0bGUgb24gdGhlIHNhbWUgbGluZSAqL1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcblxcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2hvcnQgLmZjLXRpbWUgc3BhbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgLyogZG9uJ3QgZGlzcGxheSB0aGUgZnVsbCB0aW1lIHRleHQuLi4gKi8gfVxcblxcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2hvcnQgLmZjLXRpbWU6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IGF0dHIoZGF0YS1zdGFydCk7XFxuICAvKiAuLi5pbnN0ZWFkLCBkaXNwbGF5IG9ubHkgdGhlIHN0YXJ0IHRpbWUgKi8gfVxcblxcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2hvcnQgLmZjLXRpbWU6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFxBMC1cXFxcQTBcXFwiO1xcbiAgLyogc2VwZXJhdGUgd2l0aCBhIGRhc2gsIHdyYXBwZWQgaW4gbmJzcCdzICovIH1cXG5cXG4uZmMtdGltZS1ncmlkLWV2ZW50LmZjLXNob3J0IC5mYy10aXRsZSB7XFxuICBmb250LXNpemU6IC44NWVtO1xcbiAgLyogbWFrZSB0aGUgdGl0bGUgdGV4dCB0aGUgc2FtZSBzaXplIGFzIHRoZSB0aW1lICovXFxuICBwYWRkaW5nOiAwO1xcbiAgLyogdW5kbyBwYWRkaW5nIGZyb20gYWJvdmUgKi8gfVxcblxcbi8qIHJlc2l6ZXIgKGN1cnNvciBkZXZpY2UpICovXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1hbGxvdy1tb3VzZS1yZXNpemUgLmZjLXJlc2l6ZXIge1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgaGVpZ2h0OiA4cHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgbGluZS1oZWlnaHQ6IDhweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBjdXJzb3I6IHMtcmVzaXplOyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1hbGxvdy1tb3VzZS1yZXNpemUgLmZjLXJlc2l6ZXI6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIj1cXFwiOyB9XFxuXFxuLyogcmVzaXplciAodG91Y2ggZGV2aWNlKSAqL1xcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLXJlc2l6ZXIge1xcbiAgLyogMTB4MTAgZG90ICovXFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG4gIHdpZHRoOiA4cHg7XFxuICBoZWlnaHQ6IDhweDtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgLyogaG9yaXpvbnRhbGx5IGNlbnRlciAqL1xcbiAgbGVmdDogNTAlO1xcbiAgbWFyZ2luLWxlZnQ6IC01cHg7XFxuICAvKiBjZW50ZXIgb24gdGhlIGJvdHRvbSBlZGdlICovXFxuICBib3R0b206IC01cHg7IH1cXG5cXG4vKiBOb3cgSW5kaWNhdG9yXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy10aW1lLWdyaWQgLmZjLW5vdy1pbmRpY2F0b3ItbGluZSB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7IH1cXG5cXG4vKiBhcnJvdyBvbiBheGlzICovXFxuLmZjLXRpbWUtZ3JpZCAuZmMtbm93LWluZGljYXRvci1hcnJvdyB7XFxuICBtYXJnaW4tdG9wOiAtNXB4O1xcbiAgLyogdmVydGljYWxseSBjZW50ZXIgb24gdG9wIGNvb3JkaW5hdGUgKi8gfVxcblxcbi5mYy1sdHIgLmZjLXRpbWUtZ3JpZCAuZmMtbm93LWluZGljYXRvci1hcnJvdyB7XFxuICBsZWZ0OiAwO1xcbiAgLyogdHJpYW5nbGUgcG9pbnRpbmcgcmlnaHQuLi4gKi9cXG4gIGJvcmRlci13aWR0aDogNXB4IDAgNXB4IDZweDtcXG4gIGJvcmRlci10b3AtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG5cXG4uZmMtcnRsIC5mYy10aW1lLWdyaWQgLmZjLW5vdy1pbmRpY2F0b3ItYXJyb3cge1xcbiAgcmlnaHQ6IDA7XFxuICAvKiB0cmlhbmdsZSBwb2ludGluZyBsZWZ0Li4uICovXFxuICBib3JkZXItd2lkdGg6IDVweCA2cHggNXB4IDA7XFxuICBib3JkZXItdG9wLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuXFxuLyogTGlzdCBWaWV3XFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi8qIHBvc3NpYmx5IHJldXNhYmxlICovXFxuLmZjLWV2ZW50LWRvdCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMTBweDtcXG4gIGhlaWdodDogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDsgfVxcblxcbi8qIHZpZXcgd3JhcHBlciAqL1xcbi5mYy1ydGwgLmZjLWxpc3QtdmlldyB7XFxuICBkaXJlY3Rpb246IHJ0bDtcXG4gIC8qIHVubGlrZSBjb3JlIHZpZXdzLCBsZXZlcmFnZSBicm93c2VyIFJUTCAqLyB9XFxuXFxuLmZjLWxpc3QtdmlldyB7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7IH1cXG5cXG4vKiB0YWJsZSByZXNldHMgKi9cXG4uZmMgLmZjLWxpc3QtdGFibGUge1xcbiAgdGFibGUtbGF5b3V0OiBhdXRvO1xcbiAgLyogZm9yIHNocmlua3dyYXBwaW5nIGNlbGwgY29udGVudCAqLyB9XFxuXFxuLmZjLWxpc3QtdGFibGUgdGQge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHggMCAwO1xcbiAgcGFkZGluZzogOHB4IDE0cHg7IH1cXG5cXG4uZmMtbGlzdC10YWJsZSB0cjpmaXJzdC1jaGlsZCB0ZCB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAwOyB9XFxuXFxuLyogZGF5IGhlYWRpbmdzIHdpdGggdGhlIGxpc3QgKi9cXG4uZmMtbGlzdC1oZWFkaW5nIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsgfVxcblxcbi5mYy1saXN0LWhlYWRpbmcgdGQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7IH1cXG5cXG4uZmMtbHRyIC5mYy1saXN0LWhlYWRpbmctbWFpbiB7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbi5mYy1sdHIgLmZjLWxpc3QtaGVhZGluZy1hbHQge1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLmZjLXJ0bCAuZmMtbGlzdC1oZWFkaW5nLW1haW4ge1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLmZjLXJ0bCAuZmMtbGlzdC1oZWFkaW5nLWFsdCB7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbi8qIGV2ZW50IGxpc3QgaXRlbXMgKi9cXG4uZmMtbGlzdC1pdGVtLmZjLWhhcy11cmwge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgLyogd2hvbGUgcm93IHdpbGwgYmUgY2xpY2thYmxlICovIH1cXG5cXG4uZmMtbGlzdC1pdGVtLW1hcmtlcixcXG4uZmMtbGlzdC1pdGVtLXRpbWUge1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHdpZHRoOiAxcHg7IH1cXG5cXG4vKiBtYWtlIHRoZSBkb3QgY2xvc2VyIHRvIHRoZSBldmVudCB0aXRsZSAqL1xcbi5mYy1sdHIgLmZjLWxpc3QtaXRlbS1tYXJrZXIge1xcbiAgcGFkZGluZy1yaWdodDogMDsgfVxcblxcbi5mYy1ydGwgLmZjLWxpc3QtaXRlbS1tYXJrZXIge1xcbiAgcGFkZGluZy1sZWZ0OiAwOyB9XFxuXFxuLmZjLWxpc3QtaXRlbS10aXRsZSBhIHtcXG4gIC8qIGV2ZXJ5IGV2ZW50IHRpdGxlIGNlbGwgaGFzIGFuIDxhPiB0YWcgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGNvbG9yOiBpbmhlcml0OyB9XFxuXFxuLmZjLWxpc3QtaXRlbS10aXRsZSBhW2hyZWZdOmhvdmVyIHtcXG4gIC8qIGhvdmVyIGVmZmVjdCBvbmx5IG9uIHRpdGxlcyB3aXRoIGhyZWZzICovXFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgfVxcblxcbi8qIG1lc3NhZ2Ugd2hlbiBubyBldmVudHMgKi9cXG4uZmMtbGlzdC1lbXB0eS13cmFwMiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3R0b206IDA7IH1cXG5cXG4uZmMtbGlzdC1lbXB0eS13cmFwMSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGRpc3BsYXk6IHRhYmxlOyB9XFxuXFxuLmZjLWxpc3QtZW1wdHkge1xcbiAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG5cXG4uZmMtdW50aGVtZWQgLmZjLWxpc3QtZW1wdHkge1xcbiAgLyogdGhlbWUgd2lsbCBwcm92aWRlIG93biBiYWNrZ3JvdW5kICovXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmNzc1wiKSwgXCJcIik7XG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiZGl2LmNsLWNhbGVuZGFyIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBtYXJnaW46IDFlbSBhdXRvIDFlbSBhdXRvO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U4ZjdmMztcXG4gIHBhZGRpbmc6IDRweCA0cHggNHB4IDRweDtcXG59XFxuXFxuZGl2LmNsLWNhbGVuZGFyIGEuZmMtZXZlbnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwNTUwMDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtc2l6ZTogMC43ZW07XFxufVxcblxcbmRpdi5jbC1jYWxlbmRhciBhLmZjLWV2ZW50LFxcbmRpdi5jbC1jYWxlbmRhciBhLmZjLWV2ZW50OnZpc2l0ZWQsXFxuZGl2LmNsLWNhbGVuZGFyIGEuZmMtZXZlbnQ6bGluayB7XFxuICBjb2xvcjogd2hpdGU7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcblxcbmRpdi5jbC1jYWxlbmRhciBhLmZjLWV2ZW50OmhvdmVyIHtcXG4gIGNvbG9yOiAjZmZjY2NjO1xcbn1cXG5cXG5kaXYuY2wtY2FsZW5kYXIgLmZjLXVudGhlbWVkIC5mYy10b2RheSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFmZmFhO1xcbn1cXG5cXG5kaXYuY2wtY2FsZW5kYXIgaDIge1xcbiAgYm9yZGVyOiAwO1xcbn1cXG5cXG5kaXYuY2wtY2FsZW5kYXIgdGFibGUge1xcbiAgLW1vei1ib3gtc2hhZG93OiBub25lO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuZGl2LmNsLWNhbGVuZGFyIHRhYmxlIHRkLFxcbmRpdi5jbC1jYWxlbmRhciB0YWJsZSB0aCB7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcXG59XFxuXFxuZGl2LmNsLWNhbGVuZGFyIHRhYmxlIHRyOmZpcnN0LWNoaWxkIHRoIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsIi8qIVxuICogRnVsbENhbGVuZGFyIHYzLjkuMFxuICogRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuICogKGMpIDIwMTggQWRhbSBTaGF3XG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIm1vbWVudFwiKSwgcmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJtb21lbnRcIiwgXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRnVsbENhbGVuZGFyXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibW9tZW50XCIpLCByZXF1aXJlKFwianF1ZXJ5XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJGdWxsQ2FsZW5kYXJcIl0gPSBmYWN0b3J5KHJvb3RbXCJtb21lbnRcIl0sIHJvb3RbXCJqUXVlcnlcIl0pO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMzYpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG4vKioqLyB9KSxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qXHJcbmRlcml2ZWQgZnJvbTpcclxuaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC90c2xpYi9ibG9iL3YxLjYuMC90c2xpYi5qc1xyXG5cbm9ubHkgaW5jbHVkZSB0aGUgaGVscGVycyB3ZSBuZWVkLCB0byBrZWVwIGRvd24gZmlsZXNpemVcclxuKi9cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYilcclxuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSlcclxuICAgICAgICAgICAgZFtwXSA9IGJbcF07IH07XHJcbmV4cG9ydHMuX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gR2l2ZW4gdGhlIHNjcm9sbGJhciB3aWR0aHMgb2Ygc29tZSBvdGhlciBjb250YWluZXIsIGNyZWF0ZSBib3JkZXJzL21hcmdpbnMgb24gcm93RWxzIGluIG9yZGVyIHRvIG1hdGNoIHRoZSBsZWZ0XHJcbi8vIGFuZCByaWdodCBzcGFjZSB0aGF0IHdhcyBvZmZzZXQgYnkgdGhlIHNjcm9sbGJhcnMuIEEgMS1waXhlbCBib3JkZXIgZmlyc3QsIHRoZW4gbWFyZ2luIGJleW9uZCB0aGF0LlxyXG5mdW5jdGlvbiBjb21wZW5zYXRlU2Nyb2xsKHJvd0Vscywgc2Nyb2xsYmFyV2lkdGhzKSB7XHJcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQpIHtcclxuICAgICAgICByb3dFbHMuY3NzKHtcclxuICAgICAgICAgICAgJ2JvcmRlci1sZWZ0LXdpZHRoJzogMSxcclxuICAgICAgICAgICAgJ21hcmdpbi1sZWZ0Jzogc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAxXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgcm93RWxzLmNzcyh7XHJcbiAgICAgICAgICAgICdib3JkZXItcmlnaHQtd2lkdGgnOiAxLFxyXG4gICAgICAgICAgICAnbWFyZ2luLXJpZ2h0Jzogc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IC0gMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29tcGVuc2F0ZVNjcm9sbCA9IGNvbXBlbnNhdGVTY3JvbGw7XHJcbi8vIFVuZG9lcyBjb21wZW5zYXRlU2Nyb2xsIGFuZCByZXN0b3JlcyBhbGwgYm9yZGVycy9tYXJnaW5zXHJcbmZ1bmN0aW9uIHVuY29tcGVuc2F0ZVNjcm9sbChyb3dFbHMpIHtcclxuICAgIHJvd0Vscy5jc3Moe1xyXG4gICAgICAgICdtYXJnaW4tbGVmdCc6ICcnLFxyXG4gICAgICAgICdtYXJnaW4tcmlnaHQnOiAnJyxcclxuICAgICAgICAnYm9yZGVyLWxlZnQtd2lkdGgnOiAnJyxcclxuICAgICAgICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogJydcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMudW5jb21wZW5zYXRlU2Nyb2xsID0gdW5jb21wZW5zYXRlU2Nyb2xsO1xyXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcclxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcclxuICAgICQoJ2JvZHknKS5hZGRDbGFzcygnZmMtbm90LWFsbG93ZWQnKTtcclxufVxyXG5leHBvcnRzLmRpc2FibGVDdXJzb3IgPSBkaXNhYmxlQ3Vyc29yO1xyXG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcclxuZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xyXG4gICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlQ3Vyc29yID0gZW5hYmxlQ3Vyc29yO1xyXG4vLyBHaXZlbiBhIHRvdGFsIGF2YWlsYWJsZSBoZWlnaHQgdG8gZmlsbCwgaGF2ZSBgZWxzYCAoZXNzZW50aWFsbHkgY2hpbGQgcm93cykgZXhwYW5kIHRvIGFjY29tb2RhdGUuXHJcbi8vIEJ5IGRlZmF1bHQsIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBzaG9ydGVyIHRoYW4gdGhlIHJlY29tbWVuZGVkIGhlaWdodCBhcmUgZXhwYW5kZWQgdW5pZm9ybWx5LCBub3QgY29uc2lkZXJpbmdcclxuLy8gYW55IG90aGVyIGVscyB0aGF0IGFyZSBhbHJlYWR5IHRvbyB0YWxsLiBpZiBgc2hvdWxkUmVkaXN0cmlidXRlYCBpcyBvbiwgaXQgY29uc2lkZXJzIHRoZXNlIHRhbGwgcm93cyBhbmRcclxuLy8gcmVkdWNlcyB0aGUgYXZhaWxhYmxlIGhlaWdodC5cclxuZnVuY3Rpb24gZGlzdHJpYnV0ZUhlaWdodChlbHMsIGF2YWlsYWJsZUhlaWdodCwgc2hvdWxkUmVkaXN0cmlidXRlKSB7XHJcbiAgICAvLyAqRkxPT1JJTkcgTk9URSo6IHdlIGZsb29yIGluIGNlcnRhaW4gcGxhY2VzIGJlY2F1c2Ugem9vbSBjYW4gZ2l2ZSBpbmFjY3VyYXRlIGZsb2F0aW5nLXBvaW50IGRpbWVuc2lvbnMsXHJcbiAgICAvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIHNob3J0ZXIgdGhhbiB0YWxsZXIsIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMuXHJcbiAgICB2YXIgbWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZWxzLmxlbmd0aCk7IC8vIGZvciBub24tbGFzdCBlbGVtZW50XHJcbiAgICB2YXIgbWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChlbHMubGVuZ3RoIC0gMSkpOyAvLyBmb3IgbGFzdCBlbGVtZW50ICpGTE9PUklORyBOT1RFKlxyXG4gICAgdmFyIGZsZXhFbHMgPSBbXTsgLy8gZWxlbWVudHMgdGhhdCBhcmUgYWxsb3dlZCB0byBleHBhbmQuIGFycmF5IG9mIERPTSBub2Rlc1xyXG4gICAgdmFyIGZsZXhPZmZzZXRzID0gW107IC8vIGFtb3VudCBvZiB2ZXJ0aWNhbCBzcGFjZSBpdCB0YWtlcyB1cFxyXG4gICAgdmFyIGZsZXhIZWlnaHRzID0gW107IC8vIGFjdHVhbCBjc3MgaGVpZ2h0XHJcbiAgICB2YXIgdXNlZEhlaWdodCA9IDA7XHJcbiAgICB1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKTsgLy8gZ2l2ZSBhbGwgZWxlbWVudHMgdGhlaXIgbmF0dXJhbCBoZWlnaHRcclxuICAgIC8vIGZpbmQgZWxlbWVudHMgdGhhdCBhcmUgYmVsb3cgdGhlIHJlY29tbWVuZGVkIGhlaWdodCAoZXhwYW5kYWJsZSkuXHJcbiAgICAvLyBpbXBvcnRhbnQgdG8gcXVlcnkgZm9yIGhlaWdodHMgaW4gYSBzaW5nbGUgZmlyc3QgcGFzcyAodG8gYXZvaWQgcmVmbG93IG9zY2lsbGF0aW9uKS5cclxuICAgIGVscy5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xyXG4gICAgICAgIHZhciBtaW5PZmZzZXQgPSBpID09PSBlbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xyXG4gICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gJChlbCkub3V0ZXJIZWlnaHQodHJ1ZSk7XHJcbiAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcclxuICAgICAgICAgICAgZmxleEVscy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgZmxleE9mZnNldHMucHVzaChuYXR1cmFsT2Zmc2V0KTtcclxuICAgICAgICAgICAgZmxleEhlaWdodHMucHVzaCgkKGVsKS5oZWlnaHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgc3RyZXRjaGVzIHBhc3QgcmVjb21tZW5kZWQgaGVpZ2h0IChub24tZXhwYW5kYWJsZSkuIG1hcmsgdGhlIHNwYWNlIGFzIG9jY3VwaWVkLlxyXG4gICAgICAgICAgICB1c2VkSGVpZ2h0ICs9IG5hdHVyYWxPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyByZWFkanVzdCB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IHRvIG9ubHkgY29uc2lkZXIgdGhlIGhlaWdodCBhdmFpbGFibGUgdG8gbm9uLW1heGVkLW91dCByb3dzLlxyXG4gICAgaWYgKHNob3VsZFJlZGlzdHJpYnV0ZSkge1xyXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCAtPSB1c2VkSGVpZ2h0O1xyXG4gICAgICAgIG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGZsZXhFbHMubGVuZ3RoKTtcclxuICAgICAgICBtaW5PZmZzZXQyID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLSBtaW5PZmZzZXQxICogKGZsZXhFbHMubGVuZ3RoIC0gMSkpOyAvLyAqRkxPT1JJTkcgTk9URSpcclxuICAgIH1cclxuICAgIC8vIGFzc2lnbiBoZWlnaHRzIHRvIGFsbCBleHBhbmRhYmxlIGVsZW1lbnRzXHJcbiAgICAkKGZsZXhFbHMpLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XHJcbiAgICAgICAgdmFyIG1pbk9mZnNldCA9IGkgPT09IGZsZXhFbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xyXG4gICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gZmxleE9mZnNldHNbaV07XHJcbiAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSBmbGV4SGVpZ2h0c1tpXTtcclxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gbWluT2Zmc2V0IC0gKG5hdHVyYWxPZmZzZXQgLSBuYXR1cmFsSGVpZ2h0KTsgLy8gc3VidHJhY3QgdGhlIG1hcmdpbi9wYWRkaW5nXHJcbiAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcclxuICAgICAgICAgICAgJChlbCkuaGVpZ2h0KG5ld0hlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kaXN0cmlidXRlSGVpZ2h0ID0gZGlzdHJpYnV0ZUhlaWdodDtcclxuLy8gVW5kb2VzIGRpc3RydWJ1dGVIZWlnaHQsIHJlc3RvcmluZyBhbGwgZWxzIHRvIHRoZWlyIG5hdHVyYWwgaGVpZ2h0XHJcbmZ1bmN0aW9uIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpIHtcclxuICAgIGVscy5oZWlnaHQoJycpO1xyXG59XHJcbmV4cG9ydHMudW5kaXN0cmlidXRlSGVpZ2h0ID0gdW5kaXN0cmlidXRlSGVpZ2h0O1xyXG4vLyBHaXZlbiBgZWxzYCwgYSBqUXVlcnkgc2V0IG9mIDx0ZD4gY2VsbHMsIGZpbmQgdGhlIGNlbGwgd2l0aCB0aGUgbGFyZ2VzdCBuYXR1cmFsIHdpZHRoIGFuZCBzZXQgdGhlIHdpZHRocyBvZiBhbGwgdGhlXHJcbi8vIGNlbGxzIHRvIGJlIHRoYXQgd2lkdGguXHJcbi8vIFBSRVJFUVVJU0lURTogaWYgeW91IHdhbnQgYSBjZWxsIHRvIHRha2UgdXAgd2lkdGgsIGl0IG5lZWRzIHRvIGhhdmUgYSBzaW5nbGUgaW5uZXIgZWxlbWVudCB3LyBkaXNwbGF5OmlubGluZVxyXG5mdW5jdGlvbiBtYXRjaENlbGxXaWR0aHMoZWxzKSB7XHJcbiAgICB2YXIgbWF4SW5uZXJXaWR0aCA9IDA7XHJcbiAgICBlbHMuZmluZCgnPiAqJykuZWFjaChmdW5jdGlvbiAoaSwgaW5uZXJFbCkge1xyXG4gICAgICAgIHZhciBpbm5lcldpZHRoID0gJChpbm5lckVsKS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgaWYgKGlubmVyV2lkdGggPiBtYXhJbm5lcldpZHRoKSB7XHJcbiAgICAgICAgICAgIG1heElubmVyV2lkdGggPSBpbm5lcldpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbWF4SW5uZXJXaWR0aCsrOyAvLyBzb21ldGltZXMgbm90IGFjY3VyYXRlIG9mIHdpZHRoIHRoZSB0ZXh0IG5lZWRzIHRvIHN0YXkgb24gb25lIGxpbmUuIGluc3VyYW5jZVxyXG4gICAgZWxzLndpZHRoKG1heElubmVyV2lkdGgpO1xyXG4gICAgcmV0dXJuIG1heElubmVyV2lkdGg7XHJcbn1cclxuZXhwb3J0cy5tYXRjaENlbGxXaWR0aHMgPSBtYXRjaENlbGxXaWR0aHM7XHJcbi8vIEdpdmVuIG9uZSBlbGVtZW50IHRoYXQgcmVzaWRlcyBpbnNpZGUgYW5vdGhlcixcclxuLy8gU3VidHJhY3RzIHRoZSBoZWlnaHQgb2YgdGhlIGlubmVyIGVsZW1lbnQgZnJvbSB0aGUgb3V0ZXIgZWxlbWVudC5cclxuZnVuY3Rpb24gc3VidHJhY3RJbm5lckVsSGVpZ2h0KG91dGVyRWwsIGlubmVyRWwpIHtcclxuICAgIHZhciBib3RoID0gb3V0ZXJFbC5hZGQoaW5uZXJFbCk7XHJcbiAgICB2YXIgZGlmZjtcclxuICAgIC8vIGVmZmluJyBJRTgvOS8xMC8xMSBzb21ldGltZXMgcmV0dXJucyAwIGZvciBkaW1lbnNpb25zLiB0aGlzIHdlaXJkIGhhY2sgd2FzIHRoZSBvbmx5IHRoaW5nIHRoYXQgd29ya2VkXHJcbiAgICBib3RoLmNzcyh7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgbGVmdDogLTEgLy8gZW5zdXJlIHJlZmxvdyBpbiBjYXNlIHRoZSBlbCB3YXMgYWxyZWFkeSByZWxhdGl2ZS4gbmVnYXRpdmUgaXMgbGVzcyBsaWtlbHkgdG8gY2F1c2UgbmV3IHNjcm9sbFxyXG4gICAgfSk7XHJcbiAgICBkaWZmID0gb3V0ZXJFbC5vdXRlckhlaWdodCgpIC0gaW5uZXJFbC5vdXRlckhlaWdodCgpOyAvLyBncmFiIHRoZSBkaW1lbnNpb25zXHJcbiAgICBib3RoLmNzcyh7IHBvc2l0aW9uOiAnJywgbGVmdDogJycgfSk7IC8vIHVuZG8gaGFja1xyXG4gICAgcmV0dXJuIGRpZmY7XHJcbn1cclxuZXhwb3J0cy5zdWJ0cmFjdElubmVyRWxIZWlnaHQgPSBzdWJ0cmFjdElubmVyRWxIZWlnaHQ7XHJcbi8qIEVsZW1lbnQgR2VvbSBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi8xLjExLjAvdWkvY29yZS5qcyNMNTFcclxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsKSB7XHJcbiAgICB2YXIgcG9zaXRpb24gPSBlbC5jc3MoJ3Bvc2l0aW9uJyk7XHJcbiAgICB2YXIgc2Nyb2xsUGFyZW50ID0gZWwucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9ICQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QocGFyZW50LmNzcygnb3ZlcmZsb3cnKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXknKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXgnKSk7XHJcbiAgICB9KS5lcSgwKTtcclxuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoZWxbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XHJcbn1cclxuZXhwb3J0cy5nZXRTY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQ7XHJcbi8vIFF1ZXJpZXMgdGhlIG91dGVyIGJvdW5kaW5nIGFyZWEgb2YgYSBqUXVlcnkgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuZnVuY3Rpb24gZ2V0T3V0ZXJSZWN0KGVsLCBvcmlnaW4pIHtcclxuICAgIHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcclxuICAgIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcclxuICAgIHZhciB0b3AgPSBvZmZzZXQudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsLm91dGVyV2lkdGgoKSxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsLm91dGVySGVpZ2h0KClcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRPdXRlclJlY3QgPSBnZXRPdXRlclJlY3Q7XHJcbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3Njcm9sbGJhcnMgb2YgYSBqUXVlcnkgZWxlbWVudC4gRG9lcyBub3QgZ28gd2l0aGluIHRoZSBwYWRkaW5nLlxyXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cclxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxyXG4vLyBXQVJOSU5HOiBnaXZlbiBlbGVtZW50IGNhbid0IGhhdmUgYm9yZGVyc1xyXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXHJcbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIG9yaWdpbikge1xyXG4gICAgdmFyIG9mZnNldCA9IGVsLm9mZnNldCgpO1xyXG4gICAgdmFyIHNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocyhlbCk7XHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcclxuICAgIHZhciB0b3AgPSBvZmZzZXQudG9wICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItdG9wLXdpZHRoJykgKyBzY3JvbGxiYXJXaWR0aHMudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsWzBdLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGJvdHRvbTogdG9wICsgZWxbMF0uY2xpZW50SGVpZ2h0IC8vIGNsaWVudEhlaWdodCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBOT1Qgc2Nyb2xsYmFyc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0O1xyXG4vLyBRdWVyaWVzIHRoZSBhcmVhIHdpdGhpbiB0aGUgbWFyZ2luL2JvcmRlci9wYWRkaW5nIG9mIGEgalF1ZXJ5IGVsZW1lbnQuIEFzc3VtZWQgbm90IHRvIGhhdmUgc2Nyb2xsYmFycy5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QoZWwsIG9yaWdpbikge1xyXG4gICAgdmFyIG9mZnNldCA9IGVsLm9mZnNldCgpOyAvLyBqdXN0IG91dHNpZGUgb2YgYm9yZGVyLCBtYXJnaW4gbm90IGluY2x1ZGVkXHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLWxlZnQnKSAtXHJcbiAgICAgICAgKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XHJcbiAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLXRvcCcpIC1cclxuICAgICAgICAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgZWwud2lkdGgoKSxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsLmhlaWdodCgpXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0Q29udGVudFJlY3QgPSBnZXRDb250ZW50UmVjdDtcclxuLy8gUmV0dXJucyB0aGUgY29tcHV0ZWQgbGVmdC9yaWdodC90b3AvYm90dG9tIHNjcm9sbGJhciB3aWR0aHMgZm9yIHRoZSBnaXZlbiBqUXVlcnkgZWxlbWVudC5cclxuLy8gV0FSTklORzogZ2l2ZW4gZWxlbWVudCBjYW4ndCBoYXZlIGJvcmRlcnMgKHdoaWNoIHdpbGwgY2F1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHRvIGJlIGxhcmdlcikuXHJcbi8vIE5PVEU6IHNob3VsZCB1c2UgY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCB2ZXJ5IHVucmVsaWFibGUgY3Jvc3MtYnJvd3Nlci5cclxuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKGVsKSB7XHJcbiAgICB2YXIgbGVmdFJpZ2h0V2lkdGggPSBlbFswXS5vZmZzZXRXaWR0aCAtIGVsWzBdLmNsaWVudFdpZHRoO1xyXG4gICAgdmFyIGJvdHRvbVdpZHRoID0gZWxbMF0ub2Zmc2V0SGVpZ2h0IC0gZWxbMF0uY2xpZW50SGVpZ2h0O1xyXG4gICAgdmFyIHdpZHRocztcclxuICAgIGxlZnRSaWdodFdpZHRoID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChsZWZ0UmlnaHRXaWR0aCk7XHJcbiAgICBib3R0b21XaWR0aCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgoYm90dG9tV2lkdGgpO1xyXG4gICAgd2lkdGhzID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IGJvdHRvbVdpZHRoIH07XHJcbiAgICBpZiAoZ2V0SXNMZWZ0UnRsU2Nyb2xsYmFycygpICYmIGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSB7XHJcbiAgICAgICAgd2lkdGhzLmxlZnQgPSBsZWZ0UmlnaHRXaWR0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpZHRocy5yaWdodCA9IGxlZnRSaWdodFdpZHRoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdpZHRocztcclxufVxyXG5leHBvcnRzLmdldFNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocztcclxuLy8gVGhlIHNjcm9sbGJhciB3aWR0aCBjb21wdXRhdGlvbnMgaW4gZ2V0U2Nyb2xsYmFyV2lkdGhzIGFyZSBzb21ldGltZXMgZmxhd2VkIHdoZW4gaXQgY29tZXMgdG9cclxuLy8gcmV0aW5hIGRpc3BsYXlzLCByb3VuZGluZywgYW5kIElFMTEuIE1hc3NhZ2UgdGhlbSBpbnRvIGEgdXNhYmxlIHZhbHVlLlxyXG5mdW5jdGlvbiBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKHdpZHRoKSB7XHJcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTsgLy8gbm8gbmVnYXRpdmVzXHJcbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG59XHJcbi8vIExvZ2ljIGZvciBkZXRlcm1pbmluZyBpZiwgd2hlbiB0aGUgZWxlbWVudCBpcyByaWdodC10by1sZWZ0LCB0aGUgc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgc2lkZVxyXG52YXIgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgaWYgKF9pc0xlZnRSdGxTY3JvbGxiYXJzID09PSBudWxsKSB7XHJcbiAgICAgICAgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBjb21wdXRlSXNMZWZ0UnRsU2Nyb2xsYmFycygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc0xlZnRSdGxTY3JvbGxiYXJzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgdmFyIGVsID0gJCgnPGRpdj48ZGl2Lz48L2Rpdj4nKVxyXG4gICAgICAgIC5jc3Moe1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogLTEwMDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXHJcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJ1xyXG4gICAgfSlcclxuICAgICAgICAuYXBwZW5kVG8oJ2JvZHknKTtcclxuICAgIHZhciBpbm5lckVsID0gZWwuY2hpbGRyZW4oKTtcclxuICAgIHZhciByZXMgPSBpbm5lckVsLm9mZnNldCgpLmxlZnQgPiBlbC5vZmZzZXQoKS5sZWZ0OyAvLyBpcyB0aGUgaW5uZXIgZGl2IHNoaWZ0ZWQgdG8gYWNjb21tb2RhdGUgYSBsZWZ0IHNjcm9sbGJhcj9cclxuICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vLyBSZXRyaWV2ZXMgYSBqUXVlcnkgZWxlbWVudCdzIGNvbXB1dGVkIENTUyB2YWx1ZSBhcyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cclxuLy8gSWYgdGhlIHF1ZXJpZWQgdmFsdWUgaXMgbm9uLW51bWVyaWMgKGV4OiBJRSBjYW4gcmV0dXJuIFwibWVkaXVtXCIgZm9yIGJvcmRlciB3aWR0aCksIHdpbGwganVzdCByZXR1cm4gemVyby5cclxuZnVuY3Rpb24gZ2V0Q3NzRmxvYXQoZWwsIHByb3ApIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KGVsLmNzcyhwcm9wKSkgfHwgMDtcclxufVxyXG4vKiBNb3VzZSAvIFRvdWNoIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gUmV0dXJucyBhIGJvb2xlYW4gd2hldGhlciB0aGlzIHdhcyBhIGxlZnQgbW91c2UgY2xpY2sgYW5kIG5vIGN0cmwga2V5ICh3aGljaCBtZWFucyByaWdodCBjbGljayBvbiBNYWMpXHJcbmZ1bmN0aW9uIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSB7XHJcbiAgICByZXR1cm4gZXYud2hpY2ggPT09IDEgJiYgIWV2LmN0cmxLZXk7XHJcbn1cclxuZXhwb3J0cy5pc1ByaW1hcnlNb3VzZUJ1dHRvbiA9IGlzUHJpbWFyeU1vdXNlQnV0dG9uO1xyXG5mdW5jdGlvbiBnZXRFdlgoZXYpIHtcclxuICAgIHZhciB0b3VjaGVzID0gZXYub3JpZ2luYWxFdmVudC50b3VjaGVzO1xyXG4gICAgLy8gb24gbW9iaWxlIEZGLCBwYWdlWCBmb3IgdG91Y2ggZXZlbnRzIGlzIHByZXNlbnQsIGJ1dCBpbmNvcnJlY3QsXHJcbiAgICAvLyBzbywgbG9vayBhdCB0b3VjaCBjb29yZGluYXRlcyBmaXJzdC5cclxuICAgIGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXYucGFnZVg7XHJcbn1cclxuZXhwb3J0cy5nZXRFdlggPSBnZXRFdlg7XHJcbmZ1bmN0aW9uIGdldEV2WShldikge1xyXG4gICAgdmFyIHRvdWNoZXMgPSBldi5vcmlnaW5hbEV2ZW50LnRvdWNoZXM7XHJcbiAgICAvLyBvbiBtb2JpbGUgRkYsIHBhZ2VYIGZvciB0b3VjaCBldmVudHMgaXMgcHJlc2VudCwgYnV0IGluY29ycmVjdCxcclxuICAgIC8vIHNvLCBsb29rIGF0IHRvdWNoIGNvb3JkaW5hdGVzIGZpcnN0LlxyXG4gICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdG91Y2hlc1swXS5wYWdlWTtcclxuICAgIH1cclxuICAgIHJldHVybiBldi5wYWdlWTtcclxufVxyXG5leHBvcnRzLmdldEV2WSA9IGdldEV2WTtcclxuZnVuY3Rpb24gZ2V0RXZJc1RvdWNoKGV2KSB7XHJcbiAgICByZXR1cm4gL150b3VjaC8udGVzdChldi50eXBlKTtcclxufVxyXG5leHBvcnRzLmdldEV2SXNUb3VjaCA9IGdldEV2SXNUb3VjaDtcclxuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xyXG4gICAgZWwuYWRkQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpXHJcbiAgICAgICAgLm9uKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxufVxyXG5leHBvcnRzLnByZXZlbnRTZWxlY3Rpb24gPSBwcmV2ZW50U2VsZWN0aW9uO1xyXG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xyXG4gICAgZWwucmVtb3ZlQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpXHJcbiAgICAgICAgLm9mZignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuZXhwb3J0cy5hbGxvd1NlbGVjdGlvbiA9IGFsbG93U2VsZWN0aW9uO1xyXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cclxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXYpIHtcclxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbn1cclxuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xyXG4vKiBHZW5lcmFsIEdlb21ldHJ5IFV0aWxzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxyXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcclxuICAgIHZhciByZXMgPSB7XHJcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXHJcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXHJcbiAgICAgICAgdG9wOiBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCksXHJcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSlcclxuICAgIH07XHJcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuaW50ZXJzZWN0UmVjdHMgPSBpbnRlcnNlY3RSZWN0cztcclxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxyXG5mdW5jdGlvbiBjb25zdHJhaW5Qb2ludChwb2ludCwgcmVjdCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcclxuICAgICAgICB0b3A6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LnRvcCwgcmVjdC50b3ApLCByZWN0LmJvdHRvbSlcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jb25zdHJhaW5Qb2ludCA9IGNvbnN0cmFpblBvaW50O1xyXG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcclxuZnVuY3Rpb24gZ2V0UmVjdENlbnRlcihyZWN0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXHJcbiAgICAgICAgdG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0UmVjdENlbnRlciA9IGdldFJlY3RDZW50ZXI7XHJcbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxyXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXHJcbiAgICAgICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRpZmZQb2ludHMgPSBkaWZmUG9pbnRzO1xyXG4vKiBPYmplY3QgT3JkZXJpbmcgYnkgRmllbGRcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xyXG4gICAgdmFyIHNwZWNzID0gW107XHJcbiAgICB2YXIgdG9rZW5zID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICB0b2tlbnMgPSBpbnB1dDtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cclxuICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxyXG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzcGVjcztcclxufVxyXG5leHBvcnRzLnBhcnNlRmllbGRTcGVjcyA9IHBhcnNlRmllbGRTcGVjcztcclxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzLCBvYmoxZmFsbGJhY2ssIG9iajJmYWxsYmFjaykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgY21wO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMSwgb2JqMiwgZmllbGRTcGVjc1tpXSwgb2JqMWZhbGxiYWNrLCBvYmoyZmFsbGJhY2spO1xyXG4gICAgICAgIGlmIChjbXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSBjb21wYXJlQnlGaWVsZFNwZWNzO1xyXG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMSwgb2JqMiwgZmllbGRTcGVjLCBvYmoxZmFsbGJhY2ssIG9iajJmYWxsYmFjaykge1xyXG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajEsIG9iajIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHZhbDEgPSBvYmoxW2ZpZWxkU3BlYy5maWVsZF07XHJcbiAgICB2YXIgdmFsMiA9IG9iajJbZmllbGRTcGVjLmZpZWxkXTtcclxuICAgIGlmICh2YWwxID09IG51bGwgJiYgb2JqMWZhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFsMSA9IG9iajFmYWxsYmFja1tmaWVsZFNwZWMuZmllbGRdO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbDIgPT0gbnVsbCAmJiBvYmoyZmFsbGJhY2spIHtcclxuICAgICAgICB2YWwyID0gb2JqMmZhbGxiYWNrW2ZpZWxkU3BlYy5maWVsZF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmxleGlibGVDb21wYXJlKHZhbDEsIHZhbDIpICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlYyA9IGNvbXBhcmVCeUZpZWxkU3BlYztcclxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcclxuICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChhID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGlmICgkLnR5cGUoYSkgPT09ICdzdHJpbmcnIHx8ICQudHlwZShiKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IGZsZXhpYmxlQ29tcGFyZTtcclxuLyogRGF0ZSBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydHMuZGF5SURzID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcclxuZXhwb3J0cy51bml0c0Rlc2MgPSBbJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107IC8vIGRlc2NlbmRpbmdcclxuLy8gRGlmZnMgdGhlIHR3byBtb21lbnRzIGludG8gYSBEdXJhdGlvbiB3aGVyZSBmdWxsLWRheXMgYXJlIHJlY29yZGVkIGZpcnN0LCB0aGVuIHRoZSByZW1haW5pbmcgdGltZS5cclxuLy8gTW9tZW50cyB3aWxsIGhhdmUgdGhlaXIgdGltZXpvbmVzIG5vcm1hbGl6ZWQuXHJcbmZ1bmN0aW9uIGRpZmZEYXlUaW1lKGEsIGIpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xyXG4gICAgICAgIGRheXM6IGEuY2xvbmUoKS5zdHJpcFRpbWUoKS5kaWZmKGIuY2xvbmUoKS5zdHJpcFRpbWUoKSwgJ2RheXMnKSxcclxuICAgICAgICBtczogYS50aW1lKCkgLSBiLnRpbWUoKSAvLyB0aW1lLW9mLWRheSBmcm9tIGRheSBzdGFydC4gZGlzcmVnYXJkcyB0aW1lem9uZVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kaWZmRGF5VGltZSA9IGRpZmZEYXlUaW1lO1xyXG4vLyBEaWZmcyB0aGUgdHdvIG1vbWVudHMgdmlhIHRoZWlyIHN0YXJ0LW9mLWRheSAocmVnYXJkbGVzcyBvZiB0aW1lem9uZSkuIFByb2R1Y2VzIHdob2xlLWRheSBkdXJhdGlvbnMuXHJcbmZ1bmN0aW9uIGRpZmZEYXkoYSwgYikge1xyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpZmZEYXkgPSBkaWZmRGF5O1xyXG4vLyBEaWZmcyB0d28gbW9tZW50cywgcHJvZHVjaW5nIGEgZHVyYXRpb24sIG1hZGUgb2YgYSB3aG9sZS11bml0LWluY3JlbWVudCBvZiB0aGUgZ2l2ZW4gdW5pdC4gVXNlcyByb3VuZGluZy5cclxuZnVuY3Rpb24gZGlmZkJ5VW5pdChhLCBiLCB1bml0KSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKE1hdGgucm91bmQoYS5kaWZmKGIsIHVuaXQsIHRydWUpKSwgLy8gcmV0dXJuRmxvYXQ9dHJ1ZVxyXG4gICAgdW5pdCk7XHJcbn1cclxuZXhwb3J0cy5kaWZmQnlVbml0ID0gZGlmZkJ5VW5pdDtcclxuLy8gQ29tcHV0ZXMgdGhlIHVuaXQgbmFtZSBvZiB0aGUgbGFyZ2VzdCB3aG9sZS11bml0IHBlcmlvZCBvZiB0aW1lLlxyXG4vLyBGb3IgZXhhbXBsZSwgNDggaG91cnMgd2lsbCBiZSBcImRheXNcIiB3aGVyZWFzIDQ5IGhvdXJzIHdpbGwgYmUgXCJob3Vyc1wiLlxyXG4vLyBBY2NlcHRzIHN0YXJ0L2VuZCwgYSByYW5nZSBvYmplY3QsIG9yIGFuIG9yaWdpbmFsIGR1cmF0aW9uIG9iamVjdC5cclxuZnVuY3Rpb24gY29tcHV0ZUdyZWF0ZXN0VW5pdChzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB1bml0O1xyXG4gICAgdmFyIHZhbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLnVuaXRzRGVzYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHVuaXQgPSBleHBvcnRzLnVuaXRzRGVzY1tpXTtcclxuICAgICAgICB2YWwgPSBjb21wdXRlUmFuZ2VBcyh1bml0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAodmFsID49IDEgJiYgaXNJbnQodmFsKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5pdDsgLy8gd2lsbCBiZSBcIm1pbGxpc2Vjb25kc1wiIGlmIG5vdGhpbmcgZWxzZSBtYXRjaGVzXHJcbn1cclxuZXhwb3J0cy5jb21wdXRlR3JlYXRlc3RVbml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdDtcclxuLy8gbGlrZSBjb21wdXRlR3JlYXRlc3RVbml0LCBidXQgaGFzIHNwZWNpYWwgYWJpbGl0aWVzIHRvIGludGVycHJldCB0aGUgc291cmNlIGlucHV0IGZvciBjbHVlc1xyXG5mdW5jdGlvbiBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZHVyYXRpb24sIGR1cmF0aW9uSW5wdXQpIHtcclxuICAgIHZhciB1bml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdChkdXJhdGlvbik7XHJcbiAgICAvLyBwcmV2ZW50IGRheXM6NyBmcm9tIGJlaW5nIGludGVycHJldGVkIGFzIGEgd2Vla1xyXG4gICAgaWYgKHVuaXQgPT09ICd3ZWVrJyAmJiB0eXBlb2YgZHVyYXRpb25JbnB1dCA9PT0gJ29iamVjdCcgJiYgZHVyYXRpb25JbnB1dC5kYXlzKSB7XHJcbiAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuaXQ7XHJcbn1cclxuZXhwb3J0cy5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQgPSBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQ7XHJcbi8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgdW5pdHMgKGxpa2UgXCJob3Vyc1wiKSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXHJcbi8vIFJhbmdlIGNhbiBiZSBhIHtzdGFydCxlbmR9IG9iamVjdCwgc2VwYXJhdGUgc3RhcnQvZW5kIGFyZ3MsIG9yIGEgRHVyYXRpb24uXHJcbi8vIFJlc3VsdHMgYXJlIGJhc2VkIG9uIE1vbWVudCdzIC5hcygpIGFuZCAuZGlmZigpIG1ldGhvZHMsIHNvIHJlc3VsdHMgY2FuIGRlcGVuZCBvbiBpbnRlcm5hbCBoYW5kbGluZ1xyXG4vLyBvZiBtb250aC1kaWZmaW5nIGxvZ2ljICh3aGljaCB0ZW5kcyB0byB2YXJ5IGZyb20gdmVyc2lvbiB0byB2ZXJzaW9uKS5cclxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlQXModW5pdCwgc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKGVuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHN0YXJ0KSkge1xyXG4gICAgICAgIHJldHVybiBzdGFydC5hcyh1bml0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzdGFydC5lbmQuZGlmZihzdGFydC5zdGFydCwgdW5pdCwgdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIGEgcmFuZ2UgKHNwZWNpZmllZCBieSBhIHN0YXJ0L2VuZCBwYXJhbXMpIGJ5IGEgZHVyYXRpb25cclxuZnVuY3Rpb24gZGl2aWRlUmFuZ2VCeUR1cmF0aW9uKHN0YXJ0LCBlbmQsIGR1cikge1xyXG4gICAgdmFyIG1vbnRocztcclxuICAgIGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xyXG4gICAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyO1xyXG4gICAgfVxyXG4gICAgbW9udGhzID0gZHVyLmFzTW9udGhzKCk7XHJcbiAgICBpZiAoTWF0aC5hYnMobW9udGhzKSA+PSAxICYmIGlzSW50KG1vbnRocykpIHtcclxuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsICdtb250aHMnLCB0cnVlKSAvIG1vbnRocztcclxuICAgIH1cclxuICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgJ2RheXMnLCB0cnVlKSAvIGR1ci5hc0RheXMoKTtcclxufVxyXG5leHBvcnRzLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IGRpdmlkZVJhbmdlQnlEdXJhdGlvbjtcclxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIG9uZSBkdXJhdGlvbiBieSBhbm90aGVyXHJcbmZ1bmN0aW9uIGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihkdXIxLCBkdXIyKSB7XHJcbiAgICB2YXIgbW9udGhzMTtcclxuICAgIHZhciBtb250aHMyO1xyXG4gICAgaWYgKGR1cmF0aW9uSGFzVGltZShkdXIxKSB8fCBkdXJhdGlvbkhhc1RpbWUoZHVyMikpIHtcclxuICAgICAgICByZXR1cm4gZHVyMSAvIGR1cjI7XHJcbiAgICB9XHJcbiAgICBtb250aHMxID0gZHVyMS5hc01vbnRocygpO1xyXG4gICAgbW9udGhzMiA9IGR1cjIuYXNNb250aHMoKTtcclxuICAgIGlmIChNYXRoLmFicyhtb250aHMxKSA+PSAxICYmIGlzSW50KG1vbnRoczEpICYmXHJcbiAgICAgICAgTWF0aC5hYnMobW9udGhzMikgPj0gMSAmJiBpc0ludChtb250aHMyKSkge1xyXG4gICAgICAgIHJldHVybiBtb250aHMxIC8gbW9udGhzMjtcclxuICAgIH1cclxuICAgIHJldHVybiBkdXIxLmFzRGF5cygpIC8gZHVyMi5hc0RheXMoKTtcclxufVxyXG5leHBvcnRzLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbiA9IGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbjtcclxuLy8gSW50ZWxsaWdlbnRseSBtdWx0aXBsaWVzIGEgZHVyYXRpb24gYnkgYSBudW1iZXJcclxuZnVuY3Rpb24gbXVsdGlwbHlEdXJhdGlvbihkdXIsIG4pIHtcclxuICAgIHZhciBtb250aHM7XHJcbiAgICBpZiAoZHVyYXRpb25IYXNUaW1lKGR1cikpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKGR1ciAqIG4pO1xyXG4gICAgfVxyXG4gICAgbW9udGhzID0gZHVyLmFzTW9udGhzKCk7XHJcbiAgICBpZiAoTWF0aC5hYnMobW9udGhzKSA+PSAxICYmIGlzSW50KG1vbnRocykpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgbW9udGhzOiBtb250aHMgKiBuIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IGR1ci5hc0RheXMoKSAqIG4gfSk7XHJcbn1cclxuZXhwb3J0cy5tdWx0aXBseUR1cmF0aW9uID0gbXVsdGlwbHlEdXJhdGlvbjtcclxuLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgZ2l2ZW4gZHVyYXRpb24gaGFzIGFueSB0aW1lIHBhcnRzIChob3Vycy9taW51dGVzL3NlY29uZHMvbXMpXHJcbmZ1bmN0aW9uIGR1cmF0aW9uSGFzVGltZShkdXIpIHtcclxuICAgIHJldHVybiBCb29sZWFuKGR1ci5ob3VycygpIHx8IGR1ci5taW51dGVzKCkgfHwgZHVyLnNlY29uZHMoKSB8fCBkdXIubWlsbGlzZWNvbmRzKCkpO1xyXG59XHJcbmV4cG9ydHMuZHVyYXRpb25IYXNUaW1lID0gZHVyYXRpb25IYXNUaW1lO1xyXG5mdW5jdGlvbiBpc05hdGl2ZURhdGUoaW5wdXQpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHwgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xyXG59XHJcbmV4cG9ydHMuaXNOYXRpdmVEYXRlID0gaXNOYXRpdmVEYXRlO1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSBnaXZlbiBpbnB1dCBpcyBhIHRpbWUgc3RyaW5nLCBsaWtlIFwiMDY6NDA6MDBcIiBvciBcIjA2OjAwXCJcclxuZnVuY3Rpb24gaXNUaW1lU3RyaW5nKHN0cikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgL15cXGQrXFw6XFxkKyg/OlxcOlxcZCtcXC4/KD86XFxkezN9KT8pPyQvLnRlc3Qoc3RyKTtcclxufVxyXG5leHBvcnRzLmlzVGltZVN0cmluZyA9IGlzVGltZVN0cmluZztcclxuLyogTG9nZ2luZyBhbmQgRGVidWdcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmZ1bmN0aW9uIGxvZygpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XHJcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xyXG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmxvZyA9IGxvZztcclxuZnVuY3Rpb24gd2FybigpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XHJcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGxvZy5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLndhcm4gPSB3YXJuO1xyXG4vKiBHZW5lcmFsIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIGhhc093blByb3BNZXRob2QgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcclxuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXHJcbi8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHMpIHtcclxuICAgIHZhciBkZXN0ID0ge307XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBuYW1lO1xyXG4gICAgdmFyIGNvbXBsZXhPYmpzO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgdmFsO1xyXG4gICAgdmFyIHByb3BzO1xyXG4gICAgaWYgKGNvbXBsZXhQcm9wcykge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV4UHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbmFtZSA9IGNvbXBsZXhQcm9wc1tpXTtcclxuICAgICAgICAgICAgY29tcGxleE9ianMgPSBbXTtcclxuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxyXG4gICAgICAgICAgICBmb3IgKGogPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcHJvcE9ianNbal1bbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxyXG4gICAgZm9yIChpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBwcm9wcyA9IHByb3BPYmpzW2ldO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIGRlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gcHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdDtcclxufVxyXG5leHBvcnRzLm1lcmdlUHJvcHMgPSBtZXJnZVByb3BzO1xyXG5mdW5jdGlvbiBjb3B5T3duUHJvcHMoc3JjLCBkZXN0KSB7XHJcbiAgICBmb3IgKHZhciBuYW1lXzEgaW4gc3JjKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3Aoc3JjLCBuYW1lXzEpKSB7XHJcbiAgICAgICAgICAgIGRlc3RbbmFtZV8xXSA9IHNyY1tuYW1lXzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvcHlPd25Qcm9wcyA9IGNvcHlPd25Qcm9wcztcclxuZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIG5hbWUpIHtcclxuICAgIHJldHVybiBoYXNPd25Qcm9wTWV0aG9kLmNhbGwob2JqLCBuYW1lKTtcclxufVxyXG5leHBvcnRzLmhhc093blByb3AgPSBoYXNPd25Qcm9wO1xyXG5mdW5jdGlvbiBhcHBseUFsbChmdW5jdGlvbnMsIHRoaXNPYmosIGFyZ3MpIHtcclxuICAgIGlmICgkLmlzRnVuY3Rpb24oZnVuY3Rpb25zKSkge1xyXG4gICAgICAgIGZ1bmN0aW9ucyA9IFtmdW5jdGlvbnNdO1xyXG4gICAgfVxyXG4gICAgaWYgKGZ1bmN0aW9ucykge1xyXG4gICAgICAgIHZhciBpID0gdm9pZCAwO1xyXG4gICAgICAgIHZhciByZXQgPSB2b2lkIDA7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXQgPSBmdW5jdGlvbnNbaV0uYXBwbHkodGhpc09iaiwgYXJncykgfHwgcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYXBwbHlBbGwgPSBhcHBseUFsbDtcclxuZnVuY3Rpb24gcmVtb3ZlTWF0Y2hpbmcoYXJyYXksIHRlc3RGdW5jKSB7XHJcbiAgICB2YXIgcmVtb3ZlQ250ID0gMDtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHRlc3RGdW5jKGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUNudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdmVDbnQ7XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVNYXRjaGluZyA9IHJlbW92ZU1hdGNoaW5nO1xyXG5mdW5jdGlvbiByZW1vdmVFeGFjdChhcnJheSwgZXhhY3RWYWwpIHtcclxuICAgIHZhciByZW1vdmVDbnQgPSAwO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgcmVtb3ZlQ250Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZUNudDtcclxufVxyXG5leHBvcnRzLnJlbW92ZUV4YWN0ID0gcmVtb3ZlRXhhY3Q7XHJcbmZ1bmN0aW9uIGlzQXJyYXlzRXF1YWwoYTAsIGExKSB7XHJcbiAgICB2YXIgbGVuID0gYTAubGVuZ3RoO1xyXG4gICAgdmFyIGk7XHJcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuICE9PSBhMS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYTBbaV0gIT09IGExW2ldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5leHBvcnRzLmlzQXJyYXlzRXF1YWwgPSBpc0FycmF5c0VxdWFsO1xyXG5mdW5jdGlvbiBmaXJzdERlZmluZWQoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmdzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmZpcnN0RGVmaW5lZCA9IGZpcnN0RGVmaW5lZDtcclxuZnVuY3Rpb24gaHRtbEVzY2FwZShzKSB7XHJcbiAgICByZXR1cm4gKHMgKyAnJykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcclxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXHJcbiAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpO1xyXG59XHJcbmV4cG9ydHMuaHRtbEVzY2FwZSA9IGh0bWxFc2NhcGU7XHJcbmZ1bmN0aW9uIHN0cmlwSHRtbEVudGl0aWVzKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyYuKj87L2csICcnKTtcclxufVxyXG5leHBvcnRzLnN0cmlwSHRtbEVudGl0aWVzID0gc3RyaXBIdG1sRW50aXRpZXM7XHJcbi8vIEdpdmVuIGEgaGFzaCBvZiBDU1MgcHJvcGVydGllcywgcmV0dXJucyBhIHN0cmluZyBvZiBDU1MuXHJcbi8vIFVzZXMgcHJvcGVydHkgbmFtZXMgYXMtaXMgKG5vIGNhbWVsLWNhc2UgY29udmVyc2lvbikuIFdpbGwgbm90IG1ha2Ugc3RhdGVtZW50cyBmb3IgbnVsbC91bmRlZmluZWQgdmFsdWVzLlxyXG5mdW5jdGlvbiBjc3NUb1N0cihjc3NQcm9wcykge1xyXG4gICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcclxuICAgICQuZWFjaChjc3NQcm9wcywgZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmFtZSArICc6JyArIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RhdGVtZW50cy5qb2luKCc7Jyk7XHJcbn1cclxuZXhwb3J0cy5jc3NUb1N0ciA9IGNzc1RvU3RyO1xyXG4vLyBHaXZlbiBhbiBvYmplY3QgaGFzaCBvZiBIVE1MIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMsXHJcbi8vIGdlbmVyYXRlcyBhIHN0cmluZyB0aGF0IGNhbiBiZSBpbmplY3RlZCBiZXR3ZWVuIDwgPiBpbiBIVE1MXHJcbmZ1bmN0aW9uIGF0dHJzVG9TdHIoYXR0cnMpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgJC5lYWNoKGF0dHJzLCBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2gobmFtZSArICc9XCInICsgaHRtbEVzY2FwZSh2YWwpICsgJ1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcGFydHMuam9pbignICcpO1xyXG59XHJcbmV4cG9ydHMuYXR0cnNUb1N0ciA9IGF0dHJzVG9TdHI7XHJcbmZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHIpIHtcclxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn1cclxuZXhwb3J0cy5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIgPSBjYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XHJcbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVOdW1iZXJzID0gY29tcGFyZU51bWJlcnM7XHJcbmZ1bmN0aW9uIGlzSW50KG4pIHtcclxuICAgIHJldHVybiBuICUgMSA9PT0gMDtcclxufVxyXG5leHBvcnRzLmlzSW50ID0gaXNJbnQ7XHJcbi8vIFJldHVybnMgYSBtZXRob2QgYm91bmQgdG8gdGhlIGdpdmVuIG9iamVjdCBjb250ZXh0LlxyXG4vLyBKdXN0IGxpa2Ugb25lIG9mIHRoZSBqUXVlcnkucHJveHkgc2lnbmF0dXJlcywgYnV0IHdpdGhvdXQgdGhlIHVuZGVzaXJlZCBiZWhhdmlvciBvZiB0cmVhdGluZyB0aGUgc2FtZSBtZXRob2Qgd2l0aFxyXG4vLyBkaWZmZXJlbnQgY29udGV4dHMgYXMgaWRlbnRpY2FsIHdoZW4gYmluZGluZy91bmJpbmRpbmcgZXZlbnRzLlxyXG5mdW5jdGlvbiBwcm94eShvYmosIG1ldGhvZE5hbWUpIHtcclxuICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnByb3h5ID0gcHJveHk7XHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcclxuLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxyXG4vLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcclxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2Jsb2IvMS42LjAvdW5kZXJzY29yZS5qcyNMNzE0XHJcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xyXG4gICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7IGltbWVkaWF0ZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgdGltZW91dDtcclxuICAgIHZhciBhcmdzO1xyXG4gICAgdmFyIGNvbnRleHQ7XHJcbiAgICB2YXIgdGltZXN0YW1wO1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpIC0gdGltZXN0YW1wO1xyXG4gICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICB0aW1lc3RhbXAgPSArbmV3IERhdGUoKTtcclxuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgICBpZiAoIXRpbWVvdXQpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbE5vdykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcclxuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBVbnpvbmVkUmFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVbnpvbmVkUmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQpIHtcclxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoZXNlIGludG8gZm9vdHByaW50LlxyXG4gICAgICAgIC8vIEVzcGVjaWFsbHksIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgbnVsbCBzdGFydE1zL2VuZE1zLlxyXG4gICAgICAgIHRoaXMuaXNTdGFydCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0VuZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChzdGFydElucHV0KSkge1xyXG4gICAgICAgICAgICBzdGFydElucHV0ID0gc3RhcnRJbnB1dC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGVuZElucHV0KSkge1xyXG4gICAgICAgICAgICBlbmRJbnB1dCA9IGVuZElucHV0LmNsb25lKCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydElucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRNcyA9IHN0YXJ0SW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kSW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRNcyA9IGVuZElucHV0LnZhbHVlT2YoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgU0lERUVGRkVDVDogd2lsbCBtdXRhdGUgZXZlbnRSYW5nZXMuXHJcbiAgICBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXHJcbiAgICBPbmx5IHdvcmtzIGZvciBub24tb3Blbi1lbmRlZCByYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgVW56b25lZFJhbmdlLmludmVydFJhbmdlcyA9IGZ1bmN0aW9uIChyYW5nZXMsIGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBzdGFydE1zID0gY29uc3RyYWludFJhbmdlLnN0YXJ0TXM7IC8vIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHJhbmdlLiB0aGUgc3RhcnQgb2YgdGhlIG5ldyByYW5nZVxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBkYXRlUmFuZ2U7XHJcbiAgICAgICAgLy8gcmFuZ2VzIG5lZWQgdG8gYmUgaW4gb3JkZXIuIHJlcXVpcmVkIGZvciBvdXIgZGF0ZS13YWxraW5nIGFsZ29yaXRobVxyXG4gICAgICAgIHJhbmdlcy5zb3J0KGNvbXBhcmVVbnpvbmVkUmFuZ2VzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0TXMgPiBzdGFydE1zKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKG5ldyBVbnpvbmVkUmFuZ2Uoc3RhcnRNcywgZGF0ZVJhbmdlLnN0YXJ0TXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmVuZE1zID4gc3RhcnRNcykge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNcyA9IGRhdGVSYW5nZS5lbmRNcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgIGlmIChzdGFydE1zIDwgY29uc3RyYWludFJhbmdlLmVuZE1zKSB7XHJcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2gobmV3IFVuem9uZWRSYW5nZShzdGFydE1zLCBjb25zdHJhaW50UmFuZ2UuZW5kTXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IHRoaXMuc3RhcnRNcztcclxuICAgICAgICB2YXIgZW5kTXMgPSB0aGlzLmVuZE1zO1xyXG4gICAgICAgIHZhciBuZXdSYW5nZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE1zID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TXMgPSBvdGhlclJhbmdlLnN0YXJ0TXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1zID0gTWF0aC5tYXgoc3RhcnRNcywgb3RoZXJSYW5nZS5zdGFydE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5lbmRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmRNcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNcyA9IG90aGVyUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNcyA9IE1hdGgubWluKGVuZE1zLCBvdGhlclJhbmdlLmVuZE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRNcyA9PSBudWxsIHx8IGVuZE1zID09IG51bGwgfHwgc3RhcnRNcyA8IGVuZE1zKSB7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlID0gbmV3IFVuem9uZWRSYW5nZShzdGFydE1zLCBlbmRNcyk7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlLmlzU3RhcnQgPSB0aGlzLmlzU3RhcnQgJiYgc3RhcnRNcyA9PT0gdGhpcy5zdGFydE1zO1xyXG4gICAgICAgICAgICBuZXdSYW5nZS5pc0VuZCA9IHRoaXMuaXNFbmQgJiYgZW5kTXMgPT09IHRoaXMuZW5kTXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdSYW5nZTtcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHNXaXRoID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW5kTXMgPT0gbnVsbCB8fCBvdGhlclJhbmdlLnN0YXJ0TXMgPT0gbnVsbCB8fCB0aGlzLmVuZE1zID4gb3RoZXJSYW5nZS5zdGFydE1zKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5zdGFydE1zID09IG51bGwgfHwgb3RoZXJSYW5nZS5lbmRNcyA9PSBudWxsIHx8IHRoaXMuc3RhcnRNcyA8IG90aGVyUmFuZ2UuZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29udGFpbnNSYW5nZSA9IGZ1bmN0aW9uIChpbm5lclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0TXMgPT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydE1zICE9IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydE1zID49IHRoaXMuc3RhcnRNcykpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmVuZE1zID09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kTXMgIT0gbnVsbCAmJiBpbm5lclJhbmdlLmVuZE1zIDw9IHRoaXMuZW5kTXMpKTtcclxuICAgIH07XHJcbiAgICAvLyBgZGF0ZWAgY2FuIGJlIGEgbW9tZW50LCBhIERhdGUsIG9yIGEgbWlsbGlzZWNvbmQgdGltZS5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29udGFpbnNEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgbXMgPSBkYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRNcyA9PSBudWxsIHx8IG1zID49IHRoaXMuc3RhcnRNcykgJiZcclxuICAgICAgICAgICAgKHRoaXMuZW5kTXMgPT0gbnVsbCB8fCBtcyA8IHRoaXMuZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIC8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cclxuICAgIC8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxyXG4gICAgLy8gYGRhdGVgIGNhbiBiZSBhIG1vbWVudCwgYSBEYXRlLCBvciBhIG1pbGxpc2Vjb25kIHRpbWUuXHJcbiAgICAvLyBSZXR1cm5zIGEgTVMtdGltZS5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29uc3RyYWluRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIG1zID0gZGF0ZS52YWx1ZU9mKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRNcyAhPSBudWxsICYmIG1zIDwgdGhpcy5zdGFydE1zKSB7XHJcbiAgICAgICAgICAgIG1zID0gdGhpcy5zdGFydE1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5lbmRNcyAhPSBudWxsICYmIG1zID49IHRoaXMuZW5kTXMpIHtcclxuICAgICAgICAgICAgbXMgPSB0aGlzLmVuZE1zIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1zO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE1zID09PSBvdGhlclJhbmdlLnN0YXJ0TXMgJiYgdGhpcy5lbmRNcyA9PT0gb3RoZXJSYW5nZS5lbmRNcztcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2UodGhpcy5zdGFydE1zLCB0aGlzLmVuZE1zKTtcclxuICAgICAgICByYW5nZS5pc1N0YXJ0ID0gdGhpcy5pc1N0YXJ0O1xyXG4gICAgICAgIHJhbmdlLmlzRW5kID0gdGhpcy5pc0VuZDtcclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhbiBhbWJpZy16b25lZCBtb21lbnQgZnJvbSBzdGFydE1zLlxyXG4gICAgLy8gQkVXQVJFOiByZXR1cm5lZCBtb21lbnQgaXMgbm90IGxvY2FsaXplZC5cclxuICAgIC8vIEZvcm1hdHRpbmcgYW5kIHN0YXJ0LW9mLXdlZWsgd2lsbCBiZSBkZWZhdWx0LlxyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5nZXRTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyh0aGlzLnN0YXJ0TXMpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGFuIGFtYmlnLXpvbmVkIG1vbWVudCBmcm9tIHN0YXJ0TXMuXHJcbiAgICAvLyBCRVdBUkU6IHJldHVybmVkIG1vbWVudCBpcyBub3QgbG9jYWxpemVkLlxyXG4gICAgLy8gRm9ybWF0dGluZyBhbmQgc3RhcnQtb2Ytd2VlayB3aWxsIGJlIGRlZmF1bHQuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmdldEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbmRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGModGhpcy5lbmRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuYXMgPSBmdW5jdGlvbiAodW5pdCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQudXRjKHRoaXMuZW5kTXMpLmRpZmYobW9tZW50LnV0Yyh0aGlzLnN0YXJ0TXMpLCB1bml0LCB0cnVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVW56b25lZFJhbmdlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVbnpvbmVkUmFuZ2U7XHJcbi8qXHJcbk9ubHkgd29ya3MgZm9yIG5vbi1vcGVuLWVuZGVkIHJhbmdlcy5cclxuKi9cclxuZnVuY3Rpb24gY29tcGFyZVVuem9uZWRSYW5nZXMocmFuZ2UxLCByYW5nZTIpIHtcclxuICAgIHJldHVybiByYW5nZTEuc3RhcnRNcyAtIHJhbmdlMi5zdGFydE1zOyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDgpO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG52YXIgRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIC8vIGNhbiB3ZSBkbyBhd2F5IHdpdGggY2FsZW5kYXI/IGF0IGxlYXN0IGZvciB0aGUgYWJzdHJhY3Q/XHJcbiAgICAvLyB1c2VmdWwgZm9yIGJ1aWxkRXZlbnREZWZcclxuICAgIGZ1bmN0aW9uIEV2ZW50U291cmNlKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIF90aGlzLmNsYXNzTmFtZSA9IFtdO1xyXG4gICAgICAgIF90aGlzLnVpZCA9IFN0cmluZyhFdmVudFNvdXJjZS51dWlkKyspO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICByYXdJbnB1dCBjYW4gYmUgYW55IGRhdGEgdHlwZSFcclxuICAgICovXHJcbiAgICBFdmVudFNvdXJjZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gbmV3IHRoaXMoY2FsZW5kYXIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3SW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuYXBwbHlQcm9wcyhyYXdJbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLm5vcm1hbGl6ZUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50LiBtdXN0IHJldHVybiBhIHByb21pc2UuXHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIC8vIG9wdGlvbmFsIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIEZvciBjb21wYWlyaW5nL21hdGNoaW5nXHJcbiAgICAqL1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChvdGhlclNvdXJjZSkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUucGFyc2VFdmVudERlZnMgPSBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmID0gdGhpcy5wYXJzZUV2ZW50RGVmKHJhd0V2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudERlZnM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnBhcnNlRXZlbnREZWYgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXJUcmFuc2Zvcm0gPSB0aGlzLmNhbGVuZGFyLm9wdCgnZXZlbnREYXRhVHJhbnNmb3JtJyk7XHJcbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybSA9IHRoaXMuZXZlbnREYXRhVHJhbnNmb3JtO1xyXG4gICAgICAgIGlmIChjYWxlbmRhclRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IGNhbGVuZGFyVHJhbnNmb3JtKHJhd0lucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvdXJjZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IHNvdXJjZVRyYW5zZm9ybShyYXdJbnB1dCwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UocmF3SW5wdXQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAocmF3UHJvcHMuaWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gRXZlbnRTb3VyY2Uubm9ybWFsaXplSWQocmF3UHJvcHMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50RGVmXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShyYXdQcm9wcy5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3UHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS51dWlkID0gMDtcclxuICAgIEV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmRlZmluZVN0YW5kYXJkUHJvcHM7XHJcbiAgICBFdmVudFNvdXJjZS5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgcmV0dXJuIEV2ZW50U291cmNlO1xyXG59KENsYXNzXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFNvdXJjZTtcclxuUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50U291cmNlKTtcclxuLy8gUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBtYW51YWxseSBwcm9jZXNzLi4uXHJcbiAgICBpZDogZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IGZhbHNlLFxyXG4gICAgLy8gYXV0b21hdGljYWxseSB0cmFuc2Zlci4uLlxyXG4gICAgY29sb3I6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXHJcbiAgICBib3JkZXJDb2xvcjogdHJ1ZSxcclxuICAgIHRleHRDb2xvcjogdHJ1ZSxcclxuICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXHJcbiAgICByZW5kZXJpbmc6IHRydWUsXHJcbiAgICBvdmVybGFwOiB0cnVlLFxyXG4gICAgY29uc3RyYWludDogdHJ1ZSxcclxuICAgIGFsbERheURlZmF1bHQ6IHRydWUsXHJcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IHRydWVcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypcclxuVXRpbGl0eSBtZXRob2RzIGZvciBlYXNpbHkgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiBhbm90aGVyIG9iamVjdCxcclxuYW5kIG1vcmUgaW1wb3J0YW50bHksIGVhc2lseSB1bmxpc3RlbmluZyBmcm9tIHRoZW0uXHJcblxuVVNBR0U6XHJcbiAgaW1wb3J0IHsgZGVmYXVsdCBhcyBMaXN0ZW5lck1peGluLCBMaXN0ZW5lckludGVyZmFjZSB9IGZyb20gJy4vTGlzdGVuZXJNaXhpbidcclxuaW4gY2xhc3M6XHJcbiAgbGlzdGVuVG86IExpc3RlbmVySW50ZXJmYWNlWydsaXN0ZW5UbyddXHJcbiAgc3RvcExpc3RlbmluZ1RvOiBMaXN0ZW5lckludGVyZmFjZVsnc3RvcExpc3RlbmluZ1RvJ11cclxuYWZ0ZXIgY2xhc3M6XHJcbiAgTGlzdGVuZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgZ3VpZCA9IDA7XHJcbnZhciBMaXN0ZW5lck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdGVuZXJNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RlbmVyTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIEdpdmVuIGFuIGBvdGhlcmAgb2JqZWN0IHRoYXQgaGFzIG9uL29mZiBtZXRob2RzLCBiaW5kIHRoZSBnaXZlbiBgY2FsbGJhY2tgIHRvIGFuIGV2ZW50IGJ5IHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgVGhlIGBjYWxsYmFja2Agd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIG9iamVjdCB0aGF0IC5saXN0ZW5UbyBpcyBiZWluZyBjYWxsZWQgb24uXHJcbiAgICBDYW4gYmUgY2FsbGVkOlxyXG4gICAgICAubGlzdGVuVG8ob3RoZXIsIGV2ZW50TmFtZSwgY2FsbGJhY2spXHJcbiAgICBPUlxyXG4gICAgICAubGlzdGVuVG8ob3RoZXIsIHtcclxuICAgICAgICBldmVudE5hbWUxOiBjYWxsYmFjazEsXHJcbiAgICAgICAgZXZlbnROYW1lMjogY2FsbGJhY2syXHJcbiAgICAgIH0pXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUubGlzdGVuVG8gPSBmdW5jdGlvbiAob3RoZXIsIGFyZywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGFyZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBhcmdbZXZlbnROYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb3RoZXIub24oYXJnICsgJy4nICsgdGhpcy5nZXRMaXN0ZW5lck5hbWVzcGFjZSgpLCAvLyB1c2UgZXZlbnQgbmFtZXNwYWNpbmcgdG8gaWRlbnRpZnkgdGhpcyBvYmplY3RcclxuICAgICAgICAgICAgJC5wcm94eShjYWxsYmFjaywgdGhpcykgLy8gYWx3YXlzIHVzZSBgdGhpc2AgY29udGV4dFxyXG4gICAgICAgICAgICAvLyB0aGUgdXN1YWxseS11bmRlc2lyZWQgalF1ZXJ5IGd1aWQgYmVoYXZpb3IgZG9lc24ndCBtYXR0ZXIsXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYWx3YXlzIHVuYmluZCB2aWEgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBDYXVzZXMgdGhlIGN1cnJlbnQgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiB0aGUgYG90aGVyYCBvYmplY3QuXHJcbiAgICBgZXZlbnROYW1lYCBpcyBvcHRpb25hbC4gSWYgb21pdHRlZCwgd2lsbCBzdG9wIGxpc3RlbmluZyB0byBBTEwgZXZlbnRzIG9uIGBvdGhlcmAuXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUuc3RvcExpc3RlbmluZ1RvID0gZnVuY3Rpb24gKG90aGVyLCBldmVudE5hbWUpIHtcclxuICAgICAgICBvdGhlci5vZmYoKGV2ZW50TmFtZSB8fCAnJykgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCkpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSZXR1cm5zIGEgc3RyaW5nLCB1bmlxdWUgdG8gdGhpcyBvYmplY3QsIHRvIGJlIHVzZWQgZm9yIGV2ZW50IG5hbWVzcGFjaW5nXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUuZ2V0TGlzdGVuZXJOYW1lc3BhY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJJZCA9IGd1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdfbGlzdGVuZXInICsgdGhpcy5saXN0ZW5lcklkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0ZW5lck1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0ZW5lck1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiA4ICovLFxuLyogOSAqLyxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBhbWJpZ0RhdGVPZk1vbnRoUmVnZXggPSAvXlxccypcXGR7NH0tXFxkXFxkJC87XHJcbnZhciBhbWJpZ1RpbWVPclpvbmVSZWdleCA9IC9eXFxzKlxcZHs0fS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyk/JC87XHJcbnZhciBuZXdNb21lbnRQcm90byA9IG1vbWVudC5mbjsgLy8gd2hlcmUgd2Ugd2lsbCBhdHRhY2ggb3VyIG5ldyBtZXRob2RzXHJcbmV4cG9ydHMubmV3TW9tZW50UHJvdG8gPSBuZXdNb21lbnRQcm90bztcclxudmFyIG9sZE1vbWVudFByb3RvID0gJC5leHRlbmQoe30sIG5ld01vbWVudFByb3RvKTsgLy8gY29weSBvZiBvcmlnaW5hbCBtb21lbnQgbWV0aG9kc1xyXG5leHBvcnRzLm9sZE1vbWVudFByb3RvID0gb2xkTW9tZW50UHJvdG87XHJcbi8vIHRlbGwgbW9tZW50anMgdG8gdHJhbnNmZXIgdGhlc2UgcHJvcGVydGllcyB1cG9uIGNsb25lXHJcbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gbW9tZW50Lm1vbWVudFByb3BlcnRpZXM7XHJcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2Z1bGxDYWxlbmRhcicpO1xyXG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1RpbWUnKTtcclxubW9tZW50UHJvcGVydGllcy5wdXNoKCdfYW1iaWdab25lJyk7XHJcbi8qXHJcbkNhbGwgdGhpcyBpZiB5b3Ugd2FudCBNb21lbnQncyBvcmlnaW5hbCBmb3JtYXQgbWV0aG9kIHRvIGJlIHVzZWRcclxuKi9cclxuZnVuY3Rpb24gb2xkTW9tZW50Rm9ybWF0KG1vbSwgZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8uZm9ybWF0LmNhbGwobW9tLCBmb3JtYXRTdHIpOyAvLyBvbGRNb21lbnRQcm90byBkZWZpbmVkIGluIG1vbWVudC1leHQuanNcclxufVxyXG5leHBvcnRzLm9sZE1vbWVudEZvcm1hdCA9IG9sZE1vbWVudEZvcm1hdDtcclxuLy8gQ3JlYXRpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDcmVhdGVzIGEgbmV3IG1vbWVudCwgc2ltaWxhciB0byB0aGUgdmFuaWxsYSBtb21lbnQoLi4uKSBjb25zdHJ1Y3RvciwgYnV0IHdpdGhcclxuLy8gZXh0cmEgZmVhdHVyZXMgKGFtYmlndW91cyB0aW1lLCBlbmhhbmNlZCBmb3JtYXR0aW5nKS4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsXHJcbi8vIGl0IHdpbGwgZnVuY3Rpb24gYXMgYSBjbG9uZSAoYW5kIHJldGFpbiB0aGUgem9uZSBvZiB0aGUgbW9tZW50KS4gQW55dGhpbmcgZWxzZSB3aWxsXHJcbi8vIHJlc3VsdCBpbiBhIG1vbWVudCBpbiB0aGUgbG9jYWwgem9uZS5cclxudmFyIG1vbWVudEV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cyk7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG1vbWVudEV4dDtcclxuLy8gU2FtZXMgYXMgbW9tZW50RXh0LCBidXQgZm9yY2VzIHRoZSByZXN1bHRpbmcgbW9tZW50IHRvIGJlIGluIHRoZSBVVEMgdGltZXpvbmUuXHJcbm1vbWVudEV4dC51dGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbW9tID0gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUpO1xyXG4gICAgLy8gRm9yY2UgaXQgaW50byBVVEMgYmVjYXVzZSBtYWtlTW9tZW50IGRvZXNuJ3QgZ3VhcmFudGVlIGl0XHJcbiAgICAvLyAoaWYgZ2l2ZW4gYSBwcmUtZXhpc3RpbmcgbW9tZW50IGZvciBleGFtcGxlKVxyXG4gICAgaWYgKG1vbS5oYXNUaW1lKCkpIHtcclxuICAgICAgICBtb20udXRjKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tO1xyXG59O1xyXG4vLyBTYW1lIGFzIG1vbWVudEV4dCwgYnV0IHdoZW4gZ2l2ZW4gYW4gSVNPODYwMSBzdHJpbmcsIHRoZSB0aW1lem9uZSBvZmZzZXQgaXMgcHJlc2VydmVkLlxyXG4vLyBJU084NjAxIHN0cmluZ3Mgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgd2lsbCBiZWNvbWUgYW1iaWd1b3VzbHkgem9uZWQuXHJcbm1vbWVudEV4dC5wYXJzZVpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUsIHRydWUpO1xyXG59O1xyXG4vLyBCdWlsZHMgYW4gZW5oYW5jZWQgbW9tZW50IGZyb20gYXJncy4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsIGl0IGNsb25lcy4gV2hlbiBnaXZlbiBhXHJcbi8vIG5hdGl2ZSBEYXRlLCBvciBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgKHRoZSBjdXJyZW50IHRpbWUpLCB0aGUgcmVzdWx0aW5nIG1vbWVudCB3aWxsIGJlIGxvY2FsLlxyXG4vLyBBbnl0aGluZyBlbHNlIG5lZWRzIHRvIGJlIFwicGFyc2VkXCIgKGEgc3RyaW5nIG9yIGFuIGFycmF5KSwgYW5kIHdpbGwgYmUgYWZmZWN0ZWQgYnk6XHJcbi8vICAgIHBhcnNlQXNVVEMgLSBpZiB0aGVyZSBpcyBubyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgcGFyc2UgdGhlIGlucHV0IGluIFVUQz9cclxuLy8gICAgcGFyc2Vab25lIC0gaWYgdGhlcmUgaXMgem9uZSBpbmZvcm1hdGlvbiwgc2hvdWxkIHdlIGZvcmNlIHRoZSB6b25lIG9mIHRoZSBtb21lbnQ/XHJcbmZ1bmN0aW9uIG1ha2VNb21lbnQoYXJncywgcGFyc2VBc1VUQywgcGFyc2Vab25lKSB7XHJcbiAgICBpZiAocGFyc2VBc1VUQyA9PT0gdm9pZCAwKSB7IHBhcnNlQXNVVEMgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhcnNlWm9uZSA9PT0gdm9pZCAwKSB7IHBhcnNlWm9uZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgaW5wdXQgPSBhcmdzWzBdO1xyXG4gICAgdmFyIGlzU2luZ2xlU3RyaW5nID0gYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcclxuICAgIHZhciBpc0FtYmlnVGltZTtcclxuICAgIHZhciBpc0FtYmlnWm9uZTtcclxuICAgIHZhciBhbWJpZ01hdGNoO1xyXG4gICAgdmFyIG1vbTtcclxuICAgIGlmIChtb21lbnQuaXNNb21lbnQoaW5wdXQpIHx8IHV0aWxfMS5pc05hdGl2ZURhdGUoaW5wdXQpIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc0FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgICAgIGlzQW1iaWdab25lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlzU2luZ2xlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChhbWJpZ0RhdGVPZk1vbnRoUmVnZXgudGVzdChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFjY2VwdCBzdHJpbmdzIGxpa2UgJzIwMTQtMDUnLCBidXQgY29udmVydCB0byB0aGUgZmlyc3Qgb2YgdGhlIG1vbnRoXHJcbiAgICAgICAgICAgICAgICBpbnB1dCArPSAnLTAxJztcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbaW5wdXRdOyAvLyBmb3Igd2hlbiB3ZSBwYXNzIGl0IG9uIHRvIG1vbWVudCdzIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKGFtYmlnTWF0Y2ggPSBhbWJpZ1RpbWVPclpvbmVSZWdleC5leGVjKGlucHV0KSkpIHtcclxuICAgICAgICAgICAgICAgIGlzQW1iaWdUaW1lID0gIWFtYmlnTWF0Y2hbNV07IC8vIG5vIHRpbWUgcGFydD9cclxuICAgICAgICAgICAgICAgIGlzQW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIC8vIGFycmF5cyBoYXZlIG5vIHRpbWV6b25lIGluZm9ybWF0aW9uLCBzbyBhc3N1bWUgYW1iaWd1b3VzIHpvbmVcclxuICAgICAgICAgICAgaXNBbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvdGhlcndpc2UsIHByb2JhYmx5IGEgc3RyaW5nIHdpdGggYSBmb3JtYXRcclxuICAgICAgICBpZiAocGFyc2VBc1VUQyB8fCBpc0FtYmlnVGltZSkge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnQudXRjLmFwcGx5KG1vbWVudCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FtYmlnVGltZSkge1xyXG4gICAgICAgICAgICBtb20uX2FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG1vbS5fYW1iaWdab25lID0gdHJ1ZTsgLy8gYW1iaWd1b3VzIHRpbWUgYWx3YXlzIG1lYW5zIGFtYmlndW91cyB6b25lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcnNlWm9uZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBbWJpZ1pvbmUpIHtcclxuICAgICAgICAgICAgICAgIG1vbS5fYW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NpbmdsZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgbW9tLnV0Y09mZnNldChpbnB1dCk7IC8vIGlmIG5vdCBhIHZhbGlkIHpvbmUsIHdpbGwgYXNzaWduIFVUQ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbW9tLl9mdWxsQ2FsZW5kYXIgPSB0cnVlOyAvLyBmbGFnIGZvciBleHRlbmRlZCBmdW5jdGlvbmFsaXR5XHJcbiAgICByZXR1cm4gbW9tO1xyXG59XHJcbi8vIFdlZWsgTnVtYmVyXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmV0dXJucyB0aGUgd2VlayBudW1iZXIsIGNvbnNpZGVyaW5nIHRoZSBsb2NhbGUncyBjdXN0b20gd2VlayBudW1iZXIgY2FsY3VhdGlvblxyXG4vLyBgd2Vla3NgIGlzIGFuIGFsaWFzIGZvciBgd2Vla2BcclxubmV3TW9tZW50UHJvdG8ud2VlayA9IG5ld01vbWVudFByb3RvLndlZWtzID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICB2YXIgd2Vla0NhbGMgPSB0aGlzLl9sb2NhbGUuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYztcclxuICAgIGlmIChpbnB1dCA9PSBudWxsICYmIHR5cGVvZiB3ZWVrQ2FsYyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiB3ZWVrQ2FsYyh0aGlzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHdlZWtDYWxjID09PSAnSVNPJykge1xyXG4gICAgICAgIHJldHVybiBvbGRNb21lbnRQcm90by5pc29XZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIElTTyBnZXR0ZXIvc2V0dGVyXHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8ud2Vlay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBsb2NhbCBnZXR0ZXIvc2V0dGVyXHJcbn07XHJcbi8vIFRpbWUtb2YtZGF5XHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gR0VUVEVSXHJcbi8vIFJldHVybnMgYSBEdXJhdGlvbiB3aXRoIHRoZSBob3Vycy9taW51dGVzL3NlY29uZHMvbXMgdmFsdWVzIG9mIHRoZSBtb21lbnQuXHJcbi8vIElmIHRoZSBtb21lbnQgaGFzIGFuIGFtYmlndW91cyB0aW1lLCBhIGR1cmF0aW9uIG9mIDAwOjAwIHdpbGwgYmUgcmV0dXJuZWQuXHJcbi8vXHJcbi8vIFNFVFRFUlxyXG4vLyBZb3UgY2FuIHN1cHBseSBhIER1cmF0aW9uLCBhIE1vbWVudCwgb3IgYSBEdXJhdGlvbi1saWtlIGFyZ3VtZW50LlxyXG4vLyBXaGVuIHNldHRpbmcgdGhlIHRpbWUsIGFuZCB0aGUgbW9tZW50IGhhcyBhbiBhbWJpZ3VvdXMgdGltZSwgaXQgdGhlbiBiZWNvbWVzIHVuYW1iaWd1b3VzLlxyXG5uZXdNb21lbnRQcm90by50aW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgIC8vIEZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QgKGlmIHRoZXJlIGlzIG9uZSkgaWYgdGhpcyBtb21lbnQgd2Fzbid0IGNyZWF0ZWQgdmlhIEZ1bGxDYWxlbmRhci5cclxuICAgIC8vIGB0aW1lYCBpcyBhIGdlbmVyaWMgZW5vdWdoIG1ldGhvZCBuYW1lIHdoZXJlIHRoaXMgcHJlY2F1dGlvbiBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgY29sbGlzaW9ucyB3LyBvdGhlciBwbHVnaW5zLlxyXG4gICAgaWYgKCF0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcclxuICAgICAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8udGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xyXG4gICAgICAgICAgICBob3VyczogdGhpcy5ob3VycygpLFxyXG4gICAgICAgICAgICBtaW51dGVzOiB0aGlzLm1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgc2Vjb25kczogdGhpcy5zZWNvbmRzKCksXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogdGhpcy5taWxsaXNlY29uZHMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7IC8vIG1hcmsgdGhhdCB0aGUgbW9tZW50IG5vdyBoYXMgYSB0aW1lXHJcbiAgICAgICAgaWYgKCFtb21lbnQuaXNEdXJhdGlvbih0aW1lKSAmJiAhbW9tZW50LmlzTW9tZW50KHRpbWUpKSB7XHJcbiAgICAgICAgICAgIHRpbWUgPSBtb21lbnQuZHVyYXRpb24odGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBkYXkgdmFsdWUgc2hvdWxkIGNhdXNlIG92ZXJmbG93IChzbyAyNCBob3VycyBiZWNvbWVzIDAwOjAwOjAwIG9mIG5leHQgZGF5KS5cclxuICAgICAgICAvLyBPbmx5IGZvciBEdXJhdGlvbiB0aW1lcywgbm90IE1vbWVudCB0aW1lcy5cclxuICAgICAgICB2YXIgZGF5SG91cnMgPSAwO1xyXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbih0aW1lKSkge1xyXG4gICAgICAgICAgICBkYXlIb3VycyA9IE1hdGguZmxvb3IodGltZS5hc0RheXMoKSkgKiAyNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgdGhlIGluZGl2aWR1YWwgZmllbGRzLlxyXG4gICAgICAgIC8vIENhbid0IHVzZSBzdGFydE9mKCdkYXknKSB0aGVuIGFkZCBkdXJhdGlvbi4gSW4gY2FzZSBvZiBEU1QgYXQgc3RhcnQgb2YgZGF5LlxyXG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKGRheUhvdXJzICsgdGltZS5ob3VycygpKVxyXG4gICAgICAgICAgICAubWludXRlcyh0aW1lLm1pbnV0ZXMoKSlcclxuICAgICAgICAgICAgLnNlY29uZHModGltZS5zZWNvbmRzKCkpXHJcbiAgICAgICAgICAgIC5taWxsaXNlY29uZHModGltZS5taWxsaXNlY29uZHMoKSk7XHJcbiAgICB9XHJcbn07XHJcbi8vIENvbnZlcnRzIHRoZSBtb21lbnQgdG8gVVRDLCBzdHJpcHBpbmcgb3V0IGl0cyB0aW1lLW9mLWRheSBhbmQgdGltZXpvbmUgb2Zmc2V0LFxyXG4vLyBidXQgcHJlc2VydmluZyBpdHMgWU1ELiBBIG1vbWVudCB3aXRoIGEgc3RyaXBwZWQgdGltZSB3aWxsIGRpc3BsYXkgbm8gdGltZVxyXG4vLyBub3IgdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cclxubmV3TW9tZW50UHJvdG8uc3RyaXBUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLl9hbWJpZ1RpbWUpIHtcclxuICAgICAgICB0aGlzLnV0Yyh0cnVlKTsgLy8ga2VlcExvY2FsVGltZT10cnVlIChmb3Iga2VlcGluZyAqZGF0ZSogdmFsdWUpXHJcbiAgICAgICAgLy8gc2V0IHRpbWUgdG8gemVyb1xyXG4gICAgICAgIHRoaXMuc2V0KHtcclxuICAgICAgICAgICAgaG91cnM6IDAsXHJcbiAgICAgICAgICAgIG1pbnV0ZXM6IDAsXHJcbiAgICAgICAgICAgIHNlY29uZHM6IDAsXHJcbiAgICAgICAgICAgIG1zOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgdGltZSBhcyBhbWJpZ3VvdXMuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSAudXRjKCkgY2FsbCwgd2hpY2ggbWlnaHQgY2FsbCAudXRjT2Zmc2V0KCksXHJcbiAgICAgICAgLy8gd2hpY2ggY2xlYXJzIGFsbCBhbWJpZyBmbGFncy5cclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2FtYmlnWm9uZSA9IHRydWU7IC8vIGlmIGFtYmlndW91cyB0aW1lLCBhbHNvIGFtYmlndW91cyB0aW1lem9uZSBvZmZzZXRcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxufTtcclxuLy8gUmV0dXJucyBpZiB0aGUgbW9tZW50IGhhcyBhIG5vbi1hbWJpZ3VvdXMgdGltZSAoYm9vbGVhbilcclxubmV3TW9tZW50UHJvdG8uaGFzVGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5fYW1iaWdUaW1lO1xyXG59O1xyXG4vLyBUaW1lem9uZVxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENvbnZlcnRzIHRoZSBtb21lbnQgdG8gVVRDLCBzdHJpcHBpbmcgb3V0IGl0cyB0aW1lem9uZSBvZmZzZXQsIGJ1dCBwcmVzZXJ2aW5nIGl0c1xyXG4vLyBZTUQgYW5kIHRpbWUtb2YtZGF5LiBBIG1vbWVudCB3aXRoIGEgc3RyaXBwZWQgdGltZXpvbmUgb2Zmc2V0IHdpbGwgZGlzcGxheSBub1xyXG4vLyB0aW1lem9uZSBvZmZzZXQgd2hlbiAuZm9ybWF0KCkgaXMgY2FsbGVkLlxyXG5uZXdNb21lbnRQcm90by5zdHJpcFpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgd2FzQW1iaWdUaW1lO1xyXG4gICAgaWYgKCF0aGlzLl9hbWJpZ1pvbmUpIHtcclxuICAgICAgICB3YXNBbWJpZ1RpbWUgPSB0aGlzLl9hbWJpZ1RpbWU7XHJcbiAgICAgICAgdGhpcy51dGModHJ1ZSk7IC8vIGtlZXBMb2NhbFRpbWU9dHJ1ZSAoZm9yIGtlZXBpbmcgZGF0ZSBhbmQgdGltZSB2YWx1ZXMpXHJcbiAgICAgICAgLy8gdGhlIGFib3ZlIGNhbGwgdG8gLnV0YygpLy51dGNPZmZzZXQoKSB1bmZvcnR1bmF0ZWx5IG1pZ2h0IGNsZWFyIHRoZSBhbWJpZyBmbGFncywgc28gcmVzdG9yZVxyXG4gICAgICAgIHRoaXMuX2FtYmlnVGltZSA9IHdhc0FtYmlnVGltZSB8fCBmYWxzZTtcclxuICAgICAgICAvLyBNYXJrIHRoZSB6b25lIGFzIGFtYmlndW91cy4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIC51dGMoKSBjYWxsLCB3aGljaCBtaWdodCBjYWxsIC51dGNPZmZzZXQoKSxcclxuICAgICAgICAvLyB3aGljaCBjbGVhcnMgdGhlIGFtYmlnIGZsYWdzLlxyXG4gICAgICAgIHRoaXMuX2FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbn07XHJcbi8vIFJldHVybnMgb2YgdGhlIG1vbWVudCBoYXMgYSBub24tYW1iaWd1b3VzIHRpbWV6b25lIG9mZnNldCAoYm9vbGVhbilcclxubmV3TW9tZW50UHJvdG8uaGFzWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5fYW1iaWdab25lO1xyXG59O1xyXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZVxyXG5uZXdNb21lbnRQcm90by5sb2NhbCA9IGZ1bmN0aW9uIChrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICAvLyBmb3Igd2hlbiBjb252ZXJ0aW5nIGZyb20gYW1iaWd1b3VzbHktem9uZWQgdG8gbG9jYWwsXHJcbiAgICAvLyBrZWVwIHRoZSB0aW1lIHZhbHVlcyB3aGVuIGNvbnZlcnRpbmcgZnJvbSBVVEMgLT4gbG9jYWxcclxuICAgIG9sZE1vbWVudFByb3RvLmxvY2FsLmNhbGwodGhpcywgdGhpcy5fYW1iaWdab25lIHx8IGtlZXBMb2NhbFRpbWUpO1xyXG4gICAgLy8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcclxuICAgIC8vIHRoaXMgcHJvYmFibHkgYWxyZWFkeSBoYXBwZW5lZCB2aWEgbG9jYWwoKSAtPiB1dGNPZmZzZXQoKSwgYnV0IGRvbid0IHJlbHkgb24gTW9tZW50J3MgaW50ZXJuYWxzXHJcbiAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG59O1xyXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZVxyXG5uZXdNb21lbnRQcm90by51dGMgPSBmdW5jdGlvbiAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgb2xkTW9tZW50UHJvdG8udXRjLmNhbGwodGhpcywga2VlcExvY2FsVGltZSk7XHJcbiAgICAvLyBlbnN1cmUgbm9uLWFtYmlndW91c1xyXG4gICAgLy8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSB1dGMoKSAtPiB1dGNPZmZzZXQoKSwgYnV0IGRvbid0IHJlbHkgb24gTW9tZW50J3MgaW50ZXJuYWxzXHJcbiAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lICh3aWxsIHByb2JhYmx5IGdldCBjYWxsZWQgdXBvbiAudXRjKCkgYW5kIC5sb2NhbCgpKVxyXG5uZXdNb21lbnRQcm90by51dGNPZmZzZXQgPSBmdW5jdGlvbiAodHpvKSB7XHJcbiAgICBpZiAodHpvICE9IG51bGwpIHtcclxuICAgICAgICAvLyB0aGVzZSBhc3NpZ25tZW50cyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBvcmlnaW5hbCB6b25lIG1ldGhvZCBpcyBjYWxsZWQuXHJcbiAgICAgICAgLy8gSSBmb3JnZXQgd2h5LCBzb21ldGhpbmcgdG8gZG8gd2l0aCBhIGJyb3dzZXIgY3Jhc2guXHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYW1iaWdab25lID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8udXRjT2Zmc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXHJcblVTQUdFOlxyXG4gIGltcG9ydCB7IGRlZmF1bHQgYXMgRW1pdHRlck1peGluLCBFbWl0dGVySW50ZXJmYWNlIH0gZnJvbSAnLi9FbWl0dGVyTWl4aW4nXHJcbmluIGNsYXNzOlxyXG4gIG9uOiBFbWl0dGVySW50ZXJmYWNlWydvbiddXHJcbiAgb25lOiBFbWl0dGVySW50ZXJmYWNlWydvbmUnXVxyXG4gIG9mZjogRW1pdHRlckludGVyZmFjZVsnb2ZmJ11cclxuICB0cmlnZ2VyOiBFbWl0dGVySW50ZXJmYWNlWyd0cmlnZ2VyJ11cclxuICB0cmlnZ2VyV2l0aDogRW1pdHRlckludGVyZmFjZVsndHJpZ2dlcldpdGgnXVxyXG4gIGhhc0hhbmRsZXJzOiBFbWl0dGVySW50ZXJmYWNlWydoYXNIYW5kbGVycyddXHJcbmFmdGVyIGNsYXNzOlxyXG4gIEVtaXR0ZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgRW1pdHRlck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRW1pdHRlck1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW1pdHRlck1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIGpRdWVyeS1pZmljYXRpb24gdmlhICQodGhpcykgYWxsb3dzIGEgbm9uLURPTSBvYmplY3QgdG8gaGF2ZVxyXG4gICAgLy8gdGhlIHNhbWUgZXZlbnQgaGFuZGxpbmcgY2FwYWJpbGl0aWVzIChpbmNsdWRpbmcgbmFtZXNwYWNlcykuXHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbih0eXBlcywgdGhpcy5fcHJlcGFyZUludGVyY2VwdChoYW5kbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbmUodHlwZXMsIHRoaXMuX3ByZXBhcmVJbnRlcmNlcHQoaGFuZGxlcikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLl9wcmVwYXJlSW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAvLyBoYW5kbGVycyBhcmUgYWx3YXlzIGNhbGxlZCB3aXRoIGFuIFwiZXZlbnRcIiBvYmplY3QgYXMgdGhlaXIgZmlyc3QgcGFyYW0uXHJcbiAgICAgICAgLy8gc25lYWsgdGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhcmd1bWVudHMgaW50byB0aGUgZXh0cmEgcGFyYW1ldGVyIG9iamVjdFxyXG4gICAgICAgIC8vIGFuZCBmb3J3YXJkIHRoZW0gb24gdG8gdGhlIG9yaWdpbmFsIGhhbmRsZXIuXHJcbiAgICAgICAgdmFyIGludGVyY2VwdCA9IGZ1bmN0aW9uIChldiwgZXh0cmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuYXBwbHkoZXh0cmEuY29udGV4dCB8fCB0aGlzLCBleHRyYS5hcmdzIHx8IFtdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIG1pbWljayBqUXVlcnkncyBpbnRlcm5hbCBcInByb3h5XCIgc3lzdGVtIChyaXNreSwgSSBrbm93KVxyXG4gICAgICAgIC8vIGNhdXNpbmcgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIC5ndWlkIHRvIGFwcGVhciB0byBiZSB0aGUgc2FtZS5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzIuMi40L3NyYy9jb3JlLmpzI0w0NDhcclxuICAgICAgICAvLyB0aGlzIGlzIG5lZWRlZCBmb3IgY2FsbGluZyAub2ZmIHdpdGggdGhlIG9yaWdpbmFsIG5vbi1pbnRlcmNlcHQgaGFuZGxlci5cclxuICAgICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSAkLmd1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaW50ZXJjZXB0Lmd1aWQgPSBoYW5kbGVyLmd1aWQ7XHJcbiAgICAgICAgcmV0dXJuIGludGVyY2VwdDtcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlcywgaGFuZGxlcikge1xyXG4gICAgICAgICQodGhpcykub2ZmKHR5cGVzLCBoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGVzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHRcclxuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUudHJpZ2dlcldpdGggPSBmdW5jdGlvbiAodHlwZXMsIGNvbnRleHQsIGFyZ3MpIHtcclxuICAgICAgICAvLyBgdHJpZ2dlckhhbmRsZXJgIGlzIGxlc3MgcmVsaWFudCBvbiB0aGUgRE9NIGNvbXBhcmVkIHRvIGB0cmlnZ2VyYC5cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHQuXHJcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBjb250ZXh0OiBjb250ZXh0LCBhcmdzOiBhcmdzIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgaGFzaCA9ICQuX2RhdGEodGhpcywgJ2V2ZW50cycpOyAvLyBodHRwOi8vYmxvZy5qcXVlcnkuY29tLzIwMTIvMDgvMDkvanF1ZXJ5LTEtOC1yZWxlYXNlZC9cclxuICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoW3R5cGVdICYmIGhhc2hbdHlwZV0ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW1pdHRlck1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyTWl4aW47XHJcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypcclxuTWVhbnQgdG8gYmUgaW1tdXRhYmxlXHJcbiovXHJcbnZhciBDb21wb25lbnRGb290cHJpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnRGb290cHJpbnQodW56b25lZFJhbmdlLCBpc0FsbERheSkge1xyXG4gICAgICAgIHRoaXMuaXNBbGxEYXkgPSBmYWxzZTsgLy8gY29tcG9uZW50IGNhbiBjaG9vc2UgdG8gaWdub3JlIHRoaXNcclxuICAgICAgICB0aGlzLnVuem9uZWRSYW5nZSA9IHVuem9uZWRSYW5nZTtcclxuICAgICAgICB0aGlzLmlzQWxsRGF5ID0gaXNBbGxEYXk7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgT25seSB3b3JrcyBmb3Igbm9uLW9wZW4tZW5kZWQgcmFuZ2VzLlxyXG4gICAgKi9cclxuICAgIENvbXBvbmVudEZvb3RwcmludC5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoY2FsZW5kYXIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogY2FsZW5kYXIubXNUb01vbWVudCh0aGlzLnVuem9uZWRSYW5nZS5zdGFydE1zLCB0aGlzLmlzQWxsRGF5KSxcclxuICAgICAgICAgICAgZW5kOiBjYWxlbmRhci5tc1RvTW9tZW50KHRoaXMudW56b25lZFJhbmdlLmVuZE1zLCB0aGlzLmlzQWxsRGF5KVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudEZvb3RwcmludDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcG9uZW50Rm9vdHByaW50O1xyXG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIEV2ZW50SW5zdGFuY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5KTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG52YXIgU2luZ2xlRXZlbnREZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTaW5nbGVFdmVudERlZiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNpbmdsZUV2ZW50RGVmKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBXaWxsIHJlY2VpdmUgc3RhcnQvZW5kIHBhcmFtcywgYnV0IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICovXHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLmJ1aWxkSW5zdGFuY2UoKV07XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmJ1aWxkSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEluc3RhbmNlXzEuZGVmYXVsdCh0aGlzLCAvLyBkZWZpbml0aW9uXHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSk7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVQcm9maWxlLmlzQWxsRGF5KCk7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWYgPSBfc3VwZXIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgZGVmLmRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfTtcclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5yZXpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5zb3VyY2UuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KGNhbGVuZGFyLm1vbWVudChkYXRlUHJvZmlsZS5zdGFydCksIGRhdGVQcm9maWxlLmVuZCA/IGNhbGVuZGFyLm1vbWVudChkYXRlUHJvZmlsZS5lbmQpIDogbnVsbCwgY2FsZW5kYXIpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOT1RFOiBpZiBzdXBlci1tZXRob2QgZmFpbHMsIHNob3VsZCBzdGlsbCBhdHRlbXB0IHRvIGFwcGx5XHJcbiAgICAqL1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdC5wYXJzZShyYXdQcm9wcywgdGhpcy5zb3VyY2UpOyAvLyByZXR1cm5zIG51bGwgb24gZmFpbHVyZVxyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBgZGF0ZWAgc2hvd3MgdXAgaW4gdGhlIGxlZ2FjeSBldmVudCBvYmplY3RzIGFzLWlzXHJcbiAgICAgICAgICAgIGlmIChyYXdQcm9wcy5kYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWlzY1Byb3BzLmRhdGUgPSByYXdQcm9wcy5kYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTaW5nbGVFdmVudERlZjtcclxufShFdmVudERlZl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU2luZ2xlRXZlbnREZWY7XHJcbi8vIFBhcnNpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblNpbmdsZUV2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgc3RhcnQ6IGZhbHNlLFxyXG4gICAgZGF0ZTogZmFsc2UsXHJcbiAgICBlbmQ6IGZhbHNlLFxyXG4gICAgYWxsRGF5OiBmYWxzZVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNaXhpbigpIHtcclxuICAgIH1cclxuICAgIE1peGluLm1peEludG8gPSBmdW5jdGlvbiAoZGVzdENsYXNzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBfdGhpcy5wcm90b3R5cGVbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgd2lsbCBvdmVycmlkZSBleGlzdGluZyBtZXRob2RzXHJcbiAgICBUT0RPOiByZW1vdmUhIG5vdCB1c2VkIGFueW1vcmVcclxuICAgICovXHJcbiAgICBNaXhpbi5taXhPdmVyID0gZnVuY3Rpb24gKGRlc3RDbGFzcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgZGVzdENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IF90aGlzLnByb3RvdHlwZVtuYW1lXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWl4aW47XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBJbnRlcmFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEludGVyYWN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNvbXBvbmVudC5fZ2V0VmlldygpO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJhY3Rpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEludGVyYWN0aW9uO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMudmVyc2lvbiA9ICczLjkuMCc7XHJcbi8vIFdoZW4gaW50cm9kdWNpbmcgaW50ZXJuYWwgQVBJIGluY29tcGF0aWJpbGl0aWVzICh3aGVyZSBmdWxsY2FsZW5kYXIgcGx1Z2lucyB3b3VsZCBicmVhayksXHJcbi8vIHRoZSBtaW5vciB2ZXJzaW9uIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgdXBwZWQgKGV4OiAyLjcuMiAtPiAyLjguMClcclxuLy8gYW5kIHRoZSBiZWxvdyBpbnRlZ2VyIHNob3VsZCBiZSBpbmNyZW1lbnRlZC5cclxuZXhwb3J0cy5pbnRlcm5hbEFwaVZlcnNpb24gPSAxMjtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmV4cG9ydHMuYXBwbHlBbGwgPSB1dGlsXzEuYXBwbHlBbGw7XHJcbmV4cG9ydHMuZGVib3VuY2UgPSB1dGlsXzEuZGVib3VuY2U7XHJcbmV4cG9ydHMuaXNJbnQgPSB1dGlsXzEuaXNJbnQ7XHJcbmV4cG9ydHMuaHRtbEVzY2FwZSA9IHV0aWxfMS5odG1sRXNjYXBlO1xyXG5leHBvcnRzLmNzc1RvU3RyID0gdXRpbF8xLmNzc1RvU3RyO1xyXG5leHBvcnRzLnByb3h5ID0gdXRpbF8xLnByb3h5O1xyXG5leHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XHJcbmV4cG9ydHMuZ2V0T3V0ZXJSZWN0ID0gdXRpbF8xLmdldE91dGVyUmVjdDtcclxuZXhwb3J0cy5nZXRDbGllbnRSZWN0ID0gdXRpbF8xLmdldENsaWVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0Q29udGVudFJlY3QgPSB1dGlsXzEuZ2V0Q29udGVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gdXRpbF8xLmdldFNjcm9sbGJhcldpZHRocztcclxuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHV0aWxfMS5wcmV2ZW50RGVmYXVsdDtcclxuZXhwb3J0cy5wYXJzZUZpZWxkU3BlY3MgPSB1dGlsXzEucGFyc2VGaWVsZFNwZWNzO1xyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjcztcclxuZXhwb3J0cy5jb21wYXJlQnlGaWVsZFNwZWMgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjO1xyXG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IHV0aWxfMS5mbGV4aWJsZUNvbXBhcmU7XHJcbmV4cG9ydHMuY29tcHV0ZUdyZWF0ZXN0VW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0O1xyXG5leHBvcnRzLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IHV0aWxfMS5kaXZpZGVSYW5nZUJ5RHVyYXRpb247XHJcbmV4cG9ydHMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gdXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbjtcclxuZXhwb3J0cy5tdWx0aXBseUR1cmF0aW9uID0gdXRpbF8xLm11bHRpcGx5RHVyYXRpb247XHJcbmV4cG9ydHMuZHVyYXRpb25IYXNUaW1lID0gdXRpbF8xLmR1cmF0aW9uSGFzVGltZTtcclxuZXhwb3J0cy5sb2cgPSB1dGlsXzEubG9nO1xyXG5leHBvcnRzLndhcm4gPSB1dGlsXzEud2FybjtcclxuZXhwb3J0cy5yZW1vdmVFeGFjdCA9IHV0aWxfMS5yZW1vdmVFeGFjdDtcclxuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IHV0aWxfMS5pbnRlcnNlY3RSZWN0cztcclxudmFyIGRhdGVfZm9ybWF0dGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGRhdGVfZm9ybWF0dGluZ18xLmZvcm1hdERhdGU7XHJcbmV4cG9ydHMuZm9ybWF0UmFuZ2UgPSBkYXRlX2Zvcm1hdHRpbmdfMS5mb3JtYXRSYW5nZTtcclxuZXhwb3J0cy5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQgPSBkYXRlX2Zvcm1hdHRpbmdfMS5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQ7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG5leHBvcnRzLmRhdGVwaWNrZXJMb2NhbGUgPSBsb2NhbGVfMS5kYXRlcGlja2VyTG9jYWxlO1xyXG5leHBvcnRzLmxvY2FsZSA9IGxvY2FsZV8xLmxvY2FsZTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5leHBvcnRzLm1vbWVudCA9IG1vbWVudF9leHRfMS5kZWZhdWx0O1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuZXhwb3J0cy5FbWl0dGVyTWl4aW4gPSBFbWl0dGVyTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuZXhwb3J0cy5MaXN0ZW5lck1peGluID0gTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBNb2RlbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbF8xLmRlZmF1bHQ7XHJcbnZhciBDb25zdHJhaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDcpO1xyXG5leHBvcnRzLkNvbnN0cmFpbnRzID0gQ29uc3RyYWludHNfMS5kZWZhdWx0O1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5leHBvcnRzLlVuem9uZWRSYW5nZSA9IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQ7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5leHBvcnRzLkNvbXBvbmVudEZvb3RwcmludCA9IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQ7XHJcbnZhciBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyKTtcclxuZXhwb3J0cy5CdXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5leHBvcnRzLkV2ZW50RGVmID0gRXZlbnREZWZfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbmV4cG9ydHMuRXZlbnREZWZNdXRhdGlvbiA9IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG5leHBvcnRzLkV2ZW50U291cmNlUGFyc2VyID0gRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbmV4cG9ydHMuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZV8xLmRlZmF1bHQ7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxuZXhwb3J0cy5kZWZpbmVUaGVtZVN5c3RlbSA9IFRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbmV4cG9ydHMuRXZlbnRJbnN0YW5jZUdyb3VwID0gRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdDtcclxudmFyIEFycmF5RXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG5leHBvcnRzLkFycmF5RXZlbnRTb3VyY2UgPSBBcnJheUV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIEZ1bmNFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTUpO1xyXG5leHBvcnRzLkZ1bmNFdmVudFNvdXJjZSA9IEZ1bmNFdmVudFNvdXJjZV8xLmRlZmF1bHQ7XHJcbnZhciBKc29uRmVlZEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNik7XHJcbmV4cG9ydHMuSnNvbkZlZWRFdmVudFNvdXJjZSA9IEpzb25GZWVkRXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5leHBvcnRzLkV2ZW50Rm9vdHByaW50ID0gRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0O1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG5leHBvcnRzLkNsYXNzID0gQ2xhc3NfMS5kZWZhdWx0O1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5leHBvcnRzLk1peGluID0gTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbmV4cG9ydHMuQ29vcmRDYWNoZSA9IENvb3JkQ2FjaGVfMS5kZWZhdWx0O1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcclxuZXhwb3J0cy5EcmFnTGlzdGVuZXIgPSBEcmFnTGlzdGVuZXJfMS5kZWZhdWx0O1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2VfMS5kZWZhdWx0O1xyXG52YXIgVGFza1F1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNyk7XHJcbmV4cG9ydHMuVGFza1F1ZXVlID0gVGFza1F1ZXVlXzEuZGVmYXVsdDtcclxudmFyIFJlbmRlclF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOCk7XHJcbmV4cG9ydHMuUmVuZGVyUXVldWUgPSBSZW5kZXJRdWV1ZV8xLmRlZmF1bHQ7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbmV4cG9ydHMuU2Nyb2xsZXIgPSBTY3JvbGxlcl8xLmRlZmF1bHQ7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbmV4cG9ydHMuVGhlbWUgPSBUaGVtZV8xLmRlZmF1bHQ7XHJcbnZhciBEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOSk7XHJcbmV4cG9ydHMuRGF0ZUNvbXBvbmVudCA9IERhdGVDb21wb25lbnRfMS5kZWZhdWx0O1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxuZXhwb3J0cy5JbnRlcmFjdGl2ZURhdGVDb21wb25lbnQgPSBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0O1xyXG52YXIgQ2FsZW5kYXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIwKTtcclxuZXhwb3J0cy5DYWxlbmRhciA9IENhbGVuZGFyXzEuZGVmYXVsdDtcclxudmFyIFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG5leHBvcnRzLlZpZXcgPSBWaWV3XzEuZGVmYXVsdDtcclxudmFyIFZpZXdSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbmV4cG9ydHMuZGVmaW5lVmlldyA9IFZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXc7XHJcbmV4cG9ydHMuZ2V0Vmlld0NvbmZpZyA9IFZpZXdSZWdpc3RyeV8xLmdldFZpZXdDb25maWc7XHJcbnZhciBEYXlUYWJsZU1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcclxuZXhwb3J0cy5EYXlUYWJsZU1peGluID0gRGF5VGFibGVNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbmV4cG9ydHMuQnVzaW5lc3NIb3VyUmVuZGVyZXIgPSBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxuZXhwb3J0cy5FdmVudFJlbmRlcmVyID0gRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xyXG5leHBvcnRzLkZpbGxSZW5kZXJlciA9IEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbmV4cG9ydHMuSGVscGVyUmVuZGVyZXIgPSBIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBFeHRlcm5hbERyb3BwaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMik7XHJcbmV4cG9ydHMuRXh0ZXJuYWxEcm9wcGluZyA9IEV4dGVybmFsRHJvcHBpbmdfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRSZXNpemluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjMpO1xyXG5leHBvcnRzLkV2ZW50UmVzaXppbmcgPSBFdmVudFJlc2l6aW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UG9pbnRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xyXG5leHBvcnRzLkV2ZW50UG9pbnRpbmcgPSBFdmVudFBvaW50aW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50RHJhZ2dpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI0KTtcclxuZXhwb3J0cy5FdmVudERyYWdnaW5nID0gRXZlbnREcmFnZ2luZ18xLmRlZmF1bHQ7XHJcbnZhciBEYXRlU2VsZWN0aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNSk7XHJcbmV4cG9ydHMuRGF0ZVNlbGVjdGluZyA9IERhdGVTZWxlY3RpbmdfMS5kZWZhdWx0O1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XHJcbmV4cG9ydHMuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbiA9IFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQWdlbmRhVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjYpO1xyXG5leHBvcnRzLkFnZW5kYVZpZXcgPSBBZ2VuZGFWaWV3XzEuZGVmYXVsdDtcclxudmFyIFRpbWVHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNyk7XHJcbmV4cG9ydHMuVGltZUdyaWQgPSBUaW1lR3JpZF8xLmRlZmF1bHQ7XHJcbnZhciBEYXlHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxuZXhwb3J0cy5EYXlHcmlkID0gRGF5R3JpZF8xLmRlZmF1bHQ7XHJcbnZhciBCYXNpY1ZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xyXG5leHBvcnRzLkJhc2ljVmlldyA9IEJhc2ljVmlld18xLmRlZmF1bHQ7XHJcbnZhciBNb250aFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI5KTtcclxuZXhwb3J0cy5Nb250aFZpZXcgPSBNb250aFZpZXdfMS5kZWZhdWx0O1xyXG52YXIgTGlzdFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMwKTtcclxuZXhwb3J0cy5MaXN0VmlldyA9IExpc3RWaWV3XzEuZGVmYXVsdDtcclxuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG4vKlxyXG5NZWFudCB0byBiZSBpbW11dGFibGVcclxuKi9cclxudmFyIEV2ZW50RGF0ZVByb2ZpbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERhdGVQcm9maWxlKHN0YXJ0LCBlbmQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkVW56b25lZFJhbmdlKGNhbGVuZGFyKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBOZWVkcyBhbiBFdmVudFNvdXJjZSBvYmplY3RcclxuICAgICovXHJcbiAgICBFdmVudERhdGVQcm9maWxlLnBhcnNlID0gZnVuY3Rpb24gKHJhd1Byb3BzLCBzb3VyY2UpIHtcclxuICAgICAgICB2YXIgc3RhcnRJbnB1dCA9IHJhd1Byb3BzLnN0YXJ0IHx8IHJhd1Byb3BzLmRhdGU7XHJcbiAgICAgICAgdmFyIGVuZElucHV0ID0gcmF3UHJvcHMuZW5kO1xyXG4gICAgICAgIGlmICghc3RhcnRJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHNvdXJjZS5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgc3RhcnQgPSBjYWxlbmRhci5tb21lbnQoc3RhcnRJbnB1dCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IGVuZElucHV0ID8gY2FsZW5kYXIubW9tZW50KGVuZElucHV0KSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGZvcmNlZEFsbERheSA9IHJhd1Byb3BzLmFsbERheTtcclxuICAgICAgICB2YXIgZm9yY2VFdmVudER1cmF0aW9uID0gY2FsZW5kYXIub3B0KCdmb3JjZUV2ZW50RHVyYXRpb24nKTtcclxuICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgJiYgKCFlbmQuaXNWYWxpZCgpIHx8ICFlbmQuaXNBZnRlcihzdGFydCkpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JjZWRBbGxEYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3JjZWRBbGxEYXkgPSBzb3VyY2UuYWxsRGF5RGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKGZvcmNlZEFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZWRBbGxEYXkgPSBjYWxlbmRhci5vcHQoJ2FsbERheURlZmF1bHQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9yY2VkQWxsRGF5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZm9yY2VkQWxsRGF5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0Lmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmICFlbmQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVuZCAmJiBmb3JjZUV2ZW50RHVyYXRpb24pIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKCFzdGFydC5oYXNUaW1lKCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERhdGVQcm9maWxlKHN0YXJ0LCBlbmQsIGNhbGVuZGFyKTtcclxuICAgIH07XHJcbiAgICBFdmVudERhdGVQcm9maWxlLmlzU3RhbmRhcmRQcm9wID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BOYW1lID09PSAnc3RhcnQnIHx8IHByb3BOYW1lID09PSAnZGF0ZScgfHwgcHJvcE5hbWUgPT09ICdlbmQnIHx8IHByb3BOYW1lID09PSAnYWxsRGF5JztcclxuICAgIH07XHJcbiAgICBFdmVudERhdGVQcm9maWxlLnByb3RvdHlwZS5pc0FsbERheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gISh0aGlzLnN0YXJ0Lmhhc1RpbWUoKSB8fCAodGhpcy5lbmQgJiYgdGhpcy5lbmQuaGFzVGltZSgpKSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5lZWRzIGEgQ2FsZW5kYXIgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5wcm90b3R5cGUuYnVpbGRVbnpvbmVkUmFuZ2UgPSBmdW5jdGlvbiAoY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IHRoaXMuc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgdmFyIGVuZE1zID0gdGhpcy5nZXRFbmQoY2FsZW5kYXIpLnN0cmlwWm9uZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnRNcywgZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOZWVkcyBhIENhbGVuZGFyIG9iamVjdFxyXG4gICAgKi9cclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucHJvdG90eXBlLmdldEVuZCA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCA/XHJcbiAgICAgICAgICAgIHRoaXMuZW5kLmNsb25lKCkgOlxyXG4gICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGVuZCBmcm9tIHRoZSBzdGFydCBhbmQgYWxsRGF5LiBjb21wdXRlIGFsbERheSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKHRoaXMuaXNBbGxEYXkoKSwgdGhpcy5zdGFydCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGF0ZVByb2ZpbGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGF0ZVByb2ZpbGU7XHJcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgRXZlbnRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTEpO1xyXG4vKlxyXG5JdCdzIGV4cGVjdGVkIHRoYXQgdGhlcmUgd2lsbCBiZSBhdCBsZWFzdCBvbmUgRXZlbnRJbnN0YW5jZSxcclxuT1IgdGhhdCBhbiBleHBsaWNpdEV2ZW50RGVmIGlzIGFzc2lnbmVkLlxyXG4qL1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRJbnN0YW5jZUdyb3VwKGV2ZW50SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudEluc3RhbmNlcyA9IGV2ZW50SW5zdGFuY2VzIHx8IFtdO1xyXG4gICAgfVxyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5nZXRBbGxFdmVudFJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICBpZiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlTm9ybWFsUmVuZGVyUmFuZ2VzKGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlUmVuZGVyUmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW52ZXJzZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlSW52ZXJzZVJlbmRlclJhbmdlcyhjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VOb3JtYWxSZW5kZXJSYW5nZXMoY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5zbGljZU5vcm1hbFJlbmRlclJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50SW5zdGFuY2VzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIHZhciBzbGljZWRSYW5nZTtcclxuICAgICAgICB2YXIgc2xpY2VkRXZlbnRSYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2VzW2ldO1xyXG4gICAgICAgICAgICBzbGljZWRSYW5nZSA9IGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUudW56b25lZFJhbmdlLmludGVyc2VjdChjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHNsaWNlZEV2ZW50UmFuZ2VzLnB1c2gobmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KHNsaWNlZFJhbmdlLCBldmVudEluc3RhbmNlLmRlZiwgZXZlbnRJbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzbGljZWRFdmVudFJhbmdlcztcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlSW52ZXJzZVJlbmRlclJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlcyA9IHRoaXMuZXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBvd25lckRlZiA9IHRoaXMuZ2V0RXZlbnREZWYoKTtcclxuICAgICAgICB1bnpvbmVkUmFuZ2VzID0gVW56b25lZFJhbmdlXzEuZGVmYXVsdC5pbnZlcnRSYW5nZXModW56b25lZFJhbmdlcywgY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICByZXR1cm4gdW56b25lZFJhbmdlcy5tYXAoZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KHVuem9uZWRSYW5nZSwgb3duZXJEZWYpOyAvLyBkb24ndCBnaXZlIGFuIEV2ZW50SW5zdGFuY2VcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmlzSW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudERlZigpLmhhc0ludmVyc2VSZW5kZXJpbmcoKTtcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmdldEV2ZW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RXZlbnREZWYgfHwgdGhpcy5ldmVudEluc3RhbmNlc1swXS5kZWY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50SW5zdGFuY2VHcm91cDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGhlbWUob3B0aW9uc01hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gb3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzSWNvbk92ZXJyaWRlKCk7XHJcbiAgICB9XHJcbiAgICBUaGVtZS5wcm90b3R5cGUucHJvY2Vzc0ljb25PdmVycmlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUodGhpcy5vcHRpb25zTWFuYWdlci5nZXQodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLnNldEljb25PdmVycmlkZSA9IGZ1bmN0aW9uIChpY29uT3ZlcnJpZGVIYXNoKSB7XHJcbiAgICAgICAgdmFyIGljb25DbGFzc2VzQ29weTtcclxuICAgICAgICB2YXIgYnV0dG9uTmFtZTtcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGljb25PdmVycmlkZUhhc2gpKSB7XHJcbiAgICAgICAgICAgIGljb25DbGFzc2VzQ29weSA9ICQuZXh0ZW5kKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcclxuICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXggPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xyXG4gICAgICAgIGlmIChwcmVmaXggJiYgY2xhc3NOYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVmaXggKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcclxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyAnICcgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzID0gZnVuY3Rpb24gKGN1c3RvbUJ1dHRvblByb3BzKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24pIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlSWNvbkNsYXNzICsgJyAnICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGhlbWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRoZW1lO1xyXG5UaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xyXG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcclxuVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnJztcclxuVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFByb21pc2VTdHViID0ge1xyXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZXNvbHZlOiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLnJlc29sdmUodmFsKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZWplY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCkucmVqZWN0KCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgYXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQcm9taXNlU3R1YjtcclxuZnVuY3Rpb24gYXR0YWNoSW1tZWRpYXRlbHlSZXNvbHZpbmdUaGVuKHByb21pc2UsIHZhbCkge1xyXG4gICAgcHJvbWlzZS50aGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlU3R1Yi5yZXNvbHZlKG9uUmVzb2x2ZSh2YWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGF0dGFjaEltbWVkaWF0ZWx5UmVqZWN0aW5nVGhlbihwcm9taXNlKSB7XHJcbiAgICBwcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlLCBvblJlamVjdCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgZXhwb3J0SG9va3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5leHBvcnRIb29rcy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcclxudmFyIGdsb2JhbEVtaXR0ZXIgPSBudWxsO1xyXG52YXIgbmVlZGVkQ291bnQgPSAwO1xyXG4vKlxyXG5MaXN0ZW5zIHRvIGRvY3VtZW50IGFuZCB3aW5kb3ctbGV2ZWwgdXNlci1pbnRlcmFjdGlvbiBldmVudHMsIGxpa2UgdG91Y2ggZXZlbnRzIGFuZCBtb3VzZSBldmVudHMsXHJcbmFuZCBmaXJlcyB0aGVzZSBldmVudHMgYXMtaXMgdG8gd2hvZXZlciBpcyBvYnNlcnZpbmcgYSBHbG9iYWxFbWl0dGVyLlxyXG5CZXN0IHdoZW4gdXNlZCBhcyBhIHNpbmdsZXRvbiB2aWEgR2xvYmFsRW1pdHRlci5nZXQoKVxyXG5cbk5vcm1hbGl6ZXMgbW91c2UvdG91Y2ggZXZlbnRzLiBGb3IgZXhhbXBsZXM6XHJcbi0gaWdub3JlcyB0aGUgdGhlIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgdGhhdCBoYXBwZW4gYWZ0ZXIgYSBxdWljayB0YXA6IG1vdXNlbW92ZSttb3VzZWRvd24rbW91c2V1cCtjbGlja1xyXG4tIGNvbXBlbnNhdGVzIGZvciB2YXJpb3VzIGJ1Z2d5IHNjZW5hcmlvcyB3aGVyZSBhIHRvdWNoZW5kIGRvZXMgbm90IGZpcmVcclxuKi9cclxudmFyIEdsb2JhbEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHbG9iYWxFbWl0dGVyKCkge1xyXG4gICAgICAgIHRoaXMuaXNUb3VjaGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2VJZ25vcmVEZXB0aCA9IDA7XHJcbiAgICB9XHJcbiAgICAvLyBnZXRzIHRoZSBzaW5nbGV0b25cclxuICAgIEdsb2JhbEVtaXR0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghZ2xvYmFsRW1pdHRlcikge1xyXG4gICAgICAgICAgICBnbG9iYWxFbWl0dGVyID0gbmV3IEdsb2JhbEVtaXR0ZXIoKTtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnbG9iYWxFbWl0dGVyO1xyXG4gICAgfTtcclxuICAgIC8vIGNhbGxlZCB3aGVuIGFuIG9iamVjdCBrbm93cyBpdCB3aWxsIG5lZWQgYSBHbG9iYWxFbWl0dGVyIGluIHRoZSBuZWFyIGZ1dHVyZS5cclxuICAgIEdsb2JhbEVtaXR0ZXIubmVlZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEdsb2JhbEVtaXR0ZXIuZ2V0KCk7IC8vIGVuc3VyZXMgZ2xvYmFsRW1pdHRlclxyXG4gICAgICAgIG5lZWRlZENvdW50Kys7XHJcbiAgICB9O1xyXG4gICAgLy8gY2FsbGVkIHdoZW4gdGhlIG9iamVjdCB0aGF0IG9yaWdpbmFsbHkgY2FsbGVkIG5lZWRlZCgpIGRvZXNuJ3QgbmVlZCBhIEdsb2JhbEVtaXR0ZXIgYW55bW9yZS5cclxuICAgIEdsb2JhbEVtaXR0ZXIudW5uZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbmVlZGVkQ291bnQtLTtcclxuICAgICAgICBpZiAoIW5lZWRlZENvdW50KSB7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIudW5iaW5kKCk7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXHJcbiAgICAgICAgICAgIHRvdWNoY2FuY2VsOiB0aGlzLmhhbmRsZVRvdWNoQ2FuY2VsLFxyXG4gICAgICAgICAgICB0b3VjaGVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZCxcclxuICAgICAgICAgICAgbW91c2Vkb3duOiB0aGlzLmhhbmRsZU1vdXNlRG93bixcclxuICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcclxuICAgICAgICAgICAgbW91c2V1cDogdGhpcy5oYW5kbGVNb3VzZVVwLFxyXG4gICAgICAgICAgICBjbGljazogdGhpcy5oYW5kbGVDbGljayxcclxuICAgICAgICAgICAgc2VsZWN0c3RhcnQ6IHRoaXMuaGFuZGxlU2VsZWN0U3RhcnQsXHJcbiAgICAgICAgICAgIGNvbnRleHRtZW51OiB0aGlzLmhhbmRsZUNvbnRleHRNZW51XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcHJldmVudERlZmF1bHRcclxuICAgICAgICAvLyBiZWNhdXNlIGh0dHBzOi8vd3d3LmNocm9tZXN0YXR1cy5jb20vZmVhdHVyZXMvNTA5MzU2NjAwNzIxNDA4MFxyXG4gICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIHBlcmZvcm1hbmNlIGJlY2F1c2UgdGhpcyBpcyBhIGdsb2JhbCBoYW5kbGVyXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlUHJveHkgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlVG91Y2hNb3ZlKCQuRXZlbnQoZXYpKTtcclxuICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0gLy8gYWxsb3dzIHByZXZlbnREZWZhdWx0KClcclxuICAgICAgICApO1xyXG4gICAgICAgIC8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gZ2V0IGNhbGxlZCB3aGVuIEFOWSBzY3JvbGwgYWN0aW9uIGhhcHBlbnMgb24gdGhlIHBhZ2UuXHJcbiAgICAgICAgLy8gdGhpcyB3YXMgaW1wb3NzaWJsZSB0byBkbyB3aXRoIG5vcm1hbCBvbi9vZmYgYmVjYXVzZSAnc2Nyb2xsJyBkb2Vzbid0IGJ1YmJsZS5cclxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMjk1NDU2NS85NjM0MlxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbFByb3h5ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVNjcm9sbCgkLkV2ZW50KGV2KSk7XHJcbiAgICAgICAgfSwgdHJ1ZSAvLyB1c2VDYXB0dXJlXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZVByb3h5KTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGxQcm94eSwgdHJ1ZSAvLyB1c2VDYXB0dXJlXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbiAgICAvLyBUb3VjaCBIYW5kbGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBpZiBhIHByZXZpb3VzIHRvdWNoIGludGVyYWN0aW9uIG5ldmVyIGVuZGVkIHdpdGggYSB0b3VjaGVuZCwgdGhlbiBpbXBsaWNpdGx5IGVuZCBpdCxcclxuICAgICAgICAvLyBidXQgc2luY2UgYSBuZXcgdG91Y2ggaW50ZXJhY3Rpb24gaXMgYWJvdXQgdG8gYmVnaW4sIGRvbid0IHN0YXJ0IHRoZSBtb3VzZSBpZ25vcmUgcGVyaW9kLlxyXG4gICAgICAgIHRoaXMuc3RvcFRvdWNoKGV2LCB0cnVlKTsgLy8gc2tpcE1vdXNlSWdub3JlPXRydWVcclxuICAgICAgICB0aGlzLmlzVG91Y2hpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcigndG91Y2hzdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndG91Y2htb3ZlJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaENhbmNlbCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaGNhbmNlbCcsIGV2KTtcclxuICAgICAgICAgICAgLy8gSGF2ZSB0b3VjaGNhbmNlbCBmaXJlIGFuIGFydGlmaWNpYWwgdG91Y2hlbmQuIFRoYXQgd2F5LCBoYW5kbGVycyB3b24ndCBuZWVkIHRvIGxpc3RlbiB0byBib3RoLlxyXG4gICAgICAgICAgICAvLyBJZiB0b3VjaGVuZCBmaXJlcyBsYXRlciwgaXQgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IGIvYyBpc1RvdWNoaW5nIHdpbGwgYmUgZmFsc2UuXHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFRvdWNoKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnN0b3BUb3VjaChldik7XHJcbiAgICB9O1xyXG4gICAgLy8gTW91c2UgSGFuZGxlcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlZG93bicsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNldXAnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTWlzYyBIYW5kbGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3RzdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0TWVudSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignY29udGV4dG1lbnUnLCBldik7XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzY3JvbGwnLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5zdG9wVG91Y2ggPSBmdW5jdGlvbiAoZXYsIHNraXBNb3VzZUlnbm9yZSkge1xyXG4gICAgICAgIGlmIChza2lwTW91c2VJZ25vcmUgPT09IHZvaWQgMCkgeyBza2lwTW91c2VJZ25vcmUgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndG91Y2hlbmQnLCBldik7XHJcbiAgICAgICAgICAgIGlmICghc2tpcE1vdXNlSWdub3JlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VG91Y2hNb3VzZUlnbm9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnN0YXJ0VG91Y2hNb3VzZUlnbm9yZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3YWl0ID0gZXhwb3J0SG9va3MudG91Y2hNb3VzZUlnbm9yZVdhaXQ7XHJcbiAgICAgICAgaWYgKHdhaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZUlnbm9yZURlcHRoKys7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubW91c2VJZ25vcmVEZXB0aC0tO1xyXG4gICAgICAgICAgICB9LCB3YWl0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUb3VjaGluZyB8fCBCb29sZWFuKHRoaXMubW91c2VJZ25vcmVEZXB0aCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEdsb2JhbEVtaXR0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEdsb2JhbEVtaXR0ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oR2xvYmFsRW1pdHRlcik7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhHbG9iYWxFbWl0dGVyKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZXhwb3J0SG9va3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuZXhwb3J0cy52aWV3SGFzaCA9IHt9O1xyXG5leHBvcnRIb29rcy52aWV3cyA9IGV4cG9ydHMudmlld0hhc2g7XHJcbmZ1bmN0aW9uIGRlZmluZVZpZXcodmlld05hbWUsIHZpZXdDb25maWcpIHtcclxuICAgIGV4cG9ydHMudmlld0hhc2hbdmlld05hbWVdID0gdmlld0NvbmZpZztcclxufVxyXG5leHBvcnRzLmRlZmluZVZpZXcgPSBkZWZpbmVWaWV3O1xyXG5mdW5jdGlvbiBnZXRWaWV3Q29uZmlnKHZpZXdOYW1lKSB7XHJcbiAgICByZXR1cm4gZXhwb3J0cy52aWV3SGFzaFt2aWV3TmFtZV07XHJcbn1cclxuZXhwb3J0cy5nZXRWaWV3Q29uZmlnID0gZ2V0Vmlld0NvbmZpZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcclxuLyogVHJhY2tzIG1vdXNlIG1vdmVtZW50cyBvdmVyIGEgY29tcG9uZW50IGFuZCByYWlzZXMgZXZlbnRzIGFib3V0IHdoaWNoIGhpdCB0aGUgbW91c2UgaXMgb3Zlci5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbm9wdGlvbnM6XHJcbi0gc3ViamVjdEVsXHJcbi0gc3ViamVjdENlbnRlclxyXG4qL1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGl0RHJhZ0xpc3RlbmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGl0RHJhZ0xpc3RlbmVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIENhbGxlZCB3aGVuIGRyYWcgbGlzdGVuaW5nIHN0YXJ0cyAoYnV0IGEgcmVhbCBkcmFnIGhhcyBub3QgbmVjZXNzYXJpbHkgYmVnYW4pLlxyXG4gICAgLy8gZXYgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIGRyYWdnaW5nIHdhcyBzdGFydGVkIG1hbnVhbGx5LlxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHN1YmplY3RFbCA9IHRoaXMuc3ViamVjdEVsO1xyXG4gICAgICAgIHZhciBzdWJqZWN0UmVjdDtcclxuICAgICAgICB2YXIgb3JpZ1BvaW50O1xyXG4gICAgICAgIHZhciBwb2ludDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5oaXRzTmVlZGVkKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2Nyb2xsQm91bmRzKCk7IC8vIGZvciBhdXRvc2Nyb2xsXHJcbiAgICAgICAgaWYgKGV2KSB7XHJcbiAgICAgICAgICAgIG9yaWdQb2ludCA9IHsgbGVmdDogdXRpbF8xLmdldEV2WChldiksIHRvcDogdXRpbF8xLmdldEV2WShldikgfTtcclxuICAgICAgICAgICAgcG9pbnQgPSBvcmlnUG9pbnQ7XHJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0aGUgcG9pbnQgdG8gYm91bmRzIG9mIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViamVjdFJlY3QgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0KHN1YmplY3RFbCk7IC8vIHVzZWQgZm9yIGNlbnRlcmluZyBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHV0aWxfMS5jb25zdHJhaW5Qb2ludChwb2ludCwgc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ0hpdCA9IHRoaXMucXVlcnlIaXQocG9pbnQubGVmdCwgcG9pbnQudG9wKTtcclxuICAgICAgICAgICAgLy8gdHJlYXQgdGhlIGNlbnRlciBvZiB0aGUgc3ViamVjdCBhcyB0aGUgY29sbGlzaW9uIHBvaW50P1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsICYmIHRoaXMub3B0aW9ucy5zdWJqZWN0Q2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIHRoZSBhcmVhIHRoZSBzdWJqZWN0IG92ZXJsYXBzIHRoZSBoaXQuIGJlc3QgZm9yIGxhcmdlIHN1YmplY3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2tpcCB0aGlzIGlmIGhpdCBkaWRuJ3Qgc3VwcGx5IGxlZnQvcmlnaHQvdG9wL2JvdHRvbVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gdXRpbF8xLmludGVyc2VjdFJlY3RzKHRoaXMub3JpZ0hpdCwgc3ViamVjdFJlY3QpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0OyAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSB1dGlsXzEuZ2V0UmVjdENlbnRlcihzdWJqZWN0UmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHV0aWxfMS5kaWZmUG9pbnRzKHBvaW50LCBvcmlnUG9pbnQpOyAvLyBwb2ludCAtIG9yaWdQb2ludFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZC4gZG8gaXQgYWZ0ZXIgb3JpZ0hpdCBoYXMgYmVlbiBjb21wdXRlZFxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgYWN0dWFsIGRyYWcgaGFzIHN0YXJ0ZWRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGhpdDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgICAgICAvLyBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGlzLm9yaWdIaXQgaWYgdGhlIG1pbi1kaXN0YW5jZSBpcyBsYXJnZVxyXG4gICAgICAgIGhpdCA9IHRoaXMucXVlcnlIaXQodXRpbF8xLmdldEV2WChldiksIHV0aWxfMS5nZXRFdlkoZXYpKTtcclxuICAgICAgICAvLyByZXBvcnQgdGhlIGluaXRpYWwgaGl0IHRoZSBtb3VzZSBpcyBvdmVyXHJcbiAgICAgICAgLy8gZXNwZWNpYWxseSBpbXBvcnRhbnQgaWYgbm8gbWluLWRpc3RhbmNlIGFuZCBkcmFnIHN0YXJ0cyBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnIG1vdmVzXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWcgPSBmdW5jdGlvbiAoZHgsIGR5LCBldikge1xyXG4gICAgICAgIHZhciBoaXQ7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVEcmFnLmNhbGwodGhpcywgZHgsIGR5LCBldik7XHJcbiAgICAgICAgaGl0ID0gdGhpcy5xdWVyeUhpdCh1dGlsXzEuZ2V0RXZYKGV2KSwgdXRpbF8xLmdldEV2WShldikpO1xyXG4gICAgICAgIGlmICghaXNIaXRzRXF1YWwoaGl0LCB0aGlzLmhpdCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUhpdE91dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0T3ZlcihoaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGRyYWdnaW5nIGhhcyBiZWVuIHN0b3BwZWRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZC5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBhIHRoZSBtb3VzZSBoYXMganVzdCBtb3ZlZCBvdmVyIGEgbmV3IGhpdFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVIaXRPdmVyID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciBpc09yaWcgPSBpc0hpdHNFcXVhbChoaXQsIHRoaXMub3JpZ0hpdCk7XHJcbiAgICAgICAgdGhpcy5oaXQgPSBoaXQ7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXRPdmVyJywgdGhpcy5oaXQsIGlzT3JpZywgdGhpcy5vcmlnSGl0KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgbW91c2UgaGFzIGp1c3QgbW92ZWQgb3V0IG9mIGEgaGl0XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUhpdE91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXRPdXQnLCB0aGlzLmhpdCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmhpdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBhZnRlciBhIGhpdE91dC4gQWxzbyBjYWxsZWQgYmVmb3JlIGEgZHJhZ1N0b3BcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSGl0RG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXREb25lJywgdGhpcy5oaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgaW50ZXJhY3Rpb24gZW5kcywgd2hldGhlciB0aGVyZSB3YXMgYSByZWFsIGRyYWcgb3Igbm90XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uRW5kID0gZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQuY2FsbCh0aGlzLCBldiwgaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgIHRoaXMub3JpZ0hpdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oaXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmhpdHNOb3ROZWVkZWQoKTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIC8vIGhpdHMnIGFic29sdXRlIHBvc2l0aW9ucyB3aWxsIGJlIGluIG5ldyBwbGFjZXMgYWZ0ZXIgYSB1c2VyJ3Mgc2Nyb2xsLlxyXG4gICAgICAgIC8vIEhBQ0sgZm9yIHJlY29tcHV0aW5nLlxyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVsZWFzZUhpdHMoKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgaGl0IHVuZGVybmVhdGggdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgZ2l2ZW4gbW91c2UgZXZlbnRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAobGVmdCwgdG9wKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29vcmRBZGp1c3QpIHtcclxuICAgICAgICAgICAgbGVmdCArPSB0aGlzLmNvb3JkQWRqdXN0LmxlZnQ7XHJcbiAgICAgICAgICAgIHRvcCArPSB0aGlzLmNvb3JkQWRqdXN0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhpdERyYWdMaXN0ZW5lcjtcclxufShEcmFnTGlzdGVuZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEhpdERyYWdMaXN0ZW5lcjtcclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhpdHMgYXJlIGlkZW50aWNhbGx5IGVxdWFsLiBgZmFsc2VgIG90aGVyd2lzZS4gTXVzdCBiZSBmcm9tIHRoZSBzYW1lIGNvbXBvbmVudC5cclxuLy8gVHdvIG51bGwgdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBlcXVhbCwgYXMgdHdvIFwib3V0IG9mIHRoZSBjb21wb25lbnRcIiBzdGF0ZXMgYXJlIHRoZSBzYW1lLlxyXG5mdW5jdGlvbiBpc0hpdHNFcXVhbChoaXQwLCBoaXQxKSB7XHJcbiAgICBpZiAoIWhpdDAgJiYgIWhpdDEpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChoaXQwICYmIGhpdDEpIHtcclxuICAgICAgICByZXR1cm4gaGl0MC5jb21wb25lbnQgPT09IGhpdDEuY29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgIGlzSGl0UHJvcHNXaXRoaW4oaGl0MCwgaGl0MSkgJiZcclxuICAgICAgICAgICAgaXNIaXRQcm9wc1dpdGhpbihoaXQxLCBoaXQwKTsgLy8gZW5zdXJlcyBhbGwgcHJvcHMgYXJlIGlkZW50aWNhbFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBhbGwgb2Ygc3ViSGl0J3Mgbm9uLXN0YW5kYXJkIHByb3BlcnRpZXMgYXJlIHdpdGhpbiBzdXBlckhpdFxyXG5mdW5jdGlvbiBpc0hpdFByb3BzV2l0aGluKHN1YkhpdCwgc3VwZXJIaXQpIHtcclxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHN1YkhpdCkge1xyXG4gICAgICAgIGlmICghL14oY29tcG9uZW50fGxlZnR8cmlnaHR8dG9wfGJvdHRvbSkkLy50ZXN0KHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICBpZiAoc3ViSGl0W3Byb3BOYW1lXSAhPT0gc3VwZXJIaXRbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyNCAqLyxcbi8qIDI1ICovLFxuLyogMjYgKi8sXG4vKiAyNyAqLyxcbi8qIDI4ICovLFxuLyogMjkgKi8sXG4vKiAzMCAqLyxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIGV4cG9ydEhvb2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaCA9IHt9O1xyXG5leHBvcnRIb29rcy5sb2NhbGVzID0gZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoO1xyXG4vLyBOT1RFOiBjYW4ndCBndWFyYW50ZWUgYW55IG9mIHRoZXNlIGNvbXB1dGF0aW9ucyB3aWxsIHJ1biBiZWNhdXNlIG5vdCBldmVyeSBsb2NhbGUgaGFzIGRhdGVwaWNrZXJcclxuLy8gY29uZmlncywgc28gbWFrZSBzdXJlIHRoZXJlIGFyZSBFbmdsaXNoIGZhbGxiYWNrcyBmb3IgdGhlc2UgaW4gdGhlIGRlZmF1bHRzIGZpbGUuXHJcbnZhciBkcENvbXB1dGFibGVPcHRpb25zID0ge1xyXG4gICAgYnV0dG9uVGV4dDogZnVuY3Rpb24gKGRwT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2xhdGlvbnMgc29tZXRpbWVzIHdyb25nbHkgY29udGFpbiBIVE1MIGVudGl0aWVzXHJcbiAgICAgICAgICAgIHByZXY6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMucHJldlRleHQpLFxyXG4gICAgICAgICAgICBuZXh0OiB1dGlsXzEuc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLm5leHRUZXh0KSxcclxuICAgICAgICAgICAgdG9kYXk6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMuY3VycmVudFRleHQpXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiTU1NTSBZWVlZXCIgLT4gXCJTZXB0ZW1iZXIgMjAxNFwiXHJcbiAgICBtb250aFllYXJGb3JtYXQ6IGZ1bmN0aW9uIChkcE9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZHBPcHRpb25zLnNob3dNb250aEFmdGVyWWVhciA/XHJcbiAgICAgICAgICAgICdZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddIE1NTU0nIDpcclxuICAgICAgICAgICAgJ01NTU0gWVlZWVsnICsgZHBPcHRpb25zLnllYXJTdWZmaXggKyAnXSc7XHJcbiAgICB9XHJcbn07XHJcbnZhciBtb21Db21wdXRhYmxlT3B0aW9ucyA9IHtcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJkZGQgTS9EXCIgLT4gXCJGcmkgOS8xNVwiXHJcbiAgICBkYXlPZk1vbnRoRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucywgZmNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdCA9IG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ2wnKTsgLy8gZm9yIHRoZSBmb3JtYXQgbGlrZSBcIk0vRC9ZWVlZXCJcclxuICAgICAgICAvLyBzdHJpcCB0aGUgeWVhciBvZmYgdGhlIGVkZ2UsIGFzIHdlbGwgYXMgb3RoZXIgbWlzYyBub24td2hpdGVzcGFjZSBjaGFyc1xyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9eWStbXlxcd1xcc10qfFteXFx3XFxzXSpZKyQvZywgJycpO1xyXG4gICAgICAgIGlmIChmY09wdGlvbnMuaXNSVEwpIHtcclxuICAgICAgICAgICAgZm9ybWF0ICs9ICcgZGRkJzsgLy8gZm9yIFJUTCwgYWRkIGRheS1vZi13ZWVrIHRvIGVuZFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gJ2RkZCAnICsgZm9ybWF0OyAvLyBmb3IgTFRSLCBhZGQgZGF5LW9mLXdlZWsgdG8gYmVnaW5uaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImg6bW1hXCIgLT4gXCI2OjAwcG1cIlxyXG4gICAgbWVkaXVtVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKWFcIiAtPiBcIjZwbVwiIC8gXCI2OjMwcG1cIlxyXG4gICAgc21hbGxUaW1lRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCc6bW0nLCAnKDptbSknKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaCg6bW0pdFwiIC0+IFwiNnBcIiAvIFwiNjozMHBcIlxyXG4gICAgZXh0cmFTbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoJzptbScsICcoOm1tKScpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxXbW0pJC8sICcoJDEpJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAndCcpOyAvLyBjb252ZXJ0IHRvIEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZSBvbmUtbGV0dGVyLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImhhXCIgLyBcIkhcIiAtPiBcIjZwbVwiIC8gXCIxOFwiXHJcbiAgICBob3VyRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCc6bW0nLCAnJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXFdtbSkkLywgJycpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbVwiIC0+IFwiNjozMFwiICh3aXRoIG5vIEFNL1BNKVxyXG4gICAgbm9NZXJpZGllbVRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBBTS9QTVxyXG4gICAgfVxyXG59O1xyXG4vLyBvcHRpb25zIHRoYXQgc2hvdWxkIGJlIGNvbXB1dGVkIG9mZiBsaXZlIGNhbGVuZGFyIG9wdGlvbnMgKGNvbnNpZGVycyBvdmVycmlkZSBvcHRpb25zKVxyXG4vLyBUT0RPOiBiZXN0IHBsYWNlIGZvciB0aGlzPyByZWxhdGVkIHRvIGxvY2FsZT9cclxuLy8gVE9ETzogZmxpcHBpbmcgdGV4dCBiYXNlZCBvbiBpc1JUTCBpcyBhIGJhZCBpZGVhIGJlY2F1c2UgdGhlIENTUyBgZGlyZWN0aW9uYCBtaWdodCB3YW50IHRvIGhhbmRsZSBpdFxyXG52YXIgaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHtcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJNbyAxNlwiXHJcbiAgICBzbWFsbERheURhdGVGb3JtYXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xyXG4gICAgICAgICAgICAnRCBkZCcgOlxyXG4gICAgICAgICAgICAnZGQgRCc7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIldrIDVcIlxyXG4gICAgd2Vla0Zvcm1hdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5pc1JUTCA/XHJcbiAgICAgICAgICAgICd3WyAnICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxyXG4gICAgICAgICAgICAnWycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICcgXXcnO1xyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJXazVcIlxyXG4gICAgc21hbGxXZWVrRm9ybWF0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmlzUlRMID9cclxuICAgICAgICAgICAgJ3dbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcclxuICAgICAgICAgICAgJ1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXXcnO1xyXG4gICAgfVxyXG59O1xyXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGNvbXB1dGFibGUgcHJvcGVydGllcyBpbiBvcHRpb25zTWFuYWdlclxyXG5mdW5jdGlvbiBwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgJC5lYWNoKGluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvcHRpb25zW25hbWVdID0gZnVuYyhvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucztcclxuLy8gSW5pdGlhbGl6ZSBqUXVlcnkgVUkgZGF0ZXBpY2tlciB0cmFuc2xhdGlvbnMgd2hpbGUgdXNpbmcgc29tZSBvZiB0aGUgdHJhbnNsYXRpb25zXHJcbi8vIFdpbGwgc2V0IHRoaXMgYXMgdGhlIGRlZmF1bHQgbG9jYWxlcyBmb3IgZGF0ZXBpY2tlci5cclxuZnVuY3Rpb24gZGF0ZXBpY2tlckxvY2FsZShsb2NhbGVDb2RlLCBkcExvY2FsZUNvZGUsIGRwT3B0aW9ucykge1xyXG4gICAgLy8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICB2YXIgZmNPcHRpb25zID0gZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdIHx8IChleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSB7fSk7XHJcbiAgICAvLyB0cmFuc2ZlciBzb21lIHNpbXBsZSBvcHRpb25zIGZyb20gZGF0ZXBpY2tlciB0byBmY1xyXG4gICAgZmNPcHRpb25zLmlzUlRMID0gZHBPcHRpb25zLmlzUlRMO1xyXG4gICAgZmNPcHRpb25zLndlZWtOdW1iZXJUaXRsZSA9IGRwT3B0aW9ucy53ZWVrSGVhZGVyO1xyXG4gICAgLy8gY29tcHV0ZSBzb21lIG1vcmUgY29tcGxleCBvcHRpb25zIGZyb20gZGF0ZXBpY2tlclxyXG4gICAgJC5lYWNoKGRwQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XHJcbiAgICAgICAgZmNPcHRpb25zW25hbWVdID0gZnVuYyhkcE9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIganFEYXRlUGlja2VyID0gJC5kYXRlcGlja2VyO1xyXG4gICAgLy8gaXMgalF1ZXJ5IFVJIERhdGVwaWNrZXIgaXMgb24gdGhlIHBhZ2U/XHJcbiAgICBpZiAoanFEYXRlUGlja2VyKSB7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGxvY2FsZSBkYXRhLlxyXG4gICAgICAgIC8vIEZ1bGxDYWxlbmRhciBhbmQgTW9tZW50SlMgdXNlIGxvY2FsZSBjb2RlcyBsaWtlIFwicHQtYnJcIiBidXQgRGF0ZXBpY2tlclxyXG4gICAgICAgIC8vIGRvZXMgaXQgbGlrZSBcInB0LUJSXCIgb3IgaWYgaXQgZG9lc24ndCBoYXZlIHRoZSBsb2NhbGUsIG1heWJlIGp1c3QgXCJwdFwiLlxyXG4gICAgICAgIC8vIE1ha2UgYW4gYWxpYXMgc28gdGhlIGxvY2FsZSBjYW4gYmUgcmVmZXJlbmNlZCBlaXRoZXIgd2F5LlxyXG4gICAgICAgIGpxRGF0ZVBpY2tlci5yZWdpb25hbFtkcExvY2FsZUNvZGVdID1cclxuICAgICAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsW2xvY2FsZUNvZGVdID0gLy8gYWxpYXNcclxuICAgICAgICAgICAgICAgIGRwT3B0aW9ucztcclxuICAgICAgICAvLyBBbGlhcyAnZW4nIHRvIHRoZSBkZWZhdWx0IGxvY2FsZSBkYXRhLiBEbyB0aGlzIGV2ZXJ5IHRpbWUuXHJcbiAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsLmVuID0ganFEYXRlUGlja2VyLnJlZ2lvbmFsWycnXTtcclxuICAgICAgICAvLyBTZXQgYXMgRGF0ZXBpY2tlcidzIGdsb2JhbCBkZWZhdWx0cy5cclxuICAgICAgICBqcURhdGVQaWNrZXIuc2V0RGVmYXVsdHMoZHBPcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmRhdGVwaWNrZXJMb2NhbGUgPSBkYXRlcGlja2VyTG9jYWxlO1xyXG4vLyBTZXRzIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyB0cmFuc2xhdGlvbnMuIFdpbGwgc2V0IHRoZSBsb2NhbGVzIGFzIHRoZSBnbG9iYWwgZGVmYXVsdC5cclxuZnVuY3Rpb24gbG9jYWxlKGxvY2FsZUNvZGUsIG5ld0ZjT3B0aW9ucykge1xyXG4gICAgdmFyIGZjT3B0aW9ucztcclxuICAgIHZhciBtb21PcHRpb25zO1xyXG4gICAgLy8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICBmY09wdGlvbnMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gfHwgKGV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IHt9KTtcclxuICAgIC8vIHByb3ZpZGVkIG5ldyBvcHRpb25zIGZvciB0aGlzIGxvY2FsZXM/IG1lcmdlIHRoZW0gaW5cclxuICAgIGlmIChuZXdGY09wdGlvbnMpIHtcclxuICAgICAgICBmY09wdGlvbnMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKFtmY09wdGlvbnMsIG5ld0ZjT3B0aW9uc10pO1xyXG4gICAgfVxyXG4gICAgLy8gY29tcHV0ZSBsb2NhbGUgb3B0aW9ucyB0aGF0IHdlcmVuJ3QgZGVmaW5lZC5cclxuICAgIC8vIGFsd2F5cyBkbyB0aGlzLiBuZXdGY09wdGlvbnMgY2FuIGJlIHVuZGVmaW5lZCB3aGVuIGluaXRpYWxpemluZyBmcm9tIGkxOG4gZmlsZSxcclxuICAgIC8vIHNvIG5vIHdheSB0byB0ZWxsIGlmIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gb3IgYSBkZWZhdWx0LXNldHRpbmcuXHJcbiAgICBtb21PcHRpb25zID0gZ2V0TW9tZW50TG9jYWxlRGF0YShsb2NhbGVDb2RlKTsgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cclxuICAgICQuZWFjaChtb21Db21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICBpZiAoZmNPcHRpb25zW25hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgZmNPcHRpb25zW25hbWVdID0gKGZ1bmMpKG1vbU9wdGlvbnMsIGZjT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBzZXQgaXQgYXMgdGhlIGRlZmF1bHQgbG9jYWxlIGZvciBGdWxsQ2FsZW5kYXJcclxuICAgIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5sb2NhbGUgPSBsb2NhbGVDb2RlO1xyXG59XHJcbmV4cG9ydHMubG9jYWxlID0gbG9jYWxlO1xyXG4vLyBSZXR1cm5zIG1vbWVudCdzIGludGVybmFsIGxvY2FsZSBkYXRhLiBJZiBkb2Vzbid0IGV4aXN0LCByZXR1cm5zIEVuZ2xpc2guXHJcbmZ1bmN0aW9uIGdldE1vbWVudExvY2FsZURhdGEobG9jYWxlQ29kZSkge1xyXG4gICAgcmV0dXJuIG1vbWVudC5sb2NhbGVEYXRhKGxvY2FsZUNvZGUpIHx8IG1vbWVudC5sb2NhbGVEYXRhKCdlbicpO1xyXG59XHJcbmV4cG9ydHMuZ2V0TW9tZW50TG9jYWxlRGF0YSA9IGdldE1vbWVudExvY2FsZURhdGE7XHJcbi8vIEluaXRpYWxpemUgRW5nbGlzaCBieSBmb3JjaW5nIGNvbXB1dGF0aW9uIG9mIG1vbWVudC1kZXJpdmVkIG9wdGlvbnMuXHJcbi8vIEFsc28sIHNldHMgaXQgYXMgdGhlIGRlZmF1bHQuXHJcbmxvY2FsZSgnZW4nLCBvcHRpb25zXzEuZW5nbGlzaERlZmF1bHRzKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuZXhwb3J0cy5nbG9iYWxEZWZhdWx0cyA9IHtcclxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxyXG4gICAgbW9udGhZZWFyRm9ybWF0OiAnTU1NTSBZWVlZJyxcclxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMjowMDowMCcsXHJcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXlzOiAxIH0sXHJcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxyXG4gICAgbmV4dERheVRocmVzaG9sZDogJzA5OjAwOjAwJyxcclxuICAgIC8vIGRpc3BsYXlcclxuICAgIGNvbHVtbkhlYWRlcjogdHJ1ZSxcclxuICAgIGRlZmF1bHRWaWV3OiAnbW9udGgnLFxyXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXHJcbiAgICBoZWFkZXI6IHtcclxuICAgICAgICBsZWZ0OiAndGl0bGUnLFxyXG4gICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgcmlnaHQ6ICd0b2RheSBwcmV2LG5leHQnXHJcbiAgICB9LFxyXG4gICAgd2Vla2VuZHM6IHRydWUsXHJcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXHJcbiAgICB3ZWVrTnVtYmVyVGl0bGU6ICdXJyxcclxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcclxuICAgIC8vIGVkaXRhYmxlOiBmYWxzZSxcclxuICAgIC8vIG5vd0luZGljYXRvcjogZmFsc2UsXHJcbiAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxyXG4gICAgbWluVGltZTogJzAwOjAwOjAwJyxcclxuICAgIG1heFRpbWU6ICcyNDowMDowMCcsXHJcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxyXG4gICAgLy8gZXZlbnQgYWpheFxyXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxyXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcclxuICAgIGVuZFBhcmFtOiAnZW5kJyxcclxuICAgIHRpbWV6b25lUGFyYW06ICd0aW1lem9uZScsXHJcbiAgICB0aW1lem9uZTogZmFsc2UsXHJcbiAgICAvLyBhbGxEYXlEZWZhdWx0OiB1bmRlZmluZWQsXHJcbiAgICAvLyBsb2NhbGVcclxuICAgIGxvY2FsZTogbnVsbCxcclxuICAgIGlzUlRMOiBmYWxzZSxcclxuICAgIGJ1dHRvblRleHQ6IHtcclxuICAgICAgICBwcmV2OiAncHJldicsXHJcbiAgICAgICAgbmV4dDogJ25leHQnLFxyXG4gICAgICAgIHByZXZZZWFyOiAncHJldiB5ZWFyJyxcclxuICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXHJcbiAgICAgICAgeWVhcjogJ3llYXInLFxyXG4gICAgICAgIHRvZGF5OiAndG9kYXknLFxyXG4gICAgICAgIG1vbnRoOiAnbW9udGgnLFxyXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcclxuICAgICAgICBkYXk6ICdkYXknXHJcbiAgICB9LFxyXG4gICAgLy8gYnV0dG9uSWNvbnM6IG51bGwsXHJcbiAgICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXHJcbiAgICAvLyBhbGxvd3Mgc2V0dGluZyBhIG1pbi1oZWlnaHQgdG8gdGhlIGV2ZW50IHNlZ21lbnQgdG8gcHJldmVudCBzaG9ydCBldmVudHMgb3ZlcmxhcHBpbmcgZWFjaCBvdGhlclxyXG4gICAgYWdlbmRhRXZlbnRNaW5IZWlnaHQ6IDAsXHJcbiAgICAvLyBqcXVlcnktdWkgdGhlbWluZ1xyXG4gICAgdGhlbWU6IGZhbHNlLFxyXG4gICAgLy8gdGhlbWVCdXR0b25JY29uczogbnVsbCxcclxuICAgIC8vIGV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmYWxzZSxcclxuICAgIGRyYWdPcGFjaXR5OiAuNzUsXHJcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcclxuICAgIGRyYWdTY3JvbGw6IHRydWUsXHJcbiAgICAvLyBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcclxuICAgIC8vIHNlbGVjdE1pbkRpc3RhbmNlOiAwLFxyXG4gICAgZHJvcEFjY2VwdDogJyonLFxyXG4gICAgZXZlbnRPcmRlcjogJ3RpdGxlJyxcclxuICAgIC8vIGV2ZW50UmVuZGVyV2FpdDogbnVsbCxcclxuICAgIGV2ZW50TGltaXQ6IGZhbHNlLFxyXG4gICAgZXZlbnRMaW1pdFRleHQ6ICdtb3JlJyxcclxuICAgIGV2ZW50TGltaXRDbGljazogJ3BvcG92ZXInLFxyXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogJ0xMJyxcclxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcclxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsXHJcbiAgICBsb25nUHJlc3NEZWxheTogMTAwMFxyXG59O1xyXG5leHBvcnRzLmVuZ2xpc2hEZWZhdWx0cyA9IHtcclxuICAgIGRheVBvcG92ZXJGb3JtYXQ6ICdkZGRkLCBNTU1NIEQnXHJcbn07XHJcbmV4cG9ydHMucnRsRGVmYXVsdHMgPSB7XHJcbiAgICBoZWFkZXI6IHtcclxuICAgICAgICBsZWZ0OiAnbmV4dCxwcmV2IHRvZGF5JyxcclxuICAgICAgICBjZW50ZXI6ICcnLFxyXG4gICAgICAgIHJpZ2h0OiAndGl0bGUnXHJcbiAgICB9LFxyXG4gICAgYnV0dG9uSWNvbnM6IHtcclxuICAgICAgICBwcmV2OiAncmlnaHQtc2luZ2xlLWFycm93JyxcclxuICAgICAgICBuZXh0OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgICAgIHByZXZZZWFyOiAncmlnaHQtZG91YmxlLWFycm93JyxcclxuICAgICAgICBuZXh0WWVhcjogJ2xlZnQtZG91YmxlLWFycm93J1xyXG4gICAgfSxcclxuICAgIHRoZW1lQnV0dG9uSWNvbnM6IHtcclxuICAgICAgICBwcmV2OiAnY2lyY2xlLXRyaWFuZ2xlLWUnLFxyXG4gICAgICAgIG5leHQ6ICdjaXJjbGUtdHJpYW5nbGUtdycsXHJcbiAgICAgICAgbmV4dFllYXI6ICdzZWVrLXByZXYnLFxyXG4gICAgICAgIHByZXZZZWFyOiAnc2Vlay1uZXh0J1xyXG4gICAgfVxyXG59O1xyXG52YXIgY29tcGxleE9wdGlvbnMgPSBbXHJcbiAgICAnaGVhZGVyJyxcclxuICAgICdmb290ZXInLFxyXG4gICAgJ2J1dHRvblRleHQnLFxyXG4gICAgJ2J1dHRvbkljb25zJyxcclxuICAgICd0aGVtZUJ1dHRvbkljb25zJ1xyXG5dO1xyXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3RcclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbk9ianMpIHtcclxuICAgIHJldHVybiB1dGlsXzEubWVyZ2VQcm9wcyhvcHRpb25PYmpzLCBjb21wbGV4T3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5tZXJnZU9wdGlvbnMgPSBtZXJnZU9wdGlvbnM7XHJcblxuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLy8gQ2xhc3MgdGhhdCBhbGwgb3RoZXIgY2xhc3NlcyB3aWxsIGluaGVyaXQgZnJvbVxyXG52YXIgQ2xhc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDbGFzcygpIHtcclxuICAgIH1cclxuICAgIC8vIENhbGxlZCBvbiBhIGNsYXNzIHRvIGNyZWF0ZSBhIHN1YmNsYXNzLlxyXG4gICAgLy8gTElNSVRBVElPTjogY2Fubm90IHByb3ZpZGUgYSBjb25zdHJ1Y3RvciFcclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XHJcbiAgICAgICAgdmFyIFN1YkNsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN1YkNsYXNzO1xyXG4gICAgICAgIH0odGhpcykpO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMobWVtYmVycywgU3ViQ2xhc3MucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQWRkcyBuZXcgbWVtYmVyIHZhcmlhYmxlcy9tZXRob2RzIHRvIHRoZSBjbGFzcydzIHByb3RvdHlwZS5cclxuICAgIC8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbm90aGVyIGNsYXNzLCBvciBhIHBsYWluIG9iamVjdCBoYXNoIGNvbnRhaW5pbmcgbmV3IG1lbWJlcnMuXHJcbiAgICBDbGFzcy5taXhpbiA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhtZW1iZXJzLCB0aGlzLnByb3RvdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENsYXNzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDbGFzcztcclxuXG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBQYXJzYWJsZU1vZGVsTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA4KTtcclxudmFyIEV2ZW50RGVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnREZWYoc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBbXTtcclxuICAgICAgICB0aGlzLm1pc2NQcm9wcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgRXZlbnREZWYucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBkZWYgPSBuZXcgdGhpcyhzb3VyY2UpO1xyXG4gICAgICAgIGlmIChkZWYuYXBwbHlQcm9wcyhyYXdJbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLm5vcm1hbGl6ZUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ19mYycgKyAoRXZlbnREZWYudXVpZCsrKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgY29weS5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgY29weS5yYXdJZCA9IHRoaXMucmF3SWQ7XHJcbiAgICAgICAgY29weS51aWQgPSB0aGlzLnVpZDsgLy8gbm90IHJlYWxseSB1bmlxdWUgYW55bW9yZSA6KFxyXG4gICAgICAgIEV2ZW50RGVmLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHModGhpcywgY29weSk7XHJcbiAgICAgICAgY29weS5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZS5zbGljZSgpOyAvLyBjb3B5XHJcbiAgICAgICAgY29weS5taXNjUHJvcHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5oYXNJbnZlcnNlUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmluZygpID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaGFzQmdSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmluZyA9IHRoaXMuZ2V0UmVuZGVyaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmluZyA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcgfHwgcmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldFJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZW5kZXJpbmc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZS5jb25zdHJhaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbnN0cmFpbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jYWxlbmRhci5vcHQoJ2V2ZW50Q29uc3RyYWludCcpOyAvLyB3aGF0IGFib3V0IFZpZXcgb3B0aW9uP1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5nZXRPdmVybGFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zb3VyY2Uub3ZlcmxhcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5vdmVybGFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY2FsZW5kYXIub3B0KCdldmVudE92ZXJsYXAnKTsgLy8gd2hhdCBhYm91dCBWaWV3IG9wdGlvbj9cclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaXNTdGFydEV4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydEVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRFZGl0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN0YXJ0RWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmlzRHVyYXRpb25FeHBsaWNpdGx5RWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5kdXJhdGlvbkVkaXRhYmxlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5pc0V4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLnRvTGVnYWN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvYmogPSAkLmV4dGVuZCh7fSwgdGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIG9iai5faWQgPSB0aGlzLnVpZDtcclxuICAgICAgICBvYmouc291cmNlID0gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgb2JqLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnNsaWNlKCk7IC8vIGNvcHlcclxuICAgICAgICBvYmouYWxsRGF5ID0gdGhpcy5pc0FsbERheSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJhd0lkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgb2JqLmlkID0gdGhpcy5yYXdJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnREZWYuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLCBvYmopO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIGlmIChyYXdQcm9wcy5pZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBFdmVudERlZi5ub3JtYWxpemVJZCgodGhpcy5yYXdJZCA9IHJhd1Byb3BzLmlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gRXZlbnREZWYuZ2VuZXJhdGVJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMuX2lkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBTdHJpbmcocmF3UHJvcHMuX2lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudWlkID0gRXZlbnREZWYuZ2VuZXJhdGVJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50U291cmNlXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShyYXdQcm9wcy5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWlzY1Byb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgJC5leHRlbmQodGhpcy5taXNjUHJvcHMsIHJhd1Byb3BzKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi51dWlkID0gMDtcclxuICAgIEV2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmRlZmluZVN0YW5kYXJkUHJvcHM7XHJcbiAgICBFdmVudERlZi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZjtcclxuUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50RGVmKTtcclxuRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBub3QgYXV0b21hdGljYWxseSBhc3NpZ25lZCAoYGZhbHNlYClcclxuICAgIF9pZDogZmFsc2UsXHJcbiAgICBpZDogZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IGZhbHNlLFxyXG4gICAgc291cmNlOiBmYWxzZSxcclxuICAgIC8vIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgKGB0cnVlYClcclxuICAgIHRpdGxlOiB0cnVlLFxyXG4gICAgdXJsOiB0cnVlLFxyXG4gICAgcmVuZGVyaW5nOiB0cnVlLFxyXG4gICAgY29uc3RyYWludDogdHJ1ZSxcclxuICAgIG92ZXJsYXA6IHRydWUsXHJcbiAgICBlZGl0YWJsZTogdHJ1ZSxcclxuICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXHJcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiB0cnVlLFxyXG4gICAgY29sb3I6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXHJcbiAgICBib3JkZXJDb2xvcjogdHJ1ZSxcclxuICAgIHRleHRDb2xvcjogdHJ1ZVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTEpO1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuZnVuY3Rpb24gZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcyhldmVudERlZnMsIHVuem9uZWRSYW5nZSkge1xyXG4gICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBldmVudEluc3RhbmNlcy5wdXNoLmFwcGx5KGV2ZW50SW5zdGFuY2VzLCAvLyBhcHBlbmRcclxuICAgICAgICBldmVudERlZnNbaV0uYnVpbGRJbnN0YW5jZXModW56b25lZFJhbmdlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRJbnN0YW5jZXM7XHJcbn1cclxuZXhwb3J0cy5ldmVudERlZnNUb0V2ZW50SW5zdGFuY2VzID0gZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcztcclxuZnVuY3Rpb24gZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZShldmVudEluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gbmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUudW56b25lZFJhbmdlLCBldmVudEluc3RhbmNlLmRlZiwgZXZlbnRJbnN0YW5jZSk7XHJcbn1cclxuZXhwb3J0cy5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlID0gZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZTtcclxuZnVuY3Rpb24gZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQoZXZlbnRSYW5nZS51bnpvbmVkUmFuZ2UsIGV2ZW50UmFuZ2UuZXZlbnREZWYuaXNBbGxEYXkoKSksIGV2ZW50UmFuZ2UuZXZlbnREZWYsIGV2ZW50UmFuZ2UuZXZlbnRJbnN0YW5jZSAvLyBtaWdodCBub3QgZXhpc3RcclxuICAgICk7XHJcbn1cclxuZXhwb3J0cy5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludCA9IGV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50O1xyXG5mdW5jdGlvbiBldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2UoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUudW56b25lZFJhbmdlO1xyXG59XHJcbmV4cG9ydHMuZXZlbnRJbnN0YW5jZVRvVW56b25lZFJhbmdlID0gZXZlbnRJbnN0YW5jZVRvVW56b25lZFJhbmdlO1xyXG5mdW5jdGlvbiBldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50KGV2ZW50Rm9vdHByaW50KSB7XHJcbiAgICByZXR1cm4gZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50O1xyXG59XHJcbmV4cG9ydHMuZXZlbnRGb290cHJpbnRUb0NvbXBvbmVudEZvb3RwcmludCA9IGV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV2ZW50Rm9vdHByaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Rm9vdHByaW50ID0gY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWYgPSBldmVudERlZjtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEV2ZW50Rm9vdHByaW50LnByb3RvdHlwZS5nZXRFdmVudExlZ2FjeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnRJbnN0YW5jZSB8fCB0aGlzLmV2ZW50RGVmKS50b0xlZ2FjeSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudEZvb3RwcmludDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRGb290cHJpbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERlZk11dGF0aW9uKCkge1xyXG4gICAgfVxyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5jcmVhdGVGcm9tUmF3UHJvcHMgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgcmF3UHJvcHMsIGxhcmdlVW5pdCkge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50SW5zdGFuY2UuZGVmO1xyXG4gICAgICAgIHZhciBkYXRlUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBtaXNjUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgdmVyYmF0aW1TdGFuZGFyZFByb3BzID0ge307XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmSWQgPSBudWxsO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBudWxsO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZGVmTXV0YXRpb247XHJcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQuaXNTdGFuZGFyZFByb3AocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50RGVmLmlzU3RhbmRhcmRQcm9wKHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnREZWYubWlzY1Byb3BzW3Byb3BOYW1lXSAhPT0gcmF3UHJvcHNbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNjUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGVQcm9maWxlID0gRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQucGFyc2UoZGF0ZVByb3BzLCBldmVudERlZi5zb3VyY2UpO1xyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24gPSBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQuY3JlYXRlRnJvbURpZmYoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGUsIGxhcmdlVW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFuZGFyZFByb3BzLmlkICE9PSBldmVudERlZi5pZCkge1xyXG4gICAgICAgICAgICBldmVudERlZklkID0gc3RhbmRhcmRQcm9wcy5pZDsgLy8gb25seSBhcHBseSBpZiB0aGVyZSdzIGEgY2hhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXRpbF8xLmlzQXJyYXlzRXF1YWwoc3RhbmRhcmRQcm9wcy5jbGFzc05hbWUsIGV2ZW50RGVmLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gc3RhbmRhcmRQcm9wcy5jbGFzc05hbWU7IC8vIG9ubHkgYXBwbHkgaWYgdGhlcmUncyBhIGNoYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudERlZl8xLmRlZmF1bHQuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyhzdGFuZGFyZFByb3BzLCAvLyBzcmNcclxuICAgICAgICB2ZXJiYXRpbVN0YW5kYXJkUHJvcHMgLy8gZGVzdFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbigpO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLmV2ZW50RGVmSWQgPSBldmVudERlZklkO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICBkZWZNdXRhdGlvbi52ZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSB2ZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICAgICAgZGVmTXV0YXRpb24ubWlzY1Byb3BzID0gbWlzY1Byb3BzO1xyXG4gICAgICAgIGlmIChkYXRlTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgZGVmTXV0YXRpb24uZGF0ZU11dGF0aW9uID0gZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGV2ZW50RGVmIGFzc3VtZWQgdG8gYmUgYSBTaW5nbGVFdmVudERlZi5cclxuICAgIHJldHVybnMgYW4gdW5kbyBmdW5jdGlvbi5cclxuICAgICovXHJcbiAgICBFdmVudERlZk11dGF0aW9uLnByb3RvdHlwZS5tdXRhdGVTaW5nbGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb3JpZ0RhdGVQcm9maWxlO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICBvcmlnRGF0ZVByb2ZpbGUgPSBldmVudERlZi5kYXRlUHJvZmlsZTtcclxuICAgICAgICAgICAgZXZlbnREZWYuZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVNdXRhdGlvbi5idWlsZE5ld0RhdGVQcm9maWxlKG9yaWdEYXRlUHJvZmlsZSwgZXZlbnREZWYuc291cmNlLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgRFJZIHdpdGggRXZlbnREZWY6OmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wc1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50RGVmSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudERlZi5pZCA9IEV2ZW50RGVmXzEuZGVmYXVsdC5ub3JtYWxpemVJZCgoZXZlbnREZWYucmF3SWQgPSB0aGlzLmV2ZW50RGVmSWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgRFJZIHdpdGggRXZlbnREZWY6OmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wc1xyXG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICBldmVudERlZi5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIGlmICh0aGlzLnZlcmJhdGltU3RhbmRhcmRQcm9wcykge1xyXG4gICAgICAgICAgICBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLnZlcmJhdGltU3RhbmRhcmRQcm9wcywgLy8gc3JjXHJcbiAgICAgICAgICAgIGV2ZW50RGVmIC8vIGRlc3RcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuJ3QgdW5kb1xyXG4gICAgICAgIGlmICh0aGlzLm1pc2NQcm9wcykge1xyXG4gICAgICAgICAgICBldmVudERlZi5hcHBseU1pc2NQcm9wcyh0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnRGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGVmLmRhdGVQcm9maWxlID0gb3JpZ0RhdGVQcm9maWxlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5wcm90b3R5cGUuc2V0RGF0ZU11dGF0aW9uID0gZnVuY3Rpb24gKGRhdGVNdXRhdGlvbikge1xyXG4gICAgICAgIGlmIChkYXRlTXV0YXRpb24gJiYgIWRhdGVNdXRhdGlvbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlTXV0YXRpb24gPSBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmTXV0YXRpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGVNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREZWZNdXRhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREZWZNdXRhdGlvbjtcclxuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICBzb3VyY2VDbGFzc2VzOiBbXSxcclxuICAgIHJlZ2lzdGVyQ2xhc3M6IGZ1bmN0aW9uIChFdmVudFNvdXJjZUNsYXNzKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VDbGFzc2VzLnVuc2hpZnQoRXZlbnRTb3VyY2VDbGFzcyk7IC8vIGdpdmUgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgfSxcclxuICAgIHBhcnNlOiBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZUNsYXNzZXMgPSB0aGlzLnNvdXJjZUNsYXNzZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50U291cmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VDbGFzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQ2xhc3Nlc1tpXS5wYXJzZShyYXdJbnB1dCwgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbi8qXHJcbkVtYm9kaWVzIGEgZGl2IHRoYXQgaGFzIHBvdGVudGlhbCBzY3JvbGxiYXJzXHJcbiovXHJcbnZhciBTY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFNjcm9sbGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2Nyb2xsZXIob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgX3RoaXMub3ZlcmZsb3dYID0gb3B0aW9ucy5vdmVyZmxvd1ggfHwgb3B0aW9ucy5vdmVyZmxvdyB8fCAnYXV0byc7XHJcbiAgICAgICAgX3RoaXMub3ZlcmZsb3dZID0gb3B0aW9ucy5vdmVyZmxvd1kgfHwgb3B0aW9ucy5vdmVyZmxvdyB8fCAnYXV0byc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsID0gdGhpcy5yZW5kZXJFbCgpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlPdmVyZmxvdygpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5yZW5kZXJFbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2Nyb2xsRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtc2Nyb2xsZXJcIj48L2Rpdj4nKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gc2V0cyB0byBuYXR1cmFsIGhlaWdodCwgdW5sb2NrcyBvdmVyZmxvd1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KCdhdXRvJyk7XHJcbiAgICAgICAgdGhpcy5hcHBseU92ZXJmbG93KCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBPdmVyZmxvd1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5hcHBseU92ZXJmbG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuY3NzKHtcclxuICAgICAgICAgICAgJ292ZXJmbG93LXgnOiB0aGlzLm92ZXJmbG93WCxcclxuICAgICAgICAgICAgJ292ZXJmbG93LXknOiB0aGlzLm92ZXJmbG93WVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIENhdXNlcyBhbnkgJ2F1dG8nIG92ZXJmbG93IHZhbHVlcyB0byByZXNvbHZlcyB0byAnc2Nyb2xsJyBvciAnaGlkZGVuJy5cclxuICAgIC8vIFVzZWZ1bCBmb3IgcHJlc2VydmluZyBzY3JvbGxiYXIgd2lkdGhzIHJlZ2FyZGxlc3Mgb2YgZnV0dXJlIHJlc2l6ZXMuXHJcbiAgICAvLyBDYW4gcGFzcyBpbiBzY3JvbGxiYXJXaWR0aHMgZm9yIG9wdGltaXphdGlvbi5cclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5sb2NrT3ZlcmZsb3cgPSBmdW5jdGlvbiAoc2Nyb2xsYmFyV2lkdGhzKSB7XHJcbiAgICAgICAgdmFyIG92ZXJmbG93WCA9IHRoaXMub3ZlcmZsb3dYO1xyXG4gICAgICAgIHZhciBvdmVyZmxvd1kgPSB0aGlzLm92ZXJmbG93WTtcclxuICAgICAgICBzY3JvbGxiYXJXaWR0aHMgPSBzY3JvbGxiYXJXaWR0aHMgfHwgdGhpcy5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICBpZiAob3ZlcmZsb3dYID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYID0gKHNjcm9sbGJhcldpZHRocy50b3AgfHwgc2Nyb2xsYmFyV2lkdGhzLmJvdHRvbSB8fCAvLyBob3Jpem9udGFsIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICAvLyBPUiBzY3JvbGxpbmcgcGFuZSB3aXRoIG1hc3NsZXNzIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsWzBdLnNjcm9sbFdpZHRoIC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50V2lkdGgpID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG92ZXJmbG93WSA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WSA9IChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQgfHwgLy8gdmVydGljYWwgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsSGVpZ2h0IC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0KSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuY3NzKHsgJ292ZXJmbG93LXgnOiBvdmVyZmxvd1gsICdvdmVyZmxvdy15Jzogb3ZlcmZsb3dZIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHRlcnMgLyBTZXR0ZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbEVsLmhlaWdodChoZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsRWwuc2Nyb2xsVG9wKCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcclxuICAgICAgICB0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCh0b3ApO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aDtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudEhlaWdodDtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEuZ2V0U2Nyb2xsYmFyV2lkdGhzKHRoaXMuc2Nyb2xsRWwpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTY3JvbGxlcjtcclxufShDbGFzc18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTkpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQoX3ZpZXcsIF9vcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX3ZpZXcsIF9vcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIHNlbGYtY29uZmlnLCBvdmVycmlkYWJsZSBieSBzdWJjbGFzc2VzXHJcbiAgICAgICAgX3RoaXMuc2VnU2VsZWN0b3IgPSAnLmZjLWV2ZW50LWNvbnRhaW5lciA+IConOyAvLyB3aGF0IGNvbnN0aXR1dGVzIGFuIGV2ZW50IGVsZW1lbnQ/XHJcbiAgICAgICAgaWYgKF90aGlzLmRhdGVTZWxlY3RpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRlQ2xpY2tpbmcgPSBuZXcgX3RoaXMuZGF0ZUNsaWNraW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZGF0ZVNlbGVjdGluZ0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGVTZWxlY3RpbmcgPSBuZXcgX3RoaXMuZGF0ZVNlbGVjdGluZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV2ZW50UG9pbnRpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nID0gbmV3IF90aGlzLmV2ZW50UG9pbnRpbmdDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudERyYWdnaW5nQ2xhc3MgJiYgX3RoaXMuZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudERyYWdnaW5nID0gbmV3IF90aGlzLmV2ZW50RHJhZ2dpbmdDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRQb2ludGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudFJlc2l6aW5nQ2xhc3MgJiYgX3RoaXMuZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFJlc2l6aW5nID0gbmV3IF90aGlzLmV2ZW50UmVzaXppbmdDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRQb2ludGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5leHRlcm5hbERyb3BwaW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXh0ZXJuYWxEcm9wcGluZyA9IG5ldyBfdGhpcy5leHRlcm5hbERyb3BwaW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTZXRzIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSB2aWV3IHNob3VsZCByZW5kZXIgaW5zaWRlIG9mLCBkb2VzIGdsb2JhbCBET00tcmVsYXRlZCBpbml0aWFsaXphdGlvbnMsXHJcbiAgICAvLyBhbmQgcmVuZGVycyBhbGwgdGhlIG5vbi1kYXRlLXJlbGF0ZWQgY29udGVudCBpbnNpZGUuXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEVsZW1lbnQuY2FsbCh0aGlzLCBlbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZUNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNsaWNraW5nLmJpbmRUb0VsKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlbGVjdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVTZWxlY3RpbmcuYmluZFRvRWwoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJpbmRBbGxTZWdIYW5kbGVyc1RvRWwoZWwpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVuZEludGVyYWN0aW9ucygpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbnMoKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5leHRlcm5hbERyb3BwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEcm9wcGluZy5iaW5kVG9Eb2N1bWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5leHRlcm5hbERyb3BwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEcm9wcGluZy51bmJpbmRGcm9tRG9jdW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kRGF0ZUhhbmRsZXJUb0VsID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIHRoZSBncmlkJ3Mgcm9vdCBlbGVtZW50LlxyXG4gICAgICAgIC8vIGpRdWVyeSB3aWxsIHRha2UgY2FyZSBvZiB1bnJlZ2lzdGVyaW5nIHRoZW0gd2hlbiByZW1vdmVFbGVtZW50IGdldHMgY2FsbGVkLlxyXG4gICAgICAgIHRoaXMuZWwub24obmFtZSwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICghJChldi50YXJnZXQpLmlzKF90aGlzLnNlZ1NlbGVjdG9yICsgJzpub3QoLmZjLWhlbHBlciksJyArIC8vIGRpcmVjdGx5IG9uIGFuIGV2ZW50IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1NlbGVjdG9yICsgJzpub3QoLmZjLWhlbHBlcikgKiwnICsgLy8gd2l0aGluIGFuIGV2ZW50IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICcuZmMtbW9yZSwnICsgLy8gYSBcIm1vcmUuLlwiIGxpbmtcclxuICAgICAgICAgICAgICAgICdhW2RhdGEtZ290b10nIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXHJcbiAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoX3RoaXMsIGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZEFsbFNlZ0hhbmRsZXJzVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFBvaW50aW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RHJhZ2dpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZXNpemluZ1xyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnRlcmFjdGlvbi5iaW5kVG9FbChlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmJpbmRTZWdIYW5kbGVyVG9FbCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZWwub24obmFtZSwgdGhpcy5zZWdTZWxlY3RvciwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdFbCA9ICQoZXYuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmICghc2VnRWwuaXMoJy5mYy1oZWxwZXInKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ0VsLmRhdGEoJ2ZjLXNlZycpOyAvLyBncmFiIHNlZ21lbnQgZGF0YS4gcHV0IHRoZXJlIGJ5IFZpZXc6OnJlbmRlckV2ZW50c1BheWxvYWRcclxuICAgICAgICAgICAgICAgIGlmIChzZWcgJiYgIV90aGlzLnNob3VsZElnbm9yZUV2ZW50UG9pbnRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoX3RoaXMsIHNlZywgZXYpOyAvLyBjb250ZXh0IHdpbGwgYmUgdGhlIEdyaWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSEFDS1xyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBzdGlsbCB3b3JrIGV2ZW4gdGhvdWdoIGJpbmREYXRlSGFuZGxlclRvRWwgZG9lc24ndCB1c2UgR2xvYmFsRW1pdHRlci5cclxuICAgICAgICByZXR1cm4gR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZElnbm9yZVRvdWNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIC8vIE9uIGlPUyAoYW5kIEFuZHJvaWQ/KSB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBpbml0aWF0ZWQgb3ZlcnRvcCBhbm90aGVyIHNlbGVjdGlvbixcclxuICAgICAgICAvLyB0aGUgdG91Y2hlbmQgbmV2ZXIgZmlyZXMgYmVjYXVzZSB0aGUgZWxlbWVudHMgZ2V0cyByZW1vdmVkIG1pZC10b3VjaC1pbnRlcmFjdGlvbiAobXkgdGhlb3J5KS5cclxuICAgICAgICAvLyBIQUNLOiBzaW1wbHkgZG9uJ3QgYWxsb3cgdGhpcyB0byBoYXBwZW4uXHJcbiAgICAgICAgLy8gQUxTTzogcHJldmVudCBzZWxlY3Rpb24gd2hlbiBhbiAqZXZlbnQqIGlzIGFscmVhZHkgcmFpc2VkLlxyXG4gICAgICAgIHJldHVybiB2aWV3LmlzU2VsZWN0ZWQgfHwgdmlldy5zZWxlY3RlZEV2ZW50O1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlRXZlbnRQb2ludGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBvbmx5IGNhbGwgdGhlIGhhbmRsZXJzIGlmIHRoZXJlIGlzIG5vdCBhIGRyYWcvcmVzaXplIGluIHByb2dyZXNzXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmV2ZW50RHJhZ2dpbmcgJiYgdGhpcy5ldmVudERyYWdnaW5nLmlzRHJhZ2dpbmcpIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmV2ZW50UmVzaXppbmcgJiYgdGhpcy5ldmVudFJlc2l6aW5nLmlzUmVzaXppbmcpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSAmJlxyXG4gICAgICAgICAgICAodGhpcy5pc0V2ZW50RGVmRHJhZ2dhYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnREcmFnID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY2FuU3RhcnRSZXNpemUoc2VnLCBldikgJiZcclxuICAgICAgICAgICAgdGhpcy5pc0V2ZW50RGVmRHJhZ2dhYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnRSZXNpemUgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgcmV0dXJuICghdXRpbF8xLmdldEV2SXNUb3VjaChldikgfHwgdmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoZXZlbnREZWYpKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoZXZlbnREZWYpICYmXHJcbiAgICAgICAgICAgICQoZXYudGFyZ2V0KS5pcygnLmZjLXJlc2l6ZXInKTtcclxuICAgIH07XHJcbiAgICAvLyBLaWxscyBhbGwgaW4tcHJvZ3Jlc3MgZHJhZ2dpbmcuXHJcbiAgICAvLyBVc2VmdWwgZm9yIHdoZW4gcHVibGljIEFQSSBtZXRob2RzIHRoYXQgcmVzdWx0IGluIHJlLXJlbmRlcmluZyBhcmUgaW52b2tlZCBkdXJpbmcgYSBkcmFnLlxyXG4gICAgLy8gQWxzbyB1c2VmdWwgZm9yIHdoZW4gdG91Y2ggZGV2aWNlcyBtaXNiZWhhdmUgYW5kIGRvbid0IGZpcmUgdGhlaXIgdG91Y2hlbmQuXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmVuZEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNsaWNraW5nLFxyXG4gICAgICAgICAgICB0aGlzLmRhdGVTZWxlY3RpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRQb2ludGluZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudERyYWdnaW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVzaXppbmdcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24uZW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEcmFnLW4tRHJvcFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSBkcmFnZ2VkIGJ5IHRoZSB1c2VyXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZEcmFnZ2FibGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0V2ZW50RGVmU3RhcnRFZGl0YWJsZShldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmU3RhcnRFZGl0YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc0VkaXRhYmxlID0gZXZlbnREZWYuaXNTdGFydEV4cGxpY2l0bHlFZGl0YWJsZSgpO1xyXG4gICAgICAgIGlmIChpc0VkaXRhYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMub3B0KCdldmVudFN0YXJ0RWRpdGFibGUnKTtcclxuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMuaXNFdmVudERlZkdlbmVyYWxseUVkaXRhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZHZW5lcmFsbHlFZGl0YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc0VkaXRhYmxlID0gZXZlbnREZWYuaXNFeHBsaWNpdGx5RWRpdGFibGUoKTtcclxuICAgICAgICBpZiAoaXNFZGl0YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlzRWRpdGFibGUgPSB0aGlzLm9wdCgnZWRpdGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVzaXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBmcm9tIGl0cyBzdGFydGluZyBlZGdlXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0JykgJiYgdGhpcy5pc0V2ZW50RGVmUmVzaXphYmxlKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGZyb20gaXRzIGVuZGluZyBlZGdlXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBieSB0aGUgdXNlciBhdCBhbGxcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlJlc2l6YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZSA9IGV2ZW50RGVmLmlzRHVyYXRpb25FeHBsaWNpdGx5RWRpdGFibGUoKTtcclxuICAgICAgICBpZiAoaXNSZXNpemFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpc1Jlc2l6YWJsZSA9IHRoaXMub3B0KCdldmVudER1cmF0aW9uRWRpdGFibGUnKTtcclxuICAgICAgICAgICAgaWYgKGlzUmVzaXphYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlzUmVzaXphYmxlID0gdGhpcy5pc0V2ZW50RGVmR2VuZXJhbGx5RWRpdGFibGUoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc1Jlc2l6YWJsZTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBNdXRhdGlvbiAvIENvbnN0cmFpbnRzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIERpZmZzIHRoZSB0d28gZGF0ZXMsIHJldHVybmluZyBhIGR1cmF0aW9uLCBiYXNlZCBvbiBncmFudWxhcml0eSBvZiB0aGUgZ3JpZFxyXG4gICAgLy8gVE9ETzogcG9ydCBpc1RpbWVTY2FsZSBpbnRvIHRoaXMgc3lzdGVtP1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5kaWZmRGF0ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGlmICh0aGlzLmxhcmdlVW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZCeVVuaXQoYSwgYiwgdGhpcy5sYXJnZVVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5VGltZShhLCBiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gaXMgaXQgYWxsb3dlZCwgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXcncyB2YWxpZFJhbmdlP1xyXG4gICAgLy8gTk9URTogdmVyeSBzaW1pbGFyIHRvIGlzRXh0ZXJuYWxJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRBbGxFdmVudFJhbmdlcygpKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGp1c3QgdXNlIGdldEFsbEV2ZW50UmFuZ2VzIGRpcmVjdGx5XHJcbiAgICAgICAgICAgIGlmICghZGF0ZVByb2ZpbGUudmFsaWRVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQoZXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgIH07XHJcbiAgICAvLyBOT1RFOiB2ZXJ5IHNpbWlsYXIgdG8gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAvLyB3aGVuIGl0J3MgYSBjb21wbGV0ZWx5IGFub255bW91cyBleHRlcm5hbCBkcmFnLCBubyBldmVudC5cclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZ2V0QWxsRXZlbnRSYW5nZXMoKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGVQcm9maWxlLnZhbGlkVW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGluIGV2ZW50SW5zdGFuY2VHcm91cCBpbnN0ZWFkXHJcbiAgICAgICAgICAgIC8vICBiZWNhdXNlIHdlIGRvbid0IHdhbnQgY2FsZW5kYXIncyBjb25zdHJhaW50IHN5c3RlbSB0byBkZXBlbmQgb24gYSBjb21wb25lbnQnc1xyXG4gICAgICAgICAgICAvLyAgZGV0ZXJtaW5hdGlvbiBvZiBmb290cHJpbnRzLlxyXG4gICAgICAgICAgICBpZiAoIXZpZXcuY2FsZW5kYXIuY29uc3RyYWludHMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudDtcclxufShEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFJlbmRlclF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOCk7XHJcbnZhciBEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjEpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIG90aGVyIHZpZXdzIGluaGVyaXQgZnJvbVxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCB2aWV3U3BlYy5vcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmJhdGNoUmVuZGVyRGVwdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gYm9vbGVhbiB3aGV0aGVyIGEgcmFuZ2Ugb2YgdGltZSBpcyB1c2VyLXNlbGVjdGVkIG9yIG5vdFxyXG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMudmlld1NwZWMgPSB2aWV3U3BlYztcclxuICAgICAgICAvLyBzaG9ydGN1dHNcclxuICAgICAgICBfdGhpcy50eXBlID0gdmlld1NwZWMudHlwZTtcclxuICAgICAgICAvLyAubmFtZSBpcyBkZXByZWNhdGVkXHJcbiAgICAgICAgX3RoaXMubmFtZSA9IF90aGlzLnR5cGU7XHJcbiAgICAgICAgX3RoaXMuaW5pdFJlbmRlclF1ZXVlKCk7XHJcbiAgICAgICAgX3RoaXMuaW5pdEhpZGRlbkRheXMoKTtcclxuICAgICAgICBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvciA9IG5ldyBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5iaW5kQmFzZVJlbmRlckhhbmRsZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRPcmRlclNwZWNzID0gdXRpbF8xLnBhcnNlRmllbGRTcGVjcyhfdGhpcy5vcHQoJ2V2ZW50T3JkZXInKSk7XHJcbiAgICAgICAgLy8gbGVnYWN5XHJcbiAgICAgICAgaWYgKF90aGlzWydpbml0aWFsaXplJ10pIHtcclxuICAgICAgICAgICAgX3RoaXNbJ2luaXRpYWxpemUnXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBWaWV3LnByb3RvdHlwZS5fZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvLyBSZXRyaWV2ZXMgYW4gb3B0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgIFZpZXcucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcclxuICAgIH07XHJcbiAgICAvKiBSZW5kZXIgUXVldWVcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pbml0UmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZSA9IG5ldyBSZW5kZXJRdWV1ZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBldmVudDogdGhpcy5vcHQoJ2V2ZW50UmVuZGVyV2FpdCcpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5vbignc3RhcnQnLCB0aGlzLm9uUmVuZGVyUXVldWVTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uKCdzdG9wJywgdGhpcy5vblJlbmRlclF1ZXVlU3RvcC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmU6Y2hhbmdlJywgdGhpcy5zdGFydEJhdGNoUmVuZGVyKTtcclxuICAgICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLnN0b3BCYXRjaFJlbmRlcik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsKHRoaXMucXVlcnlTY3JvbGwoKSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXIudXBkYXRlVmlld1NpemUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGVuZGFyLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuc3RhcnRCYXRjaFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmJhdGNoUmVuZGVyRGVwdGgrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdG9wQmF0Y2hSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmJhdGNoUmVuZGVyRGVwdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RSZW5kZXIgPSBmdW5jdGlvbiAoZnVuYywgbmFtZXNwYWNlLCBhY3Rpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5xdWV1ZShmdW5jLCBuYW1lc3BhY2UsIGFjdGlvblR5cGUpO1xyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGZ1bmMgd2lsbCBhdXRvLWJpbmQgdG8gYHRoaXNgXHJcbiAgICBWaWV3LnByb3RvdHlwZS53aGVuU2l6ZVVwZGF0ZWQgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclF1ZXVlLmlzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uZSgnc3RvcCcsIGZ1bmMuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmdW5jLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFRpdGxlIGFuZCBEYXRlIEZvcm1hdHRpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZVRpdGxlID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZTtcclxuICAgICAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UmFuZ2Uoe1xyXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jYWxlbmRhci5tc1RvTW9tZW50KHVuem9uZWRSYW5nZS5zdGFydE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KSxcclxuICAgICAgICAgICAgZW5kOiB0aGlzLmNhbGVuZGFyLm1zVG9Nb21lbnQodW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KVxyXG4gICAgICAgIH0sIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksIHRoaXMub3B0KCd0aXRsZUZvcm1hdCcpIHx8IHRoaXMuY29tcHV0ZVRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSwgdGhpcy5vcHQoJ3RpdGxlUmFuZ2VTZXBhcmF0b3InKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxyXG4gICAgLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cclxuICAgIFZpZXcucHJvdG90eXBlLmNvbXB1dGVUaXRsZUZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50UmFuZ2VVbml0ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdDtcclxuICAgICAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnWVlZWSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdtb250aFllYXJGb3JtYXQnKTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5hcygnZGF5cycpID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xsJzsgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnTEwnOyAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZSBTZXR0aW5nL1Vuc2V0dGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnNldERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50RGF0ZVByb2ZpbGUgPSB0aGlzLmdldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgICAgICB2YXIgbmV3RGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGRhdGUsIHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIGZvcmNlVG9WYWxpZD10cnVlXHJcbiAgICAgICAgaWYgKCFjdXJyZW50RGF0ZVByb2ZpbGUgfHxcclxuICAgICAgICAgICAgIWN1cnJlbnREYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuZXF1YWxzKG5ld0RhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoJ2RhdGVQcm9maWxlJywgbmV3RGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNldERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEYXRhXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUuZmV0Y2hJbml0aWFsRXZlbnRzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5ICYmICF0aGlzLnVzZXNNaW5NYXhUaW1lO1xyXG4gICAgICAgIHJldHVybiBjYWxlbmRhci5yZXF1ZXN0RXZlbnRzKGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLnN0YXJ0TXMsIGZvcmNlQWxsRGF5KSwgY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuZW5kTXMsIGZvcmNlQWxsRGF5KSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuYmluZEV2ZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY2FsZW5kYXIsICdldmVudHNSZXNldCcsIHRoaXMucmVzZXRFdmVudHMpOyAvLyBUT0RPOiBtYWtlIHRoaXMgYSByZWFsIGV2ZW50XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5iaW5kRXZlbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKHRoaXMuY2FsZW5kYXIsICdldmVudHNSZXNldCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnNldEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoJ2N1cnJlbnRFdmVudHMnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB0aGlzLnNldCgnaGFzRXZlbnRzJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNldCgnY3VycmVudEV2ZW50cycpO1xyXG4gICAgICAgIHRoaXMudW5zZXQoJ2hhc0V2ZW50cycpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlc2V0RXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2hSZW5kZXIoKTtcclxuICAgICAgICB0aGlzLnVuc2V0RXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5zZXRFdmVudHMoZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgdGhpcy5zdG9wQmF0Y2hSZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlIEhpZ2gtbGV2ZWwgUmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdERhdGVSZW5kZXIgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVEYXRlUmVuZGVyKGRhdGVQcm9maWxlKTtcclxuICAgICAgICB9LCAnZGF0ZScsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdERhdGVVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVEYXRlVW5yZW5kZXIoKTtcclxuICAgICAgICB9LCAnZGF0ZScsICdkZXN0cm95Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gaWYgZGF0ZVByb2ZpbGUgbm90IHNwZWNpZmllZCwgdXNlcyBjdXJyZW50XHJcbiAgICBWaWV3LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIuY2FsbCh0aGlzLCBkYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3JlbmRlciddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3JlbmRlciddKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGVzUmVuZGVyZWQnKTtcclxuICAgICAgICB0aGlzLmFkZFNjcm9sbCh7IGlzRGF0ZUluaXQ6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vd0luZGljYXRvcigpOyAvLyBzaG91bGRuJ3QgcmVuZGVyIHlldCBiZWNhdXNlIHVwZGF0ZVNpemUgd2lsbCBiZSBjYWxsZWQgc29vblxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgIHRoaXMuc3RvcE5vd0luZGljYXRvcigpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmRhdGVzVW5yZW5kZXJlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzWydkZXN0cm95J10pIHtcclxuICAgICAgICAgICAgdGhpc1snZGVzdHJveSddKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBcIkJhc2VcIiByZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5iaW5kQmFzZVJlbmRlckhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vbignZGF0ZXNSZW5kZXJlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMud2hlblNpemVVcGRhdGVkKF90aGlzLnRyaWdnZXJWaWV3UmVuZGVyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmU6ZGF0ZXNVbnJlbmRlcmVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VyVmlld0Rlc3Ryb3koKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyVmlld1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1JlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlclZpZXdEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3RGVzdHJveScsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzUmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVFdmVudFJlbmRlcihldmVudHNQYXlsb2FkKTtcclxuICAgICAgICAgICAgX3RoaXMud2hlblNpemVVcGRhdGVkKF90aGlzLnRyaWdnZXJBZnRlckV2ZW50c1JlbmRlcmVkKTtcclxuICAgICAgICB9LCAnZXZlbnQnLCAnaW5pdCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RFdmVudHNVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJCZWZvcmVFdmVudHNEZXN0cm95ZWQoKTtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZUV2ZW50VW5yZW5kZXIoKTtcclxuICAgICAgICB9LCAnZXZlbnQnLCAnZGVzdHJveScpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1c2luZXNzIEhvdXIgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1JlbmRlciA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1c2luZXNzSG91cnMoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICB9LCAnYnVzaW5lc3NIb3VycycsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdEJ1c2luZXNzSG91cnNVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVucmVuZGVyQnVzaW5lc3NIb3VycygpO1xyXG4gICAgICAgIH0sICdidXNpbmVzc0hvdXJzJywgJ2Rlc3Ryb3knKTtcclxuICAgIH07XHJcbiAgICAvLyBNaXNjIHZpZXcgcmVuZGVyaW5nIHV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQmluZHMgRE9NIGhhbmRsZXJzIHRvIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyLCBzdWNoIGFzIHRoZSBkb2N1bWVudFxyXG4gICAgVmlldy5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKSwge1xyXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiB0aGlzLnByb2Nlc3NVbnNlbGVjdCxcclxuICAgICAgICAgICAgbW91c2Vkb3duOiB0aGlzLmhhbmRsZURvY3VtZW50TW91c2Vkb3duXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5iaW5kcyBET00gaGFuZGxlcnMgZnJvbSBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSB2aWV3IGNvbnRhaW5lclxyXG4gICAgVmlldy5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpKTtcclxuICAgIH07XHJcbiAgICAvKiBOb3cgSW5kaWNhdG9yXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgcmVuZGVyIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBiZWdpbnMgcmUtcmVuZGVyaW5nIGl0IGF0IGFuIGludGVydmFsLFxyXG4gICAgLy8gd2hpY2ggaXMgZGVmaW5lZCBieSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKS5cclxuICAgIC8vIFRPRE86IHNvbWVob3cgZG8gdGhpcyBmb3IgdGhlIGN1cnJlbnQgd2hvbGUgZGF5J3MgYmFja2dyb3VuZCB0b29cclxuICAgIFZpZXcucHJvdG90eXBlLnN0YXJ0Tm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVuaXQ7XHJcbiAgICAgICAgdmFyIHVwZGF0ZTtcclxuICAgICAgICB2YXIgZGVsYXk7IC8vIG1zIHdhaXQgdmFsdWVcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ25vd0luZGljYXRvcicpKSB7XHJcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKTtcclxuICAgICAgICAgICAgaWYgKHVuaXQpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHV0aWxfMS5wcm94eSh0aGlzLCAndXBkYXRlTm93SW5kaWNhdG9yJyk7IC8vIGJpbmQgdG8gYHRoaXNgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gdGhpcy5jYWxlbmRhci5nZXROb3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICBkZWxheSA9IHRoaXMuaW5pdGlhbE5vd0RhdGUuY2xvbmUoKS5zdGFydE9mKHVuaXQpLmFkZCgxLCB1bml0KS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dEYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9ICttb21lbnQuZHVyYXRpb24oMSwgdW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBNYXRoLm1heCgxMDAsIGRlbGF5KTsgLy8gcHJldmVudCB0b28gZnJlcXVlbnRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwodXBkYXRlLCBkZWxheSk7IC8vIHVwZGF0ZSBldmVyeSBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbmRlcmluZyB3aWxsIGJlIGluaXRpYXRlZCBpbiB1cGRhdGVTaXplXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHJlcmVuZGVycyB0aGUgbm93IGluZGljYXRvciwgY29tcHV0aW5nIHRoZSBuZXcgY3VycmVudCB0aW1lIGZyb20gdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIHBhc3NlZFxyXG4gICAgLy8gc2luY2UgdGhlIGluaXRpYWwgZ2V0Tm93IGNhbGwuXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgLy8gYWN0aXZhdGVkIGJlZm9yZT9cclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpOyAvLyB3b24ndCB1bnJlbmRlciBpZiB1bm5lY2Vzc2FyeVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vd0luZGljYXRvcih0aGlzLmluaXRpYWxOb3dEYXRlLmNsb25lKCkuYWRkKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKSAvLyBhZGQgbXNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgdW5yZW5kZXJzIHRoZSB2aWV3J3MgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgc3RvcHMgYW55IHJlLXJlbmRlcmluZyB0aW1lcnMuXHJcbiAgICAvLyBXb24ndCBjYXVzZSBzaWRlIGVmZmVjdHMgaWYgaW5kaWNhdG9yIGlzbid0IHJlbmRlcmVkLlxyXG4gICAgVmlldy5wcm90b3R5cGUuc3RvcE5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3NldEhlaWdodCddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3NldEhlaWdodCddKHRvdGFsSGVpZ2h0LCBpc0F1dG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZU5vd0luZGljYXRvcigpO1xyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbGVyXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUuYWRkU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIHZhciBxdWV1ZWRTY3JvbGwgPSB0aGlzLnF1ZXVlZFNjcm9sbCB8fCAodGhpcy5xdWV1ZWRTY3JvbGwgPSB7fSk7XHJcbiAgICAgICAgJC5leHRlbmQocXVldWVkU2Nyb2xsLCBzY3JvbGwpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnBvcFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFwcGx5UXVldWVkU2Nyb2xsKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZWRTY3JvbGwgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5UXVldWVkU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZFNjcm9sbCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U2Nyb2xsKHRoaXMucXVldWVkU2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucXVlcnlTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbCA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMucXVlcnlEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Nyb2xsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5U2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwuaXNEYXRlSW5pdCAmJiB0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBseURhdGVTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7fTsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge307IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWctbi1Ecm9wXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0RXZlbnREcm9wID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIGV2ZW50TXV0YXRpb24sIGVsLCBldikge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgdW5kb0Z1bmMgPSBldmVudE1hbmFnZXIubXV0YXRlRXZlbnRzV2l0aElkKGV2ZW50SW5zdGFuY2UuZGVmLmlkLCBldmVudE11dGF0aW9uKTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uID0gZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb247XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBFdmVudEluc3RhbmNlLCBmb3IgaGFuZGxlcnNcclxuICAgICAgICBpZiAoZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUgPSBkYXRlTXV0YXRpb24uYnVpbGROZXdEYXRlUHJvZmlsZShldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnREcm9wKGV2ZW50SW5zdGFuY2UsIFxyXG4gICAgICAgIC8vIGEgZHJvcCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gYSBkYXRlIG11dGF0aW9uIChleDogcmVzb3VyY2UgY2hhbmdlKVxyXG4gICAgICAgIChkYXRlTXV0YXRpb24gJiYgZGF0ZU11dGF0aW9uLmRhdGVEZWx0YSkgfHwgbW9tZW50LmR1cmF0aW9uKCksIHVuZG9GdW5jLCBlbCwgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGV2ZW50LWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJFdmVudERyb3AgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZGF0ZURlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJvcCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGRhdGVEZWx0YSxcclxuICAgICAgICAgICAgICAgIHVuZG9GdW5jLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIEV4dGVybmFsIEVsZW1lbnQgRHJhZy1uLURyb3BcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQsIHZpYSBqUXVlcnkgVUksIGhhcyBiZWVuIGRyb3BwZWQgb250byB0aGUgY2FsZW5kYXIuXHJcbiAgICAvLyBgbWV0YWAgaXMgdGhlIHBhcnNlZCBkYXRhIHRoYXQgaGFzIGJlZW4gZW1iZWRkZWQgaW50byB0aGUgZHJhZ2dpbmcgZXZlbnQuXHJcbiAgICAvLyBgZHJvcExvY2F0aW9uYCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIGZvciB0aGUgZXZlbnQuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRFeHRlcm5hbERyb3AgPSBmdW5jdGlvbiAoc2luZ2xlRXZlbnREZWYsIGlzRXZlbnQsIGlzU3RpY2t5LCBlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgaWYgKGlzRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5ldmVudE1hbmFnZXIuYWRkRXZlbnREZWYoc2luZ2xlRXZlbnREZWYsIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXh0ZXJuYWxEcm9wKHNpbmdsZUV2ZW50RGVmLCBpc0V2ZW50LCBlbCwgZXYsIHVpKTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBleHRlcm5hbC1kcm9wIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXh0ZXJuYWxEcm9wID0gZnVuY3Rpb24gKHNpbmdsZUV2ZW50RGVmLCBpc0V2ZW50LCBlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgLy8gdHJpZ2dlciAnZHJvcCcgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGVsZW1lbnQgcmVwcmVzZW50cyBhbiBldmVudFxyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkcm9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBlbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYuZGF0ZVByb2ZpbGUuc3RhcnQuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgdWksXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBzaWduYWwgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmLmJ1aWxkSW5zdGFuY2UoKS50b0xlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6aW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCBpbiB0aGUgdmlldyBoYXMgYmVlbiByZXNpemVkIHRvIGEgbmV3IGxlbmd0aFxyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0RXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnRNdXRhdGlvbiwgZWwsIGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB1bmRvRnVuYyA9IGV2ZW50TWFuYWdlci5tdXRhdGVFdmVudHNXaXRoSWQoZXZlbnRJbnN0YW5jZS5kZWYuaWQsIGV2ZW50TXV0YXRpb24pO1xyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgRXZlbnRJbnN0YW5jZSwgZm9yIGhhbmRsZXJzXHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSA9IGV2ZW50TXV0YXRpb24uZGF0ZU11dGF0aW9uLmJ1aWxkTmV3RGF0ZVByb2ZpbGUoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRSZXNpemUoZXZlbnRJbnN0YW5jZSwgZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb24uZW5kRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGV2ZW50LXJlc2l6ZSBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIGR1cmF0aW9uRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemUnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlLnRvTGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbkRlbHRhLFxyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmMsXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogU2VsZWN0aW9uICh0aW1lIHJhbmdlKVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFNlbGVjdHMgYSBkYXRlIHNwYW4gb24gdGhlIHZpZXcuIGBzdGFydGAgYW5kIGBlbmRgIGFyZSBib3RoIE1vbWVudHMuXHJcbiAgICAvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdpbiB0aGUgaW50ZXJhY3Rpb24uXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZm9vdHByaW50LCBldikge1xyXG4gICAgICAgIHRoaXMudW5zZWxlY3QoZXYpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KGZvb3RwcmludCk7XHJcbiAgICAgICAgdGhpcy5yZXBvcnRTZWxlY3Rpb24oZm9vdHByaW50LCBldik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICh0aGlzWydyZW5kZXJTZWxlY3Rpb24nXSkge1xyXG4gICAgICAgICAgICB0aGlzWydyZW5kZXJTZWxlY3Rpb24nXShmb290cHJpbnQudG9MZWdhY3kodGhpcy5jYWxlbmRhcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQuY2FsbCh0aGlzLCBmb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBhIG5ldyBzZWxlY3Rpb24gaXMgbWFkZS4gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZm9vdHByaW50LCBldikge1xyXG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VsZWN0KGZvb3RwcmludCwgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdzZWxlY3QnXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyU2VsZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludCwgZXYpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmNhbGVuZGFyLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUoZm9vdHByaW50KTsgLy8gYWJ1c2Ugb2YgXCJFdmVudFwiRGF0ZVByb2ZpbGU/XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3NlbGVjdCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZS5lbmQsXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFVuZG9lcyBhIHNlbGVjdGlvbi4gdXBkYXRlcyBpbiB0aGUgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzLlxyXG4gICAgLy8gYGV2YCBpcyB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50IHRoYXQgYmVnYW4gdGhlIGludGVyYWN0aW9uLlxyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpc1snZGVzdHJveVNlbGVjdGlvbiddKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzWydkZXN0cm95U2VsZWN0aW9uJ10oKTsgLy8gVE9ETzogZGVwcmVjYXRlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlclNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndW5zZWxlY3QnLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW2V2LCB0aGlzXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgU2VsZWN0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUuc2VsZWN0RXZlbnRJbnN0YW5jZSA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSAhPT0gZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0RXZlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZSA9PT0gZXZlbnRJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbCAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZWwuYWRkQ2xhc3MoJ2ZjLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnVuc2VsZWN0RXZlbnRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFNlZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZWwucmVtb3ZlQ2xhc3MoJ2ZjLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmlzRXZlbnREZWZTZWxlY3RlZCA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIC8vIGV2ZW50IHJlZmVyZW5jZXMgbWlnaHQgY2hhbmdlIG9uIHJlZmV0Y2hFdmVudHMoKSwgd2hpbGUgc2VsZWN0ZWRFdmVudEluc3RhbmNlIGRvZXNuJ3QsXHJcbiAgICAgICAgLy8gc28gY29tcGFyZSBJRHNcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UgJiYgdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UuZGVmLmlkID09PSBldmVudERlZi5pZDtcclxuICAgIH07XHJcbiAgICAvKiBNb3VzZSAvIFRvdWNoIFVuc2VsZWN0aW5nICh0aW1lIHJhbmdlICYgZXZlbnQgdW5zZWxlY3Rpb24pXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gVE9ETzogbW92ZSBjb25zaXN0ZW50bHkgdG8gZG93bi9zdGFydCBvciB1cC9lbmQ/XHJcbiAgICAvLyBUT0RPOiBkb24ndCBraWxsIHByZXZpb3VzIHNlbGVjdGlvbiBpZiB0b3VjaCBzY3JvbGxpbmdcclxuICAgIFZpZXcucHJvdG90eXBlLmhhbmRsZURvY3VtZW50TW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHV0aWxfMS5pc1ByaW1hcnlNb3VzZUJ1dHRvbihldikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVW5zZWxlY3QoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5wcm9jZXNzVW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NSYW5nZVVuc2VsZWN0KGV2KTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudFVuc2VsZWN0KGV2KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5wcm9jZXNzUmFuZ2VVbnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBpZ25vcmU7XHJcbiAgICAgICAgLy8gaXMgdGhlcmUgYSB0aW1lLXJhbmdlIHNlbGVjdGlvbj9cclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkICYmIHRoaXMub3B0KCd1bnNlbGVjdEF1dG8nKSkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IHVuc2VsZWN0IGlmIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgbm90IGlkZW50aWNhbCB0byBvciBpbnNpZGUgb2YgYW4gJ3Vuc2VsZWN0Q2FuY2VsJyBlbGVtZW50XHJcbiAgICAgICAgICAgIGlnbm9yZSA9IHRoaXMub3B0KCd1bnNlbGVjdENhbmNlbCcpO1xyXG4gICAgICAgICAgICBpZiAoIWlnbm9yZSB8fCAhJChldi50YXJnZXQpLmNsb3Nlc3QoaWdub3JlKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnByb2Nlc3NFdmVudFVuc2VsZWN0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghJChldi50YXJnZXQpLmNsb3Nlc3QoJy5mYy1zZWxlY3RlZCcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdEV2ZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBUcmlnZ2Vyc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJCYXNlUmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdSZW5kZXInLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCB0aGlzLmVsXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJCYXNlVW5yZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld0Rlc3Ryb3knLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCB0aGlzLmVsXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdkYXlDbGljaydcclxuICAgIC8vIFNwYW4gaGFzIHN0YXJ0L2VuZCBvZiB0aGUgY2xpY2tlZCBhcmVhLiBPbmx5IHRoZSBzdGFydCBpcyB1c2VmdWwuXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZm9vdHByaW50LCBkYXlFbCwgZXYpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmNhbGVuZGFyLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUoZm9vdHByaW50KTsgLy8gYWJ1c2Ugb2YgXCJFdmVudFwiRGF0ZVByb2ZpbGU/XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2RheUNsaWNrJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBkYXlFbCxcclxuICAgICAgICAgICAgYXJnczogW2RhdGVQcm9maWxlLnN0YXJ0LCBldiwgdGhpc11cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIFV0aWxzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gRm9yIERhdGVDb21wb25lbnQ6OmdldERheUNsYXNzZXNcclxuICAgIFZpZXcucHJvdG90eXBlLmlzRGF0ZUluT3RoZXJNb250aCA9IGZ1bmN0aW9uIChkYXRlLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBBcmd1bWVudHMgYWZ0ZXIgbmFtZSB3aWxsIGJlIGZvcndhcmRlZCB0byBhIGh5cG90aGV0aWNhbCBmdW5jdGlvbiB2YWx1ZVxyXG4gICAgLy8gV0FSTklORzogcGFzc2VkLWluIGFyZ3VtZW50cyB3aWxsIGJlIGdpdmVuIHRvIGdlbmVyYXRvciBmdW5jdGlvbnMgYXMtaXMgYW5kIGNhbiBjYXVzZSBzaWRlLWVmZmVjdHMuXHJcbiAgICAvLyBBbHdheXMgY2xvbmUgeW91ciBvYmplY3RzIGlmIHlvdSBmZWFyIG11dGF0aW9uLlxyXG4gICAgVmlldy5wcm90b3R5cGUuZ2V0VW56b25lZFJhbmdlT3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5vcHQobmFtZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsID0gdmFsLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyLnBhcnNlVW56b25lZFJhbmdlKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEhpZGRlbiBEYXlzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xyXG4gICAgVmlldy5wcm90b3R5cGUuaW5pdEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhpZGRlbkRheXMgPSB0aGlzLm9wdCgnaGlkZGVuRGF5cycpIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxyXG4gICAgICAgIHZhciBpc0hpZGRlbkRheUhhc2ggPSBbXTsgLy8gaXMgdGhlIGRheS1vZi13ZWVrIGhpZGRlbj8gKGhhc2ggd2l0aCBkYXktb2Ytd2Vlay1pbmRleCAtPiBib29sKVxyXG4gICAgICAgIHZhciBkYXlDbnQgPSAwO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnd2Vla2VuZHMnKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaGlkZGVuRGF5cy5wdXNoKDAsIDYpOyAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghKGlzSGlkZGVuRGF5SGFzaFtpXSA9ICQuaW5BcnJheShpLCBoaWRkZW5EYXlzKSAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRheUNudCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcclxuICAgIH07XHJcbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxyXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKGlucHV0VW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5wdXRVbnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgZW5kID0gaW5wdXRVbnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5za2lwSGlkZGVuRGF5cyhlbmQsIC0xLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XHJcbiAgICAvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIE1vbWVudFxyXG4gICAgVmlldy5wcm90b3R5cGUuaXNIaWRkZW5EYXkgPSBmdW5jdGlvbiAoZGF5KSB7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChkYXkpKSB7XHJcbiAgICAgICAgICAgIGRheSA9IGRheS5kYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XHJcbiAgICB9O1xyXG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxyXG4gICAgLy8gRE9FUyBOT1QgQ09OU0lERVIgdmFsaWRVbnpvbmVkUmFuZ2UhXHJcbiAgICAvLyBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgZGF0ZWAgaXMgbm90IGEgaGlkZGVuIGRheSwgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxyXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcclxuICAgIFZpZXcucHJvdG90eXBlLnNraXBIaWRkZW5EYXlzID0gZnVuY3Rpb24gKGRhdGUsIGluYywgaXNFeGNsdXNpdmUpIHtcclxuICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxyXG4gICAgICAgIGlmIChpc0V4Y2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGlzRXhjbHVzaXZlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgb3V0ID0gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsob3V0LmRheSgpICsgKGlzRXhjbHVzaXZlID8gaW5jIDogMCkgKyA3KSAlIDddKSB7XHJcbiAgICAgICAgICAgIG91dC5hZGQoaW5jLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3O1xyXG59KEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVmlldztcclxuVmlldy5wcm90b3R5cGUudXNlc01pbk1heFRpbWUgPSBmYWxzZTtcclxuVmlldy5wcm90b3R5cGUuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IERhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0RhdGVzJywgWydpc0luRG9tJywgJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnJlcXVlc3REYXRlUmVuZGVyKGRlcHMuZGF0ZVByb2ZpbGUpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3REYXRlVW5yZW5kZXIoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ2Rpc3BsYXlpbmdCdXNpbmVzc0hvdXJzJywgWydkaXNwbGF5aW5nRGF0ZXMnLCAnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RCdXNpbmVzc0hvdXJzUmVuZGVyKGRlcHMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1VucmVuZGVyKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdpbml0aWFsRXZlbnRzJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hJbml0aWFsRXZlbnRzKGRlcHMuZGF0ZVByb2ZpbGUpO1xyXG59KTtcclxuVmlldy53YXRjaCgnYmluZGluZ0V2ZW50cycsIFsnaW5pdGlhbEV2ZW50cyddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgdGhpcy5zZXRFdmVudHMoZGVwcy5pbml0aWFsRXZlbnRzKTtcclxuICAgIHRoaXMuYmluZEV2ZW50Q2hhbmdlcygpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnVuYmluZEV2ZW50Q2hhbmdlcygpO1xyXG4gICAgdGhpcy51bnNldEV2ZW50cygpO1xyXG59KTtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0V2ZW50cycsIFsnZGlzcGxheWluZ0RhdGVzJywgJ2hhc0V2ZW50cyddLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RFdmVudHNSZW5kZXIodGhpcy5nZXQoJ2N1cnJlbnRFdmVudHMnKSk7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdEV2ZW50c1VucmVuZGVyKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCd0aXRsZScsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHJldHVybiAodGhpcy50aXRsZSA9IHRoaXMuY29tcHV0ZVRpdGxlKGRlcHMuZGF0ZVByb2ZpbGUpKTsgLy8gYXNzaWduIHRvIFZpZXcgZm9yIGxlZ2FjeSByZWFzb25zXHJcbn0pO1xyXG5WaWV3LndhdGNoKCdsZWdhY3lEYXRlUHJvcHMnLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgdmFyIGRhdGVQcm9maWxlID0gZGVwcy5kYXRlUHJvZmlsZTtcclxuICAgIC8vIERFUFJFQ0FURUQsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXQgdXBkYXRlZC4uLlxyXG4gICAgdGhpcy5zdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLnN0YXJ0TXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgdGhpcy5lbmQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5lbmRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmludGVydmFsU3RhcnQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmludGVydmFsRW5kID0gY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudFJlbmRlcmVyKGNvbXBvbmVudCwgZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIgPSBmaWxsUmVuZGVyZXI7XHJcbiAgICB9XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcub3B0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdmFsdWVzIHRoYXQgcmVseSBvbiBvcHRpb25zIGFuZCBhbHNvIHJlbGF0ZSB0byByYW5nZVxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmFuZ2VVcGRhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkaXNwbGF5RXZlbnRUaW1lO1xyXG4gICAgICAgIHZhciBkaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICAgICAgdGhpcy5ldmVudFRpbWVGb3JtYXQgPVxyXG4gICAgICAgICAgICB0aGlzLm9wdCgnZXZlbnRUaW1lRm9ybWF0JykgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0KCd0aW1lRm9ybWF0JykgfHwgLy8gZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRXZlbnRUaW1lRm9ybWF0KCk7XHJcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IHRoaXMub3B0KCdkaXNwbGF5RXZlbnRUaW1lJyk7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50VGltZSgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gdGhpcy5vcHQoJ2Rpc3BsYXlFdmVudEVuZCcpO1xyXG4gICAgICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQoKTsgLy8gbWlnaHQgYmUgYmFzZWQgb2ZmIG9mIHJhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlzcGxheUV2ZW50VGltZSA9IGRpc3BsYXlFdmVudFRpbWU7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5RXZlbnRFbmQgPSBkaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmNvbXBvbmVudC5fZ2V0RGF0ZVByb2ZpbGUoKTtcclxuICAgICAgICB2YXIgZXZlbnREZWZJZDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VHcm91cDtcclxuICAgICAgICB2YXIgZXZlbnRSYW5nZXM7XHJcbiAgICAgICAgdmFyIGJnUmFuZ2VzID0gW107XHJcbiAgICAgICAgdmFyIGZnUmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChldmVudERlZklkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2VHcm91cCA9IGV2ZW50c1BheWxvYWRbZXZlbnREZWZJZF07XHJcbiAgICAgICAgICAgIGV2ZW50UmFuZ2VzID0gaW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VHcm91cC5nZXRFdmVudERlZigpLmhhc0JnUmVuZGVyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2guYXBwbHkoYmdSYW5nZXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZnUmFuZ2VzLnB1c2guYXBwbHkoZmdSYW5nZXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckJnUmFuZ2VzKGJnUmFuZ2VzKTtcclxuICAgICAgICB0aGlzLnJlbmRlckZnUmFuZ2VzKGZnUmFuZ2VzKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQmdSYW5nZXMoKTtcclxuICAgICAgICB0aGlzLnVucmVuZGVyRmdSYW5nZXMoKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1JhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIC8vIHJlbmRlciBhbiBgLmVsYCBvbiBlYWNoIHNlZ1xyXG4gICAgICAgIC8vIHJldHVybnMgYSBzdWJzZXQgb2YgdGhlIHNlZ3MuIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXHJcbiAgICAgICAgc2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2Vncyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyRmdTZWdzKHNlZ3MpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZnU2VncyA9IHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckZnU2Vncyh0aGlzLmZnU2VncyB8fCBbXSk7XHJcbiAgICAgICAgdGhpcy5mZ1NlZ3MgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnQuZXZlbnRGb290cHJpbnRzVG9TZWdzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyQmdTZWdzKHNlZ3MpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJnU2VncyA9IHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyQmdSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckJnU2VncygpO1xyXG4gICAgICAgIHRoaXMuYmdTZWdzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5iZ1NlZ3MgfHwgW10pLmNvbmNhdCh0aGlzLmZnU2VncyB8fCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgICAgIC8vIHNlZ3MgYWxyZWFkeSBoYXMgcmVuZGVyZWQgZWxzLCBhbmQgaGFzIGJlZW4gZmlsdGVyZWQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaWduYWwgZmFpbHVyZSBpZiBub3QgaW1wbGVtZW50ZWRcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIHNlZ21lbnRzXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnYmdFdmVudCcsIHNlZ3MsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0QmdDbGFzc2VzKHNlZy5mb290cHJpbnQuZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldENzczogZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogX3RoaXMuZ2V0QmdDb2xvcihzZWcuZm9vdHByaW50LmV2ZW50RGVmKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyRWw6IGZ1bmN0aW9uIChzZWcsIGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbHRlckV2ZW50UmVuZGVyRWwoc2VnLmZvb3RwcmludCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gc2lnbmFsIGZhaWx1cmUgaWYgbm8gZmlsbFJlbmRlcmVyXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyQmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignYmdFdmVudCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LlxyXG4gICAgLy8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdFbHMgPSBmdW5jdGlvbiAoc2VncywgZGlzYWJsZVJlc2l6aW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZGlzYWJsZVJlc2l6aW5nID09PSB2b2lkIDApIHsgZGlzYWJsZVJlc2l6aW5nID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaGFzRXZlbnRSZW5kZXJIYW5kbGVycyA9IHRoaXMudmlldy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnRSZW5kZXInKTtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIGV2ZW50IHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iZWZvcmVGZ1NlZ0h0bWwoc2Vnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuZmdTZWdIdG1sKHNlZ3NbaV0sIGRpc2FibGVSZXNpemluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC4gQW4gZWwgbWlnaHQgYmUgbnVsbCBpZiB0aGUgZXZlbnRSZW5kZXIgY2FsbGJhY2sgcmV0dXJuZWQgZmFsc2UuXHJcbiAgICAgICAgICAgICQoaHRtbCkuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0V2ZW50UmVuZGVySGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbCA9IF90aGlzLmZpbHRlckV2ZW50UmVuZGVyRWwoc2VnLmZvb3RwcmludCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuZGF0YSgnZmMtc2VnJywgc2VnKTsgLy8gdXNlZCBieSBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbCA9IGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRTZWdzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJlZm9yZUZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBvZiBhIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudC4gVXNlZCBieSByZW5kZXJGZ1NlZ0VscygpXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmljIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgdGhlIEhUTUwgY2xhc3NOYW1lcyBmb3IgYW4gZXZlbnQgc2VnbWVudCdzIGVsZW1lbnRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ0NsYXNzZXMgPSBmdW5jdGlvbiAoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGUpIHtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtcclxuICAgICAgICAgICAgJ2ZjLWV2ZW50JyxcclxuICAgICAgICAgICAgc2VnLmlzU3RhcnQgPyAnZmMtc3RhcnQnIDogJ2ZjLW5vdC1zdGFydCcsXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCA/ICdmYy1lbmQnIDogJ2ZjLW5vdC1lbmQnXHJcbiAgICAgICAgXS5jb25jYXQodGhpcy5nZXRDbGFzc2VzKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKTtcclxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kcmFnZ2FibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmVzaXphYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV2ZW50IGlzIGN1cnJlbnRseSBzZWxlY3RlZD8gYXR0YWNoIGEgY2xhc3NOYW1lLlxyXG4gICAgICAgIGlmICh0aGlzLnZpZXcuaXNFdmVudERlZlNlbGVjdGVkKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQgYW5kIHRoZSBkZWZhdWx0IGVsZW1lbnQgdXNlZCBmb3IgcmVuZGVyaW5nLCByZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGFjdHVhbGx5IGJlIHVzZWQuXHJcbiAgICAvLyBCYXNpY2FsbHkgcnVucyBldmVudHMgYW5kIGVsZW1lbnRzIHRocm91Z2ggdGhlIGV2ZW50UmVuZGVyIGhvb2suXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5maWx0ZXJFdmVudFJlbmRlckVsID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50LCBlbCkge1xyXG4gICAgICAgIHZhciBsZWdhY3kgPSBldmVudEZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpO1xyXG4gICAgICAgIHZhciBjdXN0b20gPSB0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudFJlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogbGVnYWN5LFxyXG4gICAgICAgICAgICBhcmdzOiBbbGVnYWN5LCBlbCwgdGhpcy52aWV3XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjdXN0b20gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VzdG9tICYmIGN1c3RvbSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBlbCA9ICQoY3VzdG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIG9uIGFuIGV2ZW50J3MgZWxlbWVudC5cclxuICAgIC8vIGByYW5nZWAgY2FuIGJlIHRoZSBFdmVudCBvYmplY3QgaXRzZWxmLCBvciBzb21ldGhpbmcgcmFuZ2UtbGlrZSwgd2l0aCBhdCBsZWFzdCBhIGBzdGFydGAuXHJcbiAgICAvLyBJZiBldmVudCB0aW1lcyBhcmUgZGlzYWJsZWQsIG9yIHRoZSBldmVudCBoYXMgbm8gdGltZSwgd2lsbCByZXR1cm4gYSBibGFuayBzdHJpbmcuXHJcbiAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBmb3JtYXRTdHIgd2lsbCBkZWZhdWx0IHRvIHRoZSBldmVudFRpbWVGb3JtYXQgc2V0dGluZyxcclxuICAgIC8vIGFuZCBkaXNwbGF5RW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgZGlzcGxheUV2ZW50RW5kIHNldHRpbmcuXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaW1lVGV4dCA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludCwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRpbWVUZXh0KGV2ZW50Rm9vdHByaW50LmV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUuc3RhcnQsIGV2ZW50Rm9vdHByaW50LmV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUuZW5kLCBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXksIGZvcm1hdFN0ciwgZGlzcGxheUVuZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuX2dldFRpbWVUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGlzQWxsRGF5LCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpIHtcclxuICAgICAgICBpZiAoZm9ybWF0U3RyID09IG51bGwpIHtcclxuICAgICAgICAgICAgZm9ybWF0U3RyID0gdGhpcy5ldmVudFRpbWVGb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwbGF5RW5kID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheUVuZCA9IHRoaXMuZGlzcGxheUV2ZW50RW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5RXZlbnRUaW1lICYmICFpc0FsbERheSkge1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUVuZCAmJiBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXcuZm9ybWF0UmFuZ2UoeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0sIGZhbHNlLCAvLyBhbGxEYXlcclxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQuZm9ybWF0KGZvcm1hdFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJnQ2xhc3NlcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5nZXRDbGFzc2VzKGV2ZW50RGVmKTtcclxuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWJnZXZlbnQnKTtcclxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcztcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRDbGFzc2VzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaC5hcHBseSgvLyBhcHBlbmRcclxuICAgICAgICAgICAgY2xhc3NOYW1lcywgb2Jqc1tpXS5ldmVudENsYXNzTmFtZSB8fCBvYmpzW2ldLmNsYXNzTmFtZSB8fCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgZXZlbnQgc2tpbi1yZWxhdGVkIENTUyBwcm9wZXJ0aWVzXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTa2luQ3NzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiB0aGlzLmdldEJnQ29sb3IoZXZlbnREZWYpLFxyXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogdGhpcy5nZXRCb3JkZXJDb2xvcihldmVudERlZiksXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmdldFRleHRDb2xvcihldmVudERlZilcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRCZ0NvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudEJhY2tncm91bmRDb2xvciB8fCBvYmpzW2ldLmV2ZW50Q29sb3IgfHxcclxuICAgICAgICAgICAgICAgIG9ianNbaV0uYmFja2dyb3VuZENvbG9yIHx8IG9ianNbaV0uY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0KCdldmVudEJhY2tncm91bmRDb2xvcicpIHx8IHRoaXMub3B0KCdldmVudENvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJvcmRlckNvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudEJvcmRlckNvbG9yIHx8IG9ianNbaV0uZXZlbnRDb2xvciB8fFxyXG4gICAgICAgICAgICAgICAgb2Jqc1tpXS5ib3JkZXJDb2xvciB8fCBvYmpzW2ldLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLm9wdCgnZXZlbnRCb3JkZXJDb2xvcicpIHx8IHRoaXMub3B0KCdldmVudENvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFRleHRDb2xvciA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRTdHlsaW5nT2JqcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGggJiYgIXZhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IG9ianNbaV0uZXZlbnRUZXh0Q29sb3IgfHxcclxuICAgICAgICAgICAgICAgIG9ianNbaV0udGV4dENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLm9wdCgnZXZlbnRUZXh0Q29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTdHlsaW5nT2JqcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRGYWxsYmFja1N0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICBvYmpzLnVuc2hpZnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHJldHVybiBvYmpzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEZhbGxiYWNrU3R5bGluZ09ianMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gW2V2ZW50RGVmLnNvdXJjZV07XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuc29ydEV2ZW50U2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgc2Vncy5zb3J0KHV0aWxfMS5wcm94eSh0aGlzLCAnY29tcGFyZUV2ZW50U2VncycpKTtcclxuICAgIH07XHJcbiAgICAvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggc2VnbWVudHMgc2hvdWxkIHRha2UgdmlzdWFsIHByaW9yaXR5XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wYXJlRXZlbnRTZWdzID0gZnVuY3Rpb24gKHNlZzEsIHNlZzIpIHtcclxuICAgICAgICB2YXIgZjEgPSBzZWcxLmZvb3RwcmludDtcclxuICAgICAgICB2YXIgZjIgPSBzZWcyLmZvb3RwcmludDtcclxuICAgICAgICB2YXIgY2YxID0gZjEuY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHZhciBjZjIgPSBmMi5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIHIxID0gY2YxLnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgcjIgPSBjZjIudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHJldHVybiByMS5zdGFydE1zIC0gcjIuc3RhcnRNcyB8fCAvLyBlYXJsaWVyIGV2ZW50cyBnbyBmaXJzdFxyXG4gICAgICAgICAgICAocjIuZW5kTXMgLSByMi5zdGFydE1zKSAtIChyMS5lbmRNcyAtIHIxLnN0YXJ0TXMpIHx8IC8vIHRpZT8gbG9uZ2VyIGV2ZW50cyBnbyBmaXJzdFxyXG4gICAgICAgICAgICBjZjIuaXNBbGxEYXkgLSBjZjEuaXNBbGxEYXkgfHwgLy8gdGllPyBwdXQgYWxsLWRheSBldmVudHMgZmlyc3QgKGJvb2xlYW5zIGNhc3QgdG8gMC8xKVxyXG4gICAgICAgICAgICB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjcyhmMS5ldmVudERlZiwgZjIuZXZlbnREZWYsIHRoaXMudmlldy5ldmVudE9yZGVyU3BlY3MsIGYxLmV2ZW50RGVmLm1pc2NQcm9wcywgZjIuZXZlbnREZWYubWlzY1Byb3BzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRSZW5kZXJlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogNDMgKi8sXG4vKiA0NCAqLyxcbi8qIDQ1ICovLFxuLyogNDYgKi8sXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuLy8gUGx1Z2luXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxubW9tZW50X2V4dF8xLm5ld01vbWVudFByb3RvLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIgJiYgYXJndW1lbnRzWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUodGhpcywgYXJndW1lbnRzWzBdKTsgLy8gb3VyIGV4dGVuZGVkIGZvcm1hdHRpbmdcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1RpbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2FtYmlnWm9uZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcclxuICAgICAgICAvLyBtb21lbnQuZm9ybWF0KCkgZG9lc24ndCBlbnN1cmUgZW5nbGlzaCwgYnV0IHdlIHdhbnQgdG8uXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLmZvcm1hdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5tb21lbnRfZXh0XzEubmV3TW9tZW50UHJvdG8udG9JU09TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fYW1iaWdUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tREQnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fZnVsbENhbGVuZGFyKSB7XHJcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIGJyb3dzZXIsIG1vbWVudCBtaWdodCBub3Qgb3V0cHV0IGVuZ2xpc2guIGVuc3VyZSBlbmdsaXNoLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvMi4xOC4xL3NyYy9saWIvbW9tZW50L2Zvcm1hdC5qcyNMMjJcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KGVuZ2xpc2hNb21lbnQodGhpcyksIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuZ2xpc2hNb21lbnQobW9tKSB7XHJcbiAgICBpZiAobW9tLmxvY2FsZSgpICE9PSAnZW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbS5jbG9uZSgpLmxvY2FsZSgnZW4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb207XHJcbn1cclxuLy8gQ29uZmlnXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5JbnNlcnRlZCBiZXR3ZWVuIGNodW5rcyBpbiB0aGUgZmFrZSAoXCJpbnRlcm1lZGlhdGVcIikgZm9ybWF0dGluZyBzdHJpbmcuXHJcbkltcG9ydGFudCB0aGF0IGl0IHBhc3NlcyBhcyB3aGl0ZXNwYWNlIChcXHMpIGJlY2F1c2UgbW9tZW50IG9mdGVuIGlkZW50aWZpZXMgbm9uLXN0YW5kYWxvbmUgbW9udGhzXHJcbnZpYSBhIHJlZ2V4cCB3aXRoIGFuIFxccy5cclxuKi9cclxudmFyIFBBUlRfU0VQQVJBVE9SID0gJ1xcdTAwMGInOyAvLyB2ZXJ0aWNhbCB0YWJcclxuLypcclxuSW5zZXJ0ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGxpdGVyYWwtdGV4dCBjaHVuayB0byBpbmRpY2F0ZSB0aGF0IHRoZSBsaXRlcmFsIHRleHQgaXMgbm90IGFjdHVhbGx5IGxpdGVyYWwgdGV4dCxcclxuYnV0IHJhdGhlciwgYSBcInNwZWNpYWxcIiB0b2tlbiB0aGF0IGhhcyBjdXN0b20gcmVuZGVyaW5nIChzZWUgc3BlY2lhbFRva2VucyBtYXApLlxyXG4qL1xyXG52YXIgU1BFQ0lBTF9UT0tFTl9NQVJLRVIgPSAnXFx1MDAxZic7IC8vIGluZm9ybWF0aW9uIHNlcGFyYXRvciAxXHJcbi8qXHJcbkluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHNwYW4gb2YgdGV4dCB0aGF0IG11c3QgaGF2ZSBub24temVybyBudW1lcmljIGNoYXJhY3RlcnMuXHJcbkhhbmRsaW5nIG9mIHRoZXNlIG1hcmtlcnMgaXMgZG9uZSBpbiBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0ZXh0IHJlbmRlcmluZy5cclxuKi9cclxudmFyIE1BWUJFX01BUktFUiA9ICdcXHUwMDFlJzsgLy8gaW5mb3JtYXRpb24gc2VwYXJhdG9yIDJcclxudmFyIE1BWUJFX1JFR0VYUCA9IG5ldyBSZWdFeHAoTUFZQkVfTUFSS0VSICsgJyhbXicgKyBNQVlCRV9NQVJLRVIgKyAnXSopJyArIE1BWUJFX01BUktFUiwgJ2cnKTsgLy8gbXVzdCBiZSBnbG9iYWxcclxuLypcclxuQWRkaXRpb24gZm9ybWF0dGluZyB0b2tlbnMgd2Ugd2FudCByZWNvZ25pemVkXHJcbiovXHJcbnZhciBzcGVjaWFsVG9rZW5zID0ge1xyXG4gICAgdDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChkYXRlLCAnYScpLmNoYXJBdCgwKTtcclxuICAgIH0sXHJcbiAgICBUOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsICdBJykuY2hhckF0KDApO1xyXG4gICAgfVxyXG59O1xyXG4vKlxyXG5UaGUgZmlyc3QgY2hhcmFjdGVycyBvZiBmb3JtYXR0aW5nIHRva2VucyBmb3IgdW5pdHMgdGhhdCBhcmUgMSBkYXkgb3IgbGFyZ2VyLlxyXG5gdmFsdWVgIGlzIGZvciByYW5raW5nIHJlbGF0aXZlIHNpemUgKGxvd2VyIG1lYW5zIGJpZ2dlcikuXHJcbmB1bml0YCBpcyBhIG5vcm1hbGl6ZWQgdW5pdCwgdXNlZCBmb3IgY29tcGFyaW5nIG1vbWVudHMuXHJcbiovXHJcbnZhciBsYXJnZVRva2VuTWFwID0ge1xyXG4gICAgWTogeyB2YWx1ZTogMSwgdW5pdDogJ3llYXInIH0sXHJcbiAgICBNOiB7IHZhbHVlOiAyLCB1bml0OiAnbW9udGgnIH0sXHJcbiAgICBXOiB7IHZhbHVlOiAzLCB1bml0OiAnd2VlaycgfSxcclxuICAgIHc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LFxyXG4gICAgRDogeyB2YWx1ZTogNCwgdW5pdDogJ2RheScgfSxcclxuICAgIGQ6IHsgdmFsdWU6IDQsIHVuaXQ6ICdkYXknIH0gLy8gZGF5IG9mIHdlZWtcclxufTtcclxuLy8gU2luZ2xlIERhdGUgRm9ybWF0dGluZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuRm9ybWF0cyBgZGF0ZWAgd2l0aCBhIE1vbWVudCBmb3JtYXR0aW5nIHN0cmluZywgYnV0IGFsbG93IG91ciBub24temVybyBhcmVhcyBhbmQgc3BlY2lhbCB0b2tlblxyXG4qL1xyXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0cikge1xyXG4gICAgcmV0dXJuIHJlbmRlckZha2VGb3JtYXRTdHJpbmcoZ2V0UGFyc2VkRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikuZmFrZUZvcm1hdFN0cmluZywgZGF0ZSk7XHJcbn1cclxuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcclxuLy8gRGF0ZSBSYW5nZSBGb3JtYXR0aW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gVE9ETzogbWFrZSBpdCB3b3JrIHdpdGggdGltZXpvbmUgb2Zmc2V0XHJcbi8qXHJcblVzaW5nIGEgZm9ybWF0dGluZyBzdHJpbmcgbWVhbnQgZm9yIGEgc2luZ2xlIGRhdGUsIGdlbmVyYXRlIGEgcmFuZ2Ugc3RyaW5nLCBsaWtlXHJcblwiU2VwIDIgLSA5IDIwMTNcIiwgdGhhdCBpbnRlbGxpZ2VudGx5IGluc2VydHMgYSBzZXBhcmF0b3Igd2hlcmUgdGhlIGRhdGVzIGRpZmZlci5cclxuSWYgdGhlIGRhdGVzIGFyZSB0aGUgc2FtZSBhcyBmYXIgYXMgdGhlIGZvcm1hdCBzdHJpbmcgaXMgY29uY2VybmVkLCBqdXN0IHJldHVybiBhIHNpbmdsZVxyXG5yZW5kZXJpbmcgb2Ygb25lIGRhdGUsIHdpdGhvdXQgYW55IHNlcGFyYXRvci5cclxuKi9cclxuZnVuY3Rpb24gZm9ybWF0UmFuZ2UoZGF0ZTEsIGRhdGUyLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgaXNSVEwpIHtcclxuICAgIHZhciBsb2NhbGVEYXRhO1xyXG4gICAgZGF0ZTEgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTEpO1xyXG4gICAgZGF0ZTIgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTIpO1xyXG4gICAgbG9jYWxlRGF0YSA9IGRhdGUxLmxvY2FsZURhdGEoKTtcclxuICAgIC8vIEV4cGFuZCBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MsIGxpa2UgXCJMTFwiIC0+IFwiTU1NTSBEIFlZWVlcIi5cclxuICAgIC8vIEJUVywgdGhpcyBpcyBub3QgaW1wb3J0YW50IGZvciBgZm9ybWF0RGF0ZWAgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIHB1dCBjdXN0b20gdG9rZW5zXHJcbiAgICAvLyBvciBub24temVybyBhcmVhcyBpbiBNb21lbnQncyBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MuXHJcbiAgICBmb3JtYXRTdHIgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KGZvcm1hdFN0cikgfHwgZm9ybWF0U3RyO1xyXG4gICAgcmV0dXJuIHJlbmRlclBhcnNlZEZvcm1hdChnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSwgZGF0ZTEsIGRhdGUyLCBzZXBhcmF0b3IgfHwgJyAtICcsIGlzUlRMKTtcclxufVxyXG5leHBvcnRzLmZvcm1hdFJhbmdlID0gZm9ybWF0UmFuZ2U7XHJcbi8qXHJcblJlbmRlcnMgYSByYW5nZSB3aXRoIGFuIGFscmVhZHktcGFyc2VkIGZvcm1hdCBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbmRlclBhcnNlZEZvcm1hdChwYXJzZWRGb3JtYXQsIGRhdGUxLCBkYXRlMiwgc2VwYXJhdG9yLCBpc1JUTCkge1xyXG4gICAgdmFyIHNhbWVVbml0cyA9IHBhcnNlZEZvcm1hdC5zYW1lVW5pdHM7XHJcbiAgICB2YXIgdW56b25lZERhdGUxID0gZGF0ZTEuY2xvbmUoKS5zdHJpcFpvbmUoKTsgLy8gZm9yIHNhbWUtdW5pdCBjb21wYXJpc29uc1xyXG4gICAgdmFyIHVuem9uZWREYXRlMiA9IGRhdGUyLmNsb25lKCkuc3RyaXBab25lKCk7IC8vIFwiXHJcbiAgICB2YXIgcmVuZGVyZWRQYXJ0czEgPSByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMocGFyc2VkRm9ybWF0LmZha2VGb3JtYXRTdHJpbmcsIGRhdGUxKTtcclxuICAgIHZhciByZW5kZXJlZFBhcnRzMiA9IHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhwYXJzZWRGb3JtYXQuZmFrZUZvcm1hdFN0cmluZywgZGF0ZTIpO1xyXG4gICAgdmFyIGxlZnRJO1xyXG4gICAgdmFyIGxlZnRTdHIgPSAnJztcclxuICAgIHZhciByaWdodEk7XHJcbiAgICB2YXIgcmlnaHRTdHIgPSAnJztcclxuICAgIHZhciBtaWRkbGVJO1xyXG4gICAgdmFyIG1pZGRsZVN0cjEgPSAnJztcclxuICAgIHZhciBtaWRkbGVTdHIyID0gJyc7XHJcbiAgICB2YXIgbWlkZGxlU3RyID0gJyc7XHJcbiAgICAvLyBTdGFydCBhdCB0aGUgbGVmdG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIGNvbnRpbnVlIHVudGlsIHlvdSBoaXQgYSB0b2tlblxyXG4gICAgLy8gdGhhdCBpcyBub3QgdGhlIHNhbWUgYmV0d2VlbiBkYXRlcy5cclxuICAgIGZvciAobGVmdEkgPSAwOyBsZWZ0SSA8IHNhbWVVbml0cy5sZW5ndGggJiYgKCFzYW1lVW5pdHNbbGVmdEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbbGVmdEldKSk7IGxlZnRJKyspIHtcclxuICAgICAgICBsZWZ0U3RyICs9IHJlbmRlcmVkUGFydHMxW2xlZnRJXTtcclxuICAgIH1cclxuICAgIC8vIFNpbWlsYXJseSwgc3RhcnQgYXQgdGhlIHJpZ2h0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgbW92ZSBsZWZ0XHJcbiAgICBmb3IgKHJpZ2h0SSA9IHNhbWVVbml0cy5sZW5ndGggLSAxOyByaWdodEkgPiBsZWZ0SSAmJiAoIXNhbWVVbml0c1tyaWdodEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbcmlnaHRJXSkpOyByaWdodEktLSkge1xyXG4gICAgICAgIC8vIElmIGN1cnJlbnQgY2h1bmsgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHVuaXF1ZSBkYXRlLWNvbnRlbnQsIGFuZCBpcyBhIHNwZWNpYWwtY2FzZVxyXG4gICAgICAgIC8vIGRhdGUtZm9ybWF0dGluZyBwb3N0Zml4IGNoYXJhY3RlciwgdGhlbiBkb24ndCBjb25zdW1lIGl0LiBDb25zaWRlciBpdCB1bmlxdWUgZGF0ZS1jb250ZW50LlxyXG4gICAgICAgIC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlXHJcbiAgICAgICAgaWYgKHJpZ2h0SSAtIDEgPT09IGxlZnRJICYmIHJlbmRlcmVkUGFydHMxW3JpZ2h0SV0gPT09ICcuJykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmlnaHRTdHIgPSByZW5kZXJlZFBhcnRzMVtyaWdodEldICsgcmlnaHRTdHI7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgYXJlYSBpbiB0aGUgbWlkZGxlIGlzIGRpZmZlcmVudCBmb3IgYm90aCBvZiB0aGUgZGF0ZXMuXHJcbiAgICAvLyBDb2xsZWN0IHRoZW0gZGlzdGluY3RseSBzbyB3ZSBjYW4gamFtIHRoZW0gdG9nZXRoZXIgbGF0ZXIuXHJcbiAgICBmb3IgKG1pZGRsZUkgPSBsZWZ0STsgbWlkZGxlSSA8PSByaWdodEk7IG1pZGRsZUkrKykge1xyXG4gICAgICAgIG1pZGRsZVN0cjEgKz0gcmVuZGVyZWRQYXJ0czFbbWlkZGxlSV07XHJcbiAgICAgICAgbWlkZGxlU3RyMiArPSByZW5kZXJlZFBhcnRzMlttaWRkbGVJXTtcclxuICAgIH1cclxuICAgIGlmIChtaWRkbGVTdHIxIHx8IG1pZGRsZVN0cjIpIHtcclxuICAgICAgICBpZiAoaXNSVEwpIHtcclxuICAgICAgICAgICAgbWlkZGxlU3RyID0gbWlkZGxlU3RyMiArIHNlcGFyYXRvciArIG1pZGRsZVN0cjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtaWRkbGVTdHIgPSBtaWRkbGVTdHIxICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvY2Vzc01heWJlTWFya2VycyhsZWZ0U3RyICsgbWlkZGxlU3RyICsgcmlnaHRTdHIpO1xyXG59XHJcbi8vIEZvcm1hdCBTdHJpbmcgUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxudmFyIHBhcnNlZEZvcm1hdFN0ckNhY2hlID0ge307XHJcbi8qXHJcblJldHVybnMgYSBwYXJzZWQgZm9ybWF0IHN0cmluZywgbGV2ZXJhZ2luZyBhIGNhY2hlLlxyXG4qL1xyXG5mdW5jdGlvbiBnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gcGFyc2VkRm9ybWF0U3RyQ2FjaGVbZm9ybWF0U3RyXSB8fFxyXG4gICAgICAgIChwYXJzZWRGb3JtYXRTdHJDYWNoZVtmb3JtYXRTdHJdID0gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSk7XHJcbn1cclxuLypcclxuUGFyc2VzIGEgZm9ybWF0IHN0cmluZyBpbnRvIHRoZSBmb2xsb3dpbmc6XHJcbi0gZmFrZUZvcm1hdFN0cmluZzogYSBtb21lbnRKUyBmb3JtYXR0aW5nIHN0cmluZywgbGl0dGVyZWQgd2l0aCBzcGVjaWFsIGNvbnRyb2wgY2hhcmFjdGVycyB0aGF0IGdldCBwb3N0LXByb2Nlc3NlZC5cclxuLSBzYW1lVW5pdHM6IGZvciBldmVyeSBwYXJ0IGluIGZha2VGb3JtYXRTdHJpbmcsIGlmIHRoZSBwYXJ0IGlzIGEgdG9rZW4sIHRoZSB2YWx1ZSB3aWxsIGJlIGEgdW5pdCBzdHJpbmcgKGxpa2UgXCJkYXlcIiksXHJcbiAgdGhhdCBpbmRpY2F0ZXMgaG93IHNpbWlsYXIgYSByYW5nZSdzIHN0YXJ0ICYgZW5kIG11c3QgYmUgaW4gb3JkZXIgdG8gc2hhcmUgdGhlIHNhbWUgZm9ybWF0dGVkIHRleHQuXHJcbiAgSWYgbm90IGEgdG9rZW4sIHRoZW4gdGhlIHZhbHVlIGlzIG51bGwuXHJcbiAgQWx3YXlzIGEgZmxhdCBhcnJheSAobm90IG5lc3RlZCBsaWtlZCBcImNodW5rc1wiKS5cclxuKi9cclxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmFrZUZvcm1hdFN0cmluZzogYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcyksXHJcbiAgICAgICAgc2FtZVVuaXRzOiBidWlsZFNhbWVVbml0cyhjaHVua3MpXHJcbiAgICB9O1xyXG59XHJcbi8qXHJcbkJyZWFrIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGNodW5rcy5cclxuQSAnbWF5YmUnIGNodW5rIHdpbGwgaGF2ZSBuZXN0ZWQgY2h1bmtzLlxyXG4qL1xyXG5mdW5jdGlvbiBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBbXTtcclxuICAgIHZhciBtYXRjaDtcclxuICAgIC8vIFRPRE86IG1vcmUgZGVzY3JpbWluYXRpb25cclxuICAgIC8vIFxcNCBpcyBhIGJhY2tyZWZlcmVuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIG11bHRpLWNoYXJhY3RlciBzZXQuXHJcbiAgICB2YXIgY2h1bmtlciA9IC9cXFsoW15cXF1dKilcXF18XFwoKFteXFwpXSopXFwpfChMVFN8TFR8KFxcdylcXDQqbz8pfChbXlxcd1xcW1xcKF0rKS9nO1xyXG4gICAgd2hpbGUgKChtYXRjaCA9IGNodW5rZXIuZXhlYyhmb3JtYXRTdHIpKSkge1xyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaC5hcHBseShjaHVua3MsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBzcGxpdFN0cmluZ0xpdGVyYWwobWF0Y2hbMV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2goeyBtYXliZTogY2h1bmtGb3JtYXRTdHJpbmcobWF0Y2hbMl0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaCh7IHRva2VuOiBtYXRjaFszXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbNV0pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2guYXBwbHkoY2h1bmtzLCAvLyBhcHBlbmRcclxuICAgICAgICAgICAgc3BsaXRTdHJpbmdMaXRlcmFsKG1hdGNoWzVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNodW5rcztcclxufVxyXG4vKlxyXG5Qb3RlbnRpYWxseSBzcGxpdHMgYSBsaXRlcmFsLXRleHQgc3RyaW5nIGludG8gbXVsdGlwbGUgcGFydHMuIEZvciBzcGVjaWFsIGNhc2VzLlxyXG4qL1xyXG5mdW5jdGlvbiBzcGxpdFN0cmluZ0xpdGVyYWwocykge1xyXG4gICAgaWYgKHMgPT09ICcuICcpIHtcclxuICAgICAgICByZXR1cm4gWycuJywgJyAnXTsgLy8gZm9yIGxvY2FsZXMgd2l0aCBwZXJpb2RzIGJvdW5kIHRvIHRoZSBlbmQgb2YgZWFjaCB5ZWFyL21vbnRoL2RhdGVcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbc107XHJcbiAgICB9XHJcbn1cclxuLypcclxuR2l2ZW4gY2h1bmtzIHBhcnNlZCBmcm9tIGEgcmVhbCBmb3JtYXQgc3RyaW5nLCBnZW5lcmF0ZSBhIGZha2UgKGFrYSBcImludGVybWVkaWF0ZVwiKSBmb3JtYXQgc3RyaW5nIHdpdGggc3BlY2lhbCBjb250cm9sXHJcbmNoYXJhY3RlcnMgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgZ2l2ZW4gdG8gbW9tZW50IGZvciBmb3JtYXR0aW5nLCBhbmQgdGhlbiBwb3N0LXByb2Nlc3NlZC5cclxuKi9cclxuZnVuY3Rpb24gYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcykge1xyXG4gICAgdmFyIHBhcnRzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBjaHVuaztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdbJyArIGNodW5rICsgJ10nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsudG9rZW4pIHtcclxuICAgICAgICAgICAgaWYgKGNodW5rLnRva2VuIGluIHNwZWNpYWxUb2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goU1BFQ0lBTF9UT0tFTl9NQVJLRVIgKyAvLyB1c2VmdWwgZHVyaW5nIHBvc3QtcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICdbJyArIGNodW5rLnRva2VuICsgJ10nIC8vIHByZXNlcnZlIGFzIGxpdGVyYWwgdGV4dFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goY2h1bmsudG9rZW4pOyAvLyB1bnByb3RlY3RlZCB0ZXh0IGltcGxpZXMgYSBmb3JtYXQgc3RyaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsubWF5YmUpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChNQVlCRV9NQVJLRVIgKyAvLyB1c2VmdWwgZHVyaW5nIHBvc3QtcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rLm1heWJlKSArXHJcbiAgICAgICAgICAgICAgICBNQVlCRV9NQVJLRVIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJ0cy5qb2luKFBBUlRfU0VQQVJBVE9SKTtcclxufVxyXG4vKlxyXG5HaXZlbiBwYXJzZWQgY2h1bmtzIGZyb20gYSByZWFsIGZvcm1hdHRpbmcgc3RyaW5nLCBnZW5lcmF0ZXMgYW4gYXJyYXkgb2YgdW5pdCBzdHJpbmdzIChsaWtlIFwiZGF5XCIpIHRoYXQgaW5kaWNhdGVcclxuaW4gd2hpY2ggcmVnYXJkIHR3byBkYXRlcyBtdXN0IGJlIHNpbWlsYXIgaW4gb3JkZXIgdG8gc2hhcmUgcmFuZ2UgZm9ybWF0dGluZyB0ZXh0LlxyXG5UaGUgYGNodW5rc2AgY2FuIGJlIG5lc3RlZCAoYmVjYXVzZSBvZiBcIm1heWJlXCIgY2h1bmtzKSwgaG93ZXZlciwgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgYmUgZmxhdC5cclxuKi9cclxuZnVuY3Rpb24gYnVpbGRTYW1lVW5pdHMoY2h1bmtzKSB7XHJcbiAgICB2YXIgdW5pdHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGNodW5rO1xyXG4gICAgdmFyIHRva2VuSW5mbztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAoY2h1bmsudG9rZW4pIHtcclxuICAgICAgICAgICAgdG9rZW5JbmZvID0gbGFyZ2VUb2tlbk1hcFtjaHVuay50b2tlbi5jaGFyQXQoMCldO1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoKHRva2VuSW5mbyA/IHRva2VuSW5mby51bml0IDogJ3NlY29uZCcpOyAvLyBkZWZhdWx0IHRvIGEgdmVyeSBzdHJpY3Qgc2FtZS1zZWNvbmRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsubWF5YmUpIHtcclxuICAgICAgICAgICAgdW5pdHMucHVzaC5hcHBseSh1bml0cywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGJ1aWxkU2FtZVVuaXRzKGNodW5rLm1heWJlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bml0cztcclxufVxyXG4vLyBSZW5kZXJpbmcgdG8gdGV4dFxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuRm9ybWF0cyBhIGRhdGUgd2l0aCBhIGZha2UgZm9ybWF0IHN0cmluZywgcG9zdC1wcm9jZXNzZXMgdGhlIGNvbnRyb2wgY2hhcmFjdGVycywgdGhlbiByZXR1cm5zLlxyXG4qL1xyXG5mdW5jdGlvbiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpIHtcclxuICAgIHJldHVybiBwcm9jZXNzTWF5YmVNYXJrZXJzKHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhmYWtlRm9ybWF0U3RyaW5nLCBkYXRlKS5qb2luKCcnKSk7XHJcbn1cclxuLypcclxuRm9ybWF0cyBhIGRhdGUgaW50byBwYXJ0cyB0aGF0IHdpbGwgaGF2ZSBiZWVuIHBvc3QtcHJvY2Vzc2VkLCBFWENFUFQgZm9yIHRoZSBcIm1heWJlXCIgbWFya2Vycy5cclxuKi9cclxuZnVuY3Rpb24gcmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgdmFyIGZha2VSZW5kZXIgPSBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsIGZha2VGb3JtYXRTdHJpbmcpO1xyXG4gICAgdmFyIGZha2VQYXJ0cyA9IGZha2VSZW5kZXIuc3BsaXQoUEFSVF9TRVBBUkFUT1IpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgZmFrZVBhcnQ7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmFrZVBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZmFrZVBhcnQgPSBmYWtlUGFydHNbaV07XHJcbiAgICAgICAgaWYgKGZha2VQYXJ0LmNoYXJBdCgwKSA9PT0gU1BFQ0lBTF9UT0tFTl9NQVJLRVIpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChcclxuICAgICAgICAgICAgLy8gdGhlIGxpdGVyYWwgc3RyaW5nIElTIHRoZSB0b2tlbidzIG5hbWUuXHJcbiAgICAgICAgICAgIC8vIGNhbGwgc3BlY2lhbCB0b2tlbidzIHJlZ2lzdGVyZWQgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgIHNwZWNpYWxUb2tlbnNbZmFrZVBhcnQuc3Vic3RyaW5nKDEpXShkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGZha2VQYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFydHM7XHJcbn1cclxuLypcclxuQWNjZXB0cyBhbiBhbG1vc3QtZmluYWxseS1mb3JtYXR0ZWQgc3RyaW5nIGFuZCBwcm9jZXNzZXMgdGhlIFwibWF5YmVcIiBjb250cm9sIGNoYXJhY3RlcnMsIHJldHVybmluZyBhIG5ldyBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHByb2Nlc3NNYXliZU1hcmtlcnMocykge1xyXG4gICAgcmV0dXJuIHMucmVwbGFjZShNQVlCRV9SRUdFWFAsIGZ1bmN0aW9uIChtMCwgbTEpIHtcclxuICAgICAgICBpZiAobTEubWF0Y2goL1sxLTldLykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8vIE1pc2MgVXRpbHNcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5SZXR1cm5zIGEgdW5pdCBzdHJpbmcsIGVpdGhlciAneWVhcicsICdtb250aCcsICdkYXknLCBvciBudWxsIGZvciB0aGUgbW9zdCBncmFudWxhciBmb3JtYXR0aW5nIHRva2VuIGluIHRoZSBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdChmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgY2h1bms7XHJcbiAgICB2YXIgY2FuZGlkYXRlO1xyXG4gICAgdmFyIGJlc3Q7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07XHJcbiAgICAgICAgaWYgKGNodW5rLnRva2VuKSB7XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGxhcmdlVG9rZW5NYXBbY2h1bmsudG9rZW4uY2hhckF0KDApXTtcclxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiZXN0IHx8IGNhbmRpZGF0ZS52YWx1ZSA+IGJlc3QudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0ID0gY2FuZGlkYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJlc3QpIHtcclxuICAgICAgICByZXR1cm4gYmVzdC51bml0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0cy5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQgPSBxdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE1vZGVsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9kZWwoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fd2F0Y2hlcnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5fcHJvcHMgPSB7fTtcclxuICAgICAgICBfdGhpcy5hcHBseUdsb2JhbFdhdGNoZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuY29uc3RydWN0ZWQoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNb2RlbC53YXRjaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBtYWtlIGEgbWFza2VkLWNvcHkgb2YgdGhlIHN1cGVyY2xhc3MncyBtYXBcclxuICAgICAgICAvLyBUT0RPOiB3cml0ZSB0ZXN0XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX2dsb2JhbFdhdGNoQXJncycpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb3RvdHlwZS5fZ2xvYmFsV2F0Y2hBcmdzW25hbWVdID0gYXJncztcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdXNlZnVsIGZvciBtb25rZXlwYXRjaGluZy4gVE9ETzogQmFzZUNsYXNzP1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hcHBseUdsb2JhbFdhdGNoZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9nbG9iYWxXYXRjaEFyZ3M7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLndhdGNoLmFwcGx5KHRoaXMsIFtuYW1lXS5jb25jYXQobWFwW25hbWVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lIGluIHRoaXMuX3Byb3BzO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICB2YXIgbmV3UHJvcHM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBuZXdQcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tuYW1lXSA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhuZXdQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIG9sZFByb3BzID0gdGhpcy5fcHJvcHM7XHJcbiAgICAgICAgdmFyIGNoYW5nZXNldCA9IHt9OyAvLyB3aWxsIGhhdmUgdW5kZWZpbmVkJ3MgdG8gc2lnbmFsIHVuc2V0c1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICBjaGFuZ2VzZXRbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBjaGFuZ2VzZXRbbmFtZV0gPSBuZXdQcm9wc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhjaGFuZ2VzZXQpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIG5ld1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIG5hbWVzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbmFtZXMgPSBbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuYW1lcyA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tuYW1lc1tpXV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UHJvcHMobmV3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zZXRQcm9wcyA9IGZ1bmN0aW9uIChuZXdQcm9wcykge1xyXG4gICAgICAgIHZhciBjaGFuZ2VkUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgY2hhbmdlZENudCA9IDA7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKG5hbWUgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgdmFsID0gbmV3UHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgIC8vIGEgY2hhbmdlIGluIHZhbHVlP1xyXG4gICAgICAgICAgICAvLyBpZiBhbiBvYmplY3QsIGRvbid0IGNoZWNrIGVxdWFsaXR5LCBiZWNhdXNlIG1pZ2h0IGhhdmUgYmVlbiBtdXRhdGVkIGludGVybmFsbHkuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGV2ZW50dWFsbHkgZW5mb3JjZSBpbW11dGFiaWxpdHkuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgdmFsICE9PSB0aGlzLl9wcm9wc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZFByb3BzW25hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VkQ250KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmJhdGNoQ2hhbmdlJywgY2hhbmdlZFByb3BzKTtcclxuICAgICAgICAgICAgZm9yIChuYW1lIGluIGNoYW5nZWRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gY2hhbmdlZFByb3BzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6Y2hhbmdlJywgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmNoYW5nZTonICsgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gY2hhbmdlZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjaGFuZ2VkUHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmF0Y2hDaGFuZ2UnLCBjaGFuZ2VkUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAobmFtZSwgZGVwTGlzdCwgc3RhcnRGdW5jLCBzdG9wRnVuYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy51bndhdGNoKG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3dhdGNoZXJzW25hbWVdID0gdGhpcy5fd2F0Y2hEZXBzKGRlcExpc3QsIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBzdGFydEZ1bmMuY2FsbChfdGhpcywgZGVwcyk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnVuc2V0KG5hbWUpOyAvLyBwdXQgaW4gYW4gdW5zZXQgc3RhdGUgd2hpbGUgcmVzb2x2aW5nXHJcbiAgICAgICAgICAgICAgICByZXMudGhlbihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0KG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldChuYW1lLCByZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgX3RoaXMudW5zZXQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChzdG9wRnVuYykge1xyXG4gICAgICAgICAgICAgICAgc3RvcEZ1bmMuY2FsbChfdGhpcywgZGVwcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUudW53YXRjaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcclxuICAgICAgICBpZiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fd2F0Y2hlcnNbbmFtZV07XHJcbiAgICAgICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLl93YXRjaERlcHMgPSBmdW5jdGlvbiAoZGVwTGlzdCwgc3RhcnRGdW5jLCBzdG9wRnVuYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHF1ZXVlZENoYW5nZUNudCA9IDA7XHJcbiAgICAgICAgdmFyIGRlcENudCA9IGRlcExpc3QubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzYXRpc2Z5Q250ID0gMDtcclxuICAgICAgICB2YXIgdmFsdWVzID0ge307IC8vIHdoYXQncyBwYXNzZWQgYXMgdGhlIGBkZXBzYCBhcmd1bWVudHNcclxuICAgICAgICB2YXIgYmluZFR1cGxlcyA9IFtdOyAvLyBhcnJheSBvZiBbIGV2ZW50TmFtZSwgaGFuZGxlckZ1bmMgXSBhcnJheXNcclxuICAgICAgICB2YXIgaXNDYWxsaW5nU3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBvbkJlZm9yZURlcENoYW5nZSA9IGZ1bmN0aW9uIChkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgcXVldWVkQ2hhbmdlQ250Kys7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZWRDaGFuZ2VDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0NhbGxpbmdTdG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2FsbGluZ1N0b3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9uRGVwQ2hhbmdlID0gZnVuY3Rpb24gKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGRlcGVuZGVuY3kgdGhhdCB3YXMgcHJldmlvdXNseSBzZXQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3B0aW9uYWwgJiYgdmFsdWVzW2RlcE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzYXRpc2Z5Q250LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW2RlcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZGVwZW5kZW5jeSB0aGF0IHdhcyBwcmV2aW91c2x5IHVuc2V0P1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09wdGlvbmFsICYmIHZhbHVlc1tkZXBOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F0aXNmeUNudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsdWVzW2RlcE5hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHF1ZXVlZENoYW5nZUNudC0tO1xyXG4gICAgICAgICAgICBpZiAoIXF1ZXVlZENoYW5nZUNudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm93IGZpbmFsbHkgc2F0aXNmaWVkIG9yIHNhdGlzZmllZCBhbGwgYWxvbmc/XHJcbiAgICAgICAgICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0b3BGdW5jIGluaXRpYXRlZCBhbm90aGVyIHZhbHVlIGNoYW5nZSwgaWdub3JlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IGFub3RoZXIgY2hhbmdlIGV2ZW50IGFueXdheS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FsbGluZ1N0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBpbnRlcmNlcHQgZm9yIC5vbigpIHRoYXQgcmVtZW1iZXJzIGhhbmRsZXJzXHJcbiAgICAgICAgdmFyIGJpbmQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGJpbmRUdXBsZXMucHVzaChbZXZlbnROYW1lLCBoYW5kbGVyXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBsaXN0ZW4gdG8gZGVwZW5kZW5jeSBjaGFuZ2VzXHJcbiAgICAgICAgZGVwTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXBOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChkZXBOYW1lLmNoYXJBdCgwKSA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gZGVwTmFtZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiaW5kKCdiZWZvcmU6Y2hhbmdlOicgKyBkZXBOYW1lLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBvbkJlZm9yZURlcENoYW5nZShkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYmluZCgnY2hhbmdlOicgKyBkZXBOYW1lLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBvbkRlcENoYW5nZShkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBwcm9jZXNzIGN1cnJlbnQgZGVwZW5kZW5jeSB2YWx1ZXNcclxuICAgICAgICBkZXBMaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlcE5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGRlcE5hbWUuY2hhckF0KDApID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBkZXBOYW1lLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYXMoZGVwTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlc1tkZXBOYW1lXSA9IF90aGlzLmdldChkZXBOYW1lKTtcclxuICAgICAgICAgICAgICAgIHNhdGlzZnlDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICBzYXRpc2Z5Q250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBpbml0aWFsbHkgc2F0aXNmaWVkXHJcbiAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICBzdGFydEZ1bmModmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluZFR1cGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihiaW5kVHVwbGVzW2ldWzBdLCBiaW5kVHVwbGVzW2ldWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJpbmRUdXBsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gd2FzIHNhdGlzZmllZCwgc28gY2FsbCBzdG9wRnVuY1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BGdW5jKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZsYXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEZ1bmMoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEZ1bmModmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmZsYXNoID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXJzW25hbWVdO1xyXG4gICAgICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgICAgICAgIHdhdGNoZXIuZmxhc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZGVsO1xyXG59KENsYXNzXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNb2RlbDtcclxuTW9kZWwucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MgPSB7fTsgLy8gbXV0YXRpb24gcHJvdGVjdGlvbiBpbiBNb2RlbC53YXRjaFxyXG5FbWl0dGVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW9kZWwpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKE1vZGVsKTtcclxuXG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBSZWN1cnJpbmdFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTApO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKGV2ZW50SW5wdXQsIHNvdXJjZSkge1xyXG4gICAgICAgIGlmICh1dGlsXzEuaXNUaW1lU3RyaW5nKGV2ZW50SW5wdXQuc3RhcnQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGV2ZW50SW5wdXQuc3RhcnQpIHx8XHJcbiAgICAgICAgICAgIHV0aWxfMS5pc1RpbWVTdHJpbmcoZXZlbnRJbnB1dC5lbmQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGV2ZW50SW5wdXQuZW5kKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVjdXJyaW5nRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGVmRGF0ZU11dGF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJFbmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlVGltZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlQWxsRGF5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5jcmVhdGVGcm9tRGlmZiA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZTAsIGRhdGVQcm9maWxlMSwgbGFyZ2VVbml0KSB7XHJcbiAgICAgICAgdmFyIGNsZWFyRW5kID0gZGF0ZVByb2ZpbGUwLmVuZCAmJiAhZGF0ZVByb2ZpbGUxLmVuZDtcclxuICAgICAgICB2YXIgZm9yY2VUaW1lZCA9IGRhdGVQcm9maWxlMC5pc0FsbERheSgpICYmICFkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKTtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSAhZGF0ZVByb2ZpbGUwLmlzQWxsRGF5KCkgJiYgZGF0ZVByb2ZpbGUxLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgdmFyIGRhdGVEZWx0YTtcclxuICAgICAgICB2YXIgZW5kRGlmZjtcclxuICAgICAgICB2YXIgZW5kRGVsdGE7XHJcbiAgICAgICAgdmFyIG11dGF0aW9uO1xyXG4gICAgICAgIC8vIHN1YnRyYWN0cyB0aGUgZGF0ZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHdheSwgcmV0dXJuaW5nIGEgZHVyYXRpb25cclxuICAgICAgICBmdW5jdGlvbiBzdWJ0cmFjdERhdGVzKGRhdGUxLCBkYXRlMCkge1xyXG4gICAgICAgICAgICBpZiAobGFyZ2VVbml0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZCeVVuaXQoZGF0ZTEsIGRhdGUwLCBsYXJnZVVuaXQpOyAvLyBwb29ybHkgbmFtZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5KGRhdGUxLCBkYXRlMCk7IC8vIHBvb3JseSBuYW1lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5VGltZShkYXRlMSwgZGF0ZTApOyAvLyBwb29ybHkgbmFtZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlRGVsdGEgPSBzdWJ0cmFjdERhdGVzKGRhdGVQcm9maWxlMS5zdGFydCwgZGF0ZVByb2ZpbGUwLnN0YXJ0KTtcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUxLmVuZCkge1xyXG4gICAgICAgICAgICAvLyB1c2UgdW56b25lZFJhbmdlcyBiZWNhdXNlIGRhdGVQcm9maWxlMC5lbmQgbWlnaHQgYmUgbnVsbFxyXG4gICAgICAgICAgICBlbmREaWZmID0gc3VidHJhY3REYXRlcyhkYXRlUHJvZmlsZTEudW56b25lZFJhbmdlLmdldEVuZCgpLCBkYXRlUHJvZmlsZTAudW56b25lZFJhbmdlLmdldEVuZCgpKTtcclxuICAgICAgICAgICAgZW5kRGVsdGEgPSBlbmREaWZmLnN1YnRyYWN0KGRhdGVEZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uKCk7XHJcbiAgICAgICAgbXV0YXRpb24uY2xlYXJFbmQgPSBjbGVhckVuZDtcclxuICAgICAgICBtdXRhdGlvbi5mb3JjZVRpbWVkID0gZm9yY2VUaW1lZDtcclxuICAgICAgICBtdXRhdGlvbi5mb3JjZUFsbERheSA9IGZvcmNlQWxsRGF5O1xyXG4gICAgICAgIG11dGF0aW9uLnNldERhdGVEZWx0YShkYXRlRGVsdGEpO1xyXG4gICAgICAgIG11dGF0aW9uLnNldEVuZERlbHRhKGVuZERlbHRhKTtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIHJldHVybnMgYW4gdW5kbyBmdW5jdGlvbi5cclxuICAgICovXHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuYnVpbGROZXdEYXRlUHJvZmlsZSA9IGZ1bmN0aW9uIChldmVudERhdGVQcm9maWxlLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzdGFydCA9IGV2ZW50RGF0ZVByb2ZpbGUuc3RhcnQuY2xvbmUoKTtcclxuICAgICAgICB2YXIgZW5kID0gbnVsbDtcclxuICAgICAgICB2YXIgc2hvdWxkUmV6b25lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0ZVByb2ZpbGUuZW5kICYmICF0aGlzLmNsZWFyRW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGV2ZW50RGF0ZVByb2ZpbGUuZW5kLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5kRGVsdGEgJiYgIWVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREYXRlUHJvZmlsZS5pc0FsbERheSgpLCBzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZvcmNlVGltZWQpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCAmJiAhZW5kLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmIGVuZC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRlRGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhcnQuYWRkKHRoaXMuZGF0ZURlbHRhKTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmRhdGVEZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG8gdGhpcyBiZWZvcmUgYWRkaW5nIHN0YXJ0RGVsdGEgdG8gc3RhcnQsIHNvIHdlIGNhbiB3b3JrIG9mZiBvZiBzdGFydFxyXG4gICAgICAgIGlmICh0aGlzLmVuZERlbHRhKSB7XHJcbiAgICAgICAgICAgIHNob3VsZFJlem9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGVuZC5hZGQodGhpcy5lbmREZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhcnQuYWRkKHRoaXMuc3RhcnREZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZXpvbmUpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKHN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IG9rYXkgdG8gYWNjZXNzIGNhbGVuZGFyIG9wdGlvbj9cclxuICAgICAgICBpZiAoIWVuZCAmJiBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChldmVudERhdGVQcm9maWxlLmlzQWxsRGF5KCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChzdGFydCwgZW5kLCBjYWxlbmRhcik7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldERhdGVEZWx0YSA9IGZ1bmN0aW9uIChkYXRlRGVsdGEpIHtcclxuICAgICAgICBpZiAoZGF0ZURlbHRhICYmIGRhdGVEZWx0YS52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlRGVsdGEgPSBkYXRlRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVEZWx0YSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLnByb3RvdHlwZS5zZXRTdGFydERlbHRhID0gZnVuY3Rpb24gKHN0YXJ0RGVsdGEpIHtcclxuICAgICAgICBpZiAoc3RhcnREZWx0YSAmJiBzdGFydERlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsdGEgPSBzdGFydERlbHRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldEVuZERlbHRhID0gZnVuY3Rpb24gKGVuZERlbHRhKSB7XHJcbiAgICAgICAgaWYgKGVuZERlbHRhICYmIGVuZERlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZERlbHRhID0gZW5kRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVuZERlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmNsZWFyRW5kICYmICF0aGlzLmZvcmNlVGltZWQgJiYgIXRoaXMuZm9yY2VBbGxEYXkgJiZcclxuICAgICAgICAgICAgIXRoaXMuZGF0ZURlbHRhICYmICF0aGlzLnN0YXJ0RGVsdGEgJiYgIXRoaXMuZW5kRGVsdGE7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmRGF0ZU11dGF0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZkRhdGVNdXRhdGlvbjtcclxuXG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3RhbmRhcmRUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTMpO1xyXG52YXIgSnF1ZXJ5VWlUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTQpO1xyXG52YXIgdGhlbWVDbGFzc0hhc2ggPSB7fTtcclxuZnVuY3Rpb24gZGVmaW5lVGhlbWVTeXN0ZW0odGhlbWVOYW1lLCB0aGVtZUNsYXNzKSB7XHJcbiAgICB0aGVtZUNsYXNzSGFzaFt0aGVtZU5hbWVdID0gdGhlbWVDbGFzcztcclxufVxyXG5leHBvcnRzLmRlZmluZVRoZW1lU3lzdGVtID0gZGVmaW5lVGhlbWVTeXN0ZW07XHJcbmZ1bmN0aW9uIGdldFRoZW1lU3lzdGVtQ2xhc3ModGhlbWVTZXR0aW5nKSB7XHJcbiAgICBpZiAoIXRoZW1lU2V0dGluZykge1xyXG4gICAgICAgIHJldHVybiBTdGFuZGFyZFRoZW1lXzEuZGVmYXVsdDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoZW1lU2V0dGluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBKcXVlcnlVaVRoZW1lXzEuZGVmYXVsdDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGVtZUNsYXNzSGFzaFt0aGVtZVNldHRpbmddO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZ2V0VGhlbWVTeXN0ZW1DbGFzcyA9IGdldFRoZW1lU3lzdGVtQ2xhc3M7XHJcblxuXG4vKioqLyB9KSxcbi8qIDUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEFycmF5RXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBcnJheUV2ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXJyYXlFdmVudFNvdXJjZShjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmV2ZW50RGVmcyA9IFtdOyAvLyBmb3IgaWYgc2V0UmF3RXZlbnREZWZzIGlzIG5ldmVyIGNhbGxlZFxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFycmF5RXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd0lucHV0LmV2ZW50cykpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgZXZlbnRzOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5zZXRSYXdFdmVudERlZnMgPSBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgdGhpcy5yYXdFdmVudERlZnMgPSByYXdFdmVudERlZnM7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMgPSB0aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcyk7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gdGhpcy5ldmVudERlZnM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRpbWV6b25lICE9IG51bGwgJiZcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZXpvbmUgIT09IHRpbWV6b25lKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudERlZnNbaV0gaW5zdGFuY2VvZiBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERlZnNbaV0ucmV6b25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZXpvbmUgPSB0aW1lem9uZTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQucmVzb2x2ZShldmVudERlZnMpO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMucHVzaChldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGV2ZW50RGVmSWQgYWxyZWFkeSBub3JtYWxpemVkIHRvIGEgc3RyaW5nXHJcbiAgICAqL1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5yZW1vdmVNYXRjaGluZyh0aGlzLmV2ZW50RGVmcywgZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZi5pZCA9PT0gZXZlbnREZWZJZDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMgPSBbXTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRQcmltaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3RXZlbnREZWZzO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB0aGlzLnNldFJhd0V2ZW50RGVmcyhyYXdQcm9wcy5ldmVudHMpO1xyXG4gICAgICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFycmF5RXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFycmF5RXZlbnRTb3VyY2U7XHJcbkFycmF5RXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICBldmVudHM6IGZhbHNlIC8vIGRvbid0IGF1dG9tYXRpY2FsbHkgdHJhbnNmZXJcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLypcclxuQSBjYWNoZSBmb3IgdGhlIGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQgdmFsdWVzIGZvciBvbmUgb3IgbW9yZSBlbGVtZW50cy5cclxuV29ya3Mgd2l0aCBib3RoIG9mZnNldCAoZnJvbSB0b3BsZWZ0IGRvY3VtZW50KSBhbmQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50KS5cclxuXG5vcHRpb25zOlxyXG4tIGVsc1xyXG4tIGlzSG9yaXpvbnRhbFxyXG4tIGlzVmVydGljYWxcclxuKi9cclxudmFyIENvb3JkQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb29yZENhY2hlKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IGZhbHNlOyAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciBsZWZ0L3JpZ2h0L3dpZHRoXHJcbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gZmFsc2U7IC8vIHdoZXRoZXIgdG8gcXVlcnkgZm9yIHRvcC9ib3R0b20vaGVpZ2h0XHJcbiAgICAgICAgdGhpcy5lbHMgPSAkKG9wdGlvbnMuZWxzKTtcclxuICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IG9wdGlvbnMuaXNIb3Jpem9udGFsO1xyXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9IG9wdGlvbnMuaXNWZXJ0aWNhbDtcclxuICAgICAgICB0aGlzLmZvcmNlZE9mZnNldFBhcmVudEVsID0gb3B0aW9ucy5vZmZzZXRQYXJlbnQgPyAkKG9wdGlvbnMub2Zmc2V0UGFyZW50KSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBRdWVyaWVzIHRoZSBlbHMgZm9yIGNvb3JkaW5hdGVzIGFuZCBzdG9yZXMgdGhlbS5cclxuICAgIC8vIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIGFuZCBvZiB0aGUgZ2V0KiBtZXRob2RzIGJlbG93LlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudEVsID0gdGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbDtcclxuICAgICAgICBpZiAoIW9mZnNldFBhcmVudEVsICYmIHRoaXMuZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50RWwgPSB0aGlzLmVscy5lcSgwKS5vZmZzZXRQYXJlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBvZmZzZXRQYXJlbnRFbCA/XHJcbiAgICAgICAgICAgIG9mZnNldFBhcmVudEVsLm9mZnNldCgpIDpcclxuICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmVjdCA9IHRoaXMucXVlcnlCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGVzdHJveXMgYWxsIGludGVybmFsIGRhdGEgYWJvdXQgY29vcmRpbmF0ZXMsIGZyZWVpbmcgbWVtb3J5XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JlY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVmdHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRvcHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm90dG9tcyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gV2hlbiBjYWxsZWQsIGlmIGNvb3JkIGNhY2hlcyBhcmVuJ3QgYnVpbHQsIGJ1aWxkcyB0aGVtXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5lbnN1cmVCdWlsdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMub3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5idWlsZEVsSG9yaXpvbnRhbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnRzID0gW107XHJcbiAgICAgICAgdmFyIHJpZ2h0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWxzLmVhY2goZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gJChub2RlKTtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBlbC5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIGxlZnRzLnB1c2gobGVmdCk7XHJcbiAgICAgICAgICAgIHJpZ2h0cy5wdXNoKGxlZnQgKyB3aWR0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xyXG4gICAgICAgIHRoaXMucmlnaHRzID0gcmlnaHRzO1xyXG4gICAgfTtcclxuICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuYnVpbGRFbFZlcnRpY2FscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG9wcyA9IFtdO1xyXG4gICAgICAgIHZhciBib3R0b21zID0gW107XHJcbiAgICAgICAgdGhpcy5lbHMuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gZWwub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWwub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICAgICAgdG9wcy5wdXNoKHRvcCk7XHJcbiAgICAgICAgICAgIGJvdHRvbXMucHVzaCh0b3AgKyBoZWlnaHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudG9wcyA9IHRvcHM7XHJcbiAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cclxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldEhvcml6b250YWxJbmRleCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHZhciBsZWZ0cyA9IHRoaXMubGVmdHM7XHJcbiAgICAgICAgdmFyIHJpZ2h0cyA9IHRoaXMucmlnaHRzO1xyXG4gICAgICAgIHZhciBsZW4gPSBsZWZ0cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0T2Zmc2V0ID49IGxlZnRzW2ldICYmIGxlZnRPZmZzZXQgPCByaWdodHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXHJcbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRWZXJ0aWNhbEluZGV4ID0gZnVuY3Rpb24gKHRvcE9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICB2YXIgdG9wcyA9IHRoaXMudG9wcztcclxuICAgICAgICB2YXIgYm90dG9tcyA9IHRoaXMuYm90dG9tcztcclxuICAgICAgICB2YXIgbGVuID0gdG9wcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0b3BPZmZzZXQgPj0gdG9wc1tpXSAmJiB0b3BPZmZzZXQgPCBib3R0b21zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldExlZnRPZmZzZXQgPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgbGVmdCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRMZWZ0UG9zaXRpb24gPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHJpZ2h0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRSaWdodE9mZnNldCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgcmlnaHQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRSaWdodFBvc2l0aW9uID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0VG9wT2Zmc2V0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcHNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRvcCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFRvcFBvc2l0aW9uID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcHNbdG9wSW5kZXhdIC0gdGhpcy5vcmlnaW4udG9wO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGJvdHRvbSBvZmZzZXQgKGZyb20gdGhlIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0Qm90dG9tT2Zmc2V0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGJvdHRvbSBwb3NpdGlvbiAoZnJvbSB0aGUgb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0Qm90dG9tUG9zaXRpb24gPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLm9yaWdpbi50b3A7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBCb3VuZGluZyBSZWN0XHJcbiAgICAvLyBUT0RPOiBkZWNvdXBsZSB0aGlzIGZyb20gQ29vcmRDYWNoZVxyXG4gICAgLy8gQ29tcHV0ZSBhbmQgcmV0dXJuIHdoYXQgdGhlIGVsZW1lbnRzJyBib3VuZGluZyByZWN0YW5nbGUgaXMsIGZyb20gdGhlIHVzZXIncyBwZXJzcGVjdGl2ZS5cclxuICAgIC8vIFJpZ2h0IG5vdywgb25seSByZXR1cm5zIGEgcmVjdGFuZ2xlIGlmIGNvbnN0cmFpbmVkIGJ5IGFuIG92ZXJmbG93OnNjcm9sbCBlbGVtZW50LlxyXG4gICAgLy8gUmV0dXJucyBudWxsIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50c1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUucXVlcnlCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudEVsO1xyXG4gICAgICAgIGlmICh0aGlzLmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudEVsID0gdXRpbF8xLmdldFNjcm9sbFBhcmVudCh0aGlzLmVscy5lcSgwKSk7XHJcbiAgICAgICAgICAgIGlmICghc2Nyb2xsUGFyZW50RWwuaXMoZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmdldENsaWVudFJlY3Qoc2Nyb2xsUGFyZW50RWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmlzUG9pbnRJbkJvdW5kcyA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiB0aGlzLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KTtcclxuICAgIH07XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5pc0xlZnRJbkJvdW5kcyA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAobGVmdE9mZnNldCA+PSB0aGlzLmJvdW5kaW5nUmVjdC5sZWZ0ICYmIGxlZnRPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5yaWdodCk7XHJcbiAgICB9O1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuaXNUb3BJbkJvdW5kcyA9IGZ1bmN0aW9uICh0b3BPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuYm91bmRpbmdSZWN0IHx8ICh0b3BPZmZzZXQgPj0gdGhpcy5ib3VuZGluZ1JlY3QudG9wICYmIHRvcE9mZnNldCA8IHRoaXMuYm91bmRpbmdSZWN0LmJvdHRvbSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvb3JkQ2FjaGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvb3JkQ2FjaGU7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuLyogVHJhY2tzIGEgZHJhZydzIG1vdXNlIG1vdmVtZW50LCBmaXJpbmcgdmFyaW91cyBoYW5kbGVyc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gVE9ETzogdXNlIEVtaXR0ZXJcclxudmFyIERyYWdMaXN0ZW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERyYWdMaXN0ZW5lcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzVG91Y2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzR2VuZXJpYyA9IGZhbHNlOyAvLyBpbml0aWF0ZWQgYnkgJ2RyYWdzdGFydCcgKGpxdWkpXHJcbiAgICAgICAgdGhpcy5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxBbHdheXNLaWxscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNBdXRvU2Nyb2xsID0gZmFsc2U7XHJcbiAgICAgICAgLy8gZGVmYXVsdHNcclxuICAgICAgICB0aGlzLnNjcm9sbFNlbnNpdGl2aXR5ID0gMzA7IC8vIHBpeGVscyBmcm9tIGVkZ2UgZm9yIHNjcm9sbGluZyB0byBzdGFydFxyXG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSAyMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kLCBhdCBtYXhpbXVtIHNwZWVkXHJcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbE1zID0gNTA7IC8vIG1pbGxpc2Vjb25kIHdhaXQgYmV0d2VlbiBzY3JvbGwgaW5jcmVtZW50XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8vIEludGVyYWN0aW9uIChoaWdoLWxldmVsKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc3RhcnRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldiwgZXh0cmFPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGV4dHJhT3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKGV2LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcbiAgICAgICAgICAgIGlmIChHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKS5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWxfMS5pc1ByaW1hcnlNb3VzZUJ1dHRvbihldikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIG5hdGl2ZSBzZWxlY3Rpb24gaW4gbW9zdCBicm93c2Vyc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3Mgb3B0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gdXRpbF8xLmZpcnN0RGVmaW5lZChleHRyYU9wdGlvbnMuZGVsYXksIHRoaXMub3B0aW9ucy5kZWxheSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWluRGlzdGFuY2UgPSB1dGlsXzEuZmlyc3REZWZpbmVkKGV4dHJhT3B0aW9ucy5kaXN0YW5jZSwgdGhpcy5vcHRpb25zLmRpc3RhbmNlLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSB0aGlzLm9wdGlvbnMuc3ViamVjdEVsO1xyXG4gICAgICAgICAgICB1dGlsXzEucHJldmVudFNlbGVjdGlvbigkKCdib2R5JykpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmlzVG91Y2ggPSB1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5pc0dlbmVyaWMgPSBldi50eXBlID09PSAnZHJhZ3N0YXJ0JztcclxuICAgICAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luWCA9IHV0aWxfMS5nZXRFdlgoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpblkgPSB1dGlsXzEuZ2V0RXZZKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbCA9IHV0aWxfMS5nZXRTY3JvbGxQYXJlbnQoJChldi50YXJnZXQpKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kSGFuZGxlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0QXV0b1Njcm9sbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uU3RhcnQoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignaW50ZXJhY3Rpb25TdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZEludGVyYWN0aW9uID0gZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmREcmFnKGV2KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUF1dG9TY3JvbGwoKTtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmRIYW5kbGVycygpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbkVuZChldiwgaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICB1dGlsXzEuYWxsb3dTZWxlY3Rpb24oJCgnYm9keScpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZCA9IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2ludGVyYWN0aW9uRW5kJywgZXYsIGlzQ2FuY2VsbGVkIHx8IGZhbHNlKTtcclxuICAgIH07XHJcbiAgICAvLyBCaW5kaW5nIFRvIERPTVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuYmluZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKFNhZmFyaSBpbiBpT1MgMTApIGRvbid0IGFsbG93IHByZXZlbnREZWZhdWx0IG9uIHRvdWNoIGV2ZW50cyB0aGF0IGFyZSBib3VuZCBhZnRlciB0b3VjaHN0YXJ0LFxyXG4gICAgICAgIC8vIHNvIGxpc3RlbiB0byB0aGUgR2xvYmFsRW1pdHRlciBzaW5nbGV0b24sIHdoaWNoIGlzIGFsd2F5cyBib3VuZCwgaW5zdGVhZCBvZiB0aGUgZG9jdW1lbnQgZGlyZWN0bHkuXHJcbiAgICAgICAgdmFyIGdsb2JhbEVtaXR0ZXIgPSBHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0dlbmVyaWMpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICAgICAgZHJhZzogdGhpcy5oYW5kbGVNb3ZlLFxyXG4gICAgICAgICAgICAgICAgZHJhZ3N0b3A6IHRoaXMuZW5kSW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUb3VjaCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIHRvdWNobW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXHJcbiAgICAgICAgICAgICAgICB0b3VjaGVuZDogdGhpcy5lbmRJbnRlcmFjdGlvbixcclxuICAgICAgICAgICAgICAgIHNjcm9sbDogdGhpcy5oYW5kbGVUb3VjaFNjcm9sbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xyXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcclxuICAgICAgICAgICAgICAgIG1vdXNldXA6IHRoaXMuZW5kSW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xyXG4gICAgICAgICAgICBzZWxlY3RzdGFydDogdXRpbF8xLnByZXZlbnREZWZhdWx0LFxyXG4gICAgICAgICAgICBjb250ZXh0bWVudTogdXRpbF8xLnByZXZlbnREZWZhdWx0IC8vIGxvbmcgdGFwcyB3b3VsZCBvcGVuIG1lbnUgb24gQ2hyb21lIGRldiB0b29sc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUudW5iaW5kSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkpO1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTsgLy8gZm9yIGlzR2VuZXJpY1xyXG4gICAgfTtcclxuICAgIC8vIERyYWcgKGhpZ2gtbGV2ZWwpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXh0cmFPcHRpb25zIGlnbm9yZWQgaWYgZHJhZyBhbHJlYWR5IHN0YXJ0ZWRcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2LCBleHRyYU9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIGV4dHJhT3B0aW9ucyk7IC8vIGVuc3VyZSBpbnRlcmFjdGlvbiBiZWdhblxyXG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RyYWdTdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgZHggPSB1dGlsXzEuZ2V0RXZYKGV2KSAtIHRoaXMub3JpZ2luWDtcclxuICAgICAgICB2YXIgZHkgPSB1dGlsXzEuZ2V0RXZZKGV2KSAtIHRoaXMub3JpZ2luWTtcclxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZVNxOyAvLyBjdXJyZW50IGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiwgc3F1YXJlZFxyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlU3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWcoZHgsIGR5LCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGlsZSB0aGUgbW91c2UgaXMgYmVpbmcgbW92ZWQgYW5kIHdoZW4gd2Uga25vdyBhIGxlZ2l0aW1hdGUgZHJhZyBpcyB0YWtpbmcgcGxhY2VcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZyA9IGZ1bmN0aW9uIChkeCwgZHksIGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkcmFnJywgZHgsIGR5LCBldik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBdXRvU2Nyb2xsKGV2KTsgLy8gd2lsbCBwb3NzaWJseSBjYXVzZSBzY3JvbGxpbmdcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZERyYWcgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RyYWdFbmQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gRGVsYXlcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnN0YXJ0RGVsYXkgPSBmdW5jdGlvbiAoaW5pdGlhbEV2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5kZWxheSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xyXG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoaW5pdGlhbEV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEZWxheUVuZCA9IGZ1bmN0aW9uIChpbml0aWFsRXYpIHtcclxuICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZyhpbml0aWFsRXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBEaXN0YW5jZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsYXlFbmRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZyhldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIE1vdXNlIC8gVG91Y2hcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIHByZXZlbnQgaW5lcnRpYSBhbmQgdG91Y2htb3ZlLXNjcm9sbGluZyB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCkge1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYpO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBTY3JvbGxpbmcgKHVucmVsYXRlZCB0byBhdXRvLXNjcm9sbClcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIGRyYWcgaXMgYmVpbmcgaW5pdGlhdGVkIGJ5IHRvdWNoLCBidXQgYSBzY3JvbGwgaGFwcGVucyBiZWZvcmVcclxuICAgICAgICAvLyB0aGUgZHJhZy1pbml0aWF0aW5nIGRlbGF5IGlzIG92ZXIsIGNhbmNlbCB0aGUgZHJhZ1xyXG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuc2Nyb2xsQWx3YXlzS2lsbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbihldiwgdHJ1ZSk7IC8vIGlzQ2FuY2VsbGVkPXRydWVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxyXG4gICAgLy8gQXJndW1lbnRzIGJleW9uZCB0aGUgZmlyc3QgYG5hbWVgIGFyZSBmb3J3YXJkZWQgb24uXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1ha2VzIF9tZXRob2RzIGNhbGxhYmxlIGJ5IGV2ZW50IG5hbWUuIFRPRE86IGtpbGwgdGhpc1xyXG4gICAgICAgIGlmICh0aGlzWydfJyArIG5hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ18nICsgbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEF1dG8tc2Nyb2xsXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5pbml0QXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsRWwgPSB0aGlzLnNjcm9sbEVsO1xyXG4gICAgICAgIHRoaXMuaXNBdXRvU2Nyb2xsID1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbCAmJlxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsRWwgJiZcclxuICAgICAgICAgICAgICAgICFzY3JvbGxFbC5pcyh3aW5kb3cpICYmXHJcbiAgICAgICAgICAgICAgICAhc2Nyb2xsRWwuaXMoZG9jdW1lbnQpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xyXG4gICAgICAgICAgICAvLyBkZWJvdW5jZSBtYWtlcyBzdXJlIHJhcGlkIGNhbGxzIGRvbid0IGhhcHBlblxyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHNjcm9sbEVsLCAnc2Nyb2xsJywgdXRpbF8xLmRlYm91bmNlKHRoaXMuaGFuZGxlRGVib3VuY2VkU2Nyb2xsLCAxMDApKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5kZXN0cm95QXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVuZEF1dG9TY3JvbGwoKTsgLy8ga2lsbCBhbnkgYW5pbWF0aW9uIGxvb3BcclxuICAgICAgICAvLyByZW1vdmUgdGhlIHNjcm9sbCBoYW5kbGVyIGlmIHRoZXJlIGlzIGEgc2Nyb2xsRWxcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5zY3JvbGxFbCwgJ3Njcm9sbCcpOyAvLyB3aWxsIHByb2JhYmx5IGdldCByZW1vdmVkIGJ5IHVuYmluZEhhbmRsZXJzIHRvbyA6KFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbmQgc3RvcmVzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2Ygc2Nyb2xsRWxcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxCb3VuZHMgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0KHRoaXMuc2Nyb2xsRWwpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB1c2UgZ2V0Q2xpZW50UmVjdCBpbiBmdXR1cmUuIGJ1dCBwcmV2ZW50cyBhdXRvIHNjcm9sbGluZyB3aGVuIG9uIHRvcCBvZiBzY3JvbGxiYXJzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnZ2luZyBpcyBpbiBwcm9ncmVzcyBhbmQgc2Nyb2xsaW5nIHNob3VsZCBiZSB1cGRhdGVkXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZUF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgc2Vuc2l0aXZpdHkgPSB0aGlzLnNjcm9sbFNlbnNpdGl2aXR5O1xyXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLnNjcm9sbEJvdW5kcztcclxuICAgICAgICB2YXIgdG9wQ2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciBib3R0b21DbG9zZW5lc3M7XHJcbiAgICAgICAgdmFyIGxlZnRDbG9zZW5lc3M7XHJcbiAgICAgICAgdmFyIHJpZ2h0Q2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciB0b3BWZWwgPSAwO1xyXG4gICAgICAgIHZhciBsZWZ0VmVsID0gMDtcclxuICAgICAgICBpZiAoYm91bmRzKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgY2xvc2VuZXNzIHRvIGVkZ2VzLiB2YWxpZCByYW5nZSBpcyBmcm9tIDAuMCAtIDEuMFxyXG4gICAgICAgICAgICB0b3BDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAodXRpbF8xLmdldEV2WShldikgLSBib3VuZHMudG9wKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgYm90dG9tQ2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5ib3R0b20gLSB1dGlsXzEuZ2V0RXZZKGV2KSkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIGxlZnRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAodXRpbF8xLmdldEV2WChldikgLSBib3VuZHMubGVmdCkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIHJpZ2h0Q2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5yaWdodCAtIHV0aWxfMS5nZXRFdlgoZXYpKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHZlcnRpY2FsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5LlxyXG4gICAgICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGNvbXBsZXRlbHkgaW4gYm91bmRzIGZvciB2ZWxvY2l0eSB0byBoYXBwZW4uXHJcbiAgICAgICAgICAgIGlmICh0b3BDbG9zZW5lc3MgPj0gMCAmJiB0b3BDbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgdG9wVmVsID0gdG9wQ2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZCAqIC0xOyAvLyBuZWdhdGl2ZS4gZm9yIHNjcm9sbGluZyB1cFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJvdHRvbUNsb3NlbmVzcyA+PSAwICYmIGJvdHRvbUNsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BWZWwgPSBib3R0b21DbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBob3Jpem9udGFsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q2xvc2VuZXNzID49IDAgJiYgbGVmdENsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0VmVsID0gbGVmdENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQgKiAtMTsgLy8gbmVnYXRpdmUuIGZvciBzY3JvbGxpbmcgbGVmdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0Q2xvc2VuZXNzID49IDAgJiYgcmlnaHRDbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdFZlbCA9IHJpZ2h0Q2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFNjcm9sbFZlbCh0b3BWZWwsIGxlZnRWZWwpO1xyXG4gICAgfTtcclxuICAgIC8vIFNldHMgdGhlIHNwZWVkLW9mLXNjcm9sbGluZyBmb3IgdGhlIHNjcm9sbEVsXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnNldFNjcm9sbFZlbCA9IGZ1bmN0aW9uICh0b3BWZWwsIGxlZnRWZWwpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFRvcFZlbCA9IHRvcFZlbDtcclxuICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSBsZWZ0VmVsO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIG1hc3NhZ2VzIGludG8gcmVhbGlzdGljIHZhbHVlc1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vbi16ZXJvIHZlbG9jaXR5LCBhbmQgYW4gYW5pbWF0aW9uIGxvb3AgaGFzbid0IGFscmVhZHkgc3RhcnRlZCwgdGhlbiBTVEFSVFxyXG4gICAgICAgIGlmICgodGhpcy5zY3JvbGxUb3BWZWwgfHwgdGhpcy5zY3JvbGxMZWZ0VmVsKSAmJiAhdGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHV0aWxfMS5wcm94eSh0aGlzLCAnc2Nyb2xsSW50ZXJ2YWxGdW5jJyksIC8vIHNjb3BlIHRvIGB0aGlzYFxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsTXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBGb3JjZXMgc2Nyb2xsVG9wVmVsIGFuZCBzY3JvbGxMZWZ0VmVsIHRvIGJlIHplcm8gaWYgc2Nyb2xsaW5nIGhhcyBhbHJlYWR5IGdvbmUgYWxsIHRoZSB3YXlcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuY29uc3RyYWluU2Nyb2xsVmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuc2Nyb2xsRWw7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wKCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wKCkgKyBlbFswXS5jbGllbnRIZWlnaHQgPj0gZWxbMF0uc2Nyb2xsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcFZlbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbExlZnQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbExlZnQoKSArIGVsWzBdLmNsaWVudFdpZHRoID49IGVsWzBdLnNjcm9sbFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZHVyaW5nIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnNjcm9sbEludGVydmFsRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLnNjcm9sbEVsO1xyXG4gICAgICAgIHZhciBmcmFjID0gdGhpcy5zY3JvbGxJbnRlcnZhbE1zIC8gMTAwMDsgLy8gY29uc2lkZXJpbmcgYW5pbWF0aW9uIGZyZXF1ZW5jeSwgd2hhdCB0aGUgdmVsIHNob3VsZCBiZSBtdWx0J2QgYnlcclxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHZhbHVlIG9mIHNjcm9sbEVsJ3Mgc2Nyb2xsXHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsKSB7XHJcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcChlbC5zY3JvbGxUb3AoKSArIHRoaXMuc2Nyb2xsVG9wVmVsICogZnJhYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnRWZWwpIHtcclxuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdChlbC5zY3JvbGxMZWZ0KCkgKyB0aGlzLnNjcm9sbExlZnRWZWwgKiBmcmFjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW5TY3JvbGxWZWwoKTsgLy8gc2luY2UgdGhlIHNjcm9sbCB2YWx1ZXMgY2hhbmdlZCwgcmVjb21wdXRlIHRoZSB2ZWxvY2l0aWVzXHJcbiAgICAgICAgLy8gaWYgc2Nyb2xsZWQgYWxsIHRoZSB3YXksIHdoaWNoIGNhdXNlcyB0aGUgdmVscyB0byBiZSB6ZXJvLCBzdG9wIHRoZSBhbmltYXRpb24gbG9vcFxyXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxUb3BWZWwgJiYgIXRoaXMuc2Nyb2xsTGVmdFZlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZEF1dG9TY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gS2lsbHMgYW55IGV4aXN0aW5nIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5lbmRBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbEludGVydmFsSWQpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsSWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXQgY2FsbGVkIHdoZW4gdGhlIHNjcm9sbEVsIGlzIHNjcm9sbGVkIChOT1RFOiB0aGlzIGlzIGRlbGF5ZWQgdmlhIGRlYm91bmNlKVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEZWJvdW5jZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gcmVjb21wdXRlIGFsbCBjb29yZGluYXRlcywgYnV0ICpvbmx5KiBpZiB0aGlzIGlzICpub3QqIHBhcnQgb2Ygb3VyIHNjcm9sbGluZyBhbmltYXRpb25cclxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERyYWdMaXN0ZW5lcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ0xpc3RlbmVyO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKERyYWdMaXN0ZW5lcik7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuLypcclxuQSBzZXQgb2YgcmVuZGVyaW5nIGFuZCBkYXRlLXJlbGF0ZWQgbWV0aG9kcyBmb3IgYSB2aXN1YWwgY29tcG9uZW50IGNvbXByaXNlZCBvZiBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjb2x1bW5zLlxyXG5QcmVyZXF1aXNpdGU6IHRoZSBvYmplY3QgYmVpbmcgbWl4ZWQgaW50byBuZWVkcyB0byBiZSBhICpHcmlkKlxyXG4qL1xyXG52YXIgRGF5VGFibGVNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheVRhYmxlTWl4aW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlUYWJsZU1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIFBvcHVsYXRlcyBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCBmb3IgZGF0ZSBjYWxjdWxhdGlvbiBhbmQgcmVuZGVyaW5nXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS51cGRhdGVEYXlUYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZGF0ZSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGVuZCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIHRydWUpO1xyXG4gICAgICAgIHZhciBkYXlJbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBkYXlJbmRpY2VzID0gW107XHJcbiAgICAgICAgdmFyIGRheURhdGVzID0gW107XHJcbiAgICAgICAgdmFyIGRheXNQZXJSb3c7XHJcbiAgICAgICAgdmFyIGZpcnN0RGF5O1xyXG4gICAgICAgIHZhciByb3dDbnQ7XHJcbiAgICAgICAgd2hpbGUgKGRhdGUuaXNCZWZvcmUoZW5kKSkge1xyXG4gICAgICAgICAgICBpZiAodmlldy5pc0hpZGRlbkRheShkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgZGF5SW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KTsgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXlJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgZGF5SW5kaWNlcy5wdXNoKGRheUluZGV4KTtcclxuICAgICAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF0ZS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRlLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5icmVha09uV2Vla3MpIHtcclxuICAgICAgICAgICAgLy8gY291bnQgY29sdW1ucyB1bnRpbCB0aGUgZGF5LW9mLXdlZWsgcmVwZWF0c1xyXG4gICAgICAgICAgICBmaXJzdERheSA9IGRheURhdGVzWzBdLmRheSgpO1xyXG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF5RGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXlEYXRlc1tkYXlzUGVyUm93XS5kYXkoKSA9PT0gZmlyc3REYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF5RGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByb3dDbnQgPSAxO1xyXG4gICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF5RGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRheURhdGVzID0gZGF5RGF0ZXM7XHJcbiAgICAgICAgdGhpcy5kYXlJbmRpY2VzID0gZGF5SW5kaWNlcztcclxuICAgICAgICB0aGlzLmRheXNQZXJSb3cgPSBkYXlzUGVyUm93O1xyXG4gICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGF5VGFibGVDb2xzKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW5kIGFzc2lnbmVkIHRoZSBjb2xDbnQgcHJvcGVydHkgYW5kIHVwZGF0ZXMgYW55IG9wdGlvbnMgdGhhdCBtYXkgYmUgY29tcHV0ZWQgZnJvbSBpdFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUudXBkYXRlRGF5VGFibGVDb2xzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ250ID0gdGhpcy5jb21wdXRlQ29sQ250KCk7XHJcbiAgICAgICAgdGhpcy5jb2xIZWFkRm9ybWF0ID1cclxuICAgICAgICAgICAgdGhpcy5vcHQoJ2NvbHVtbkhlYWRlckZvcm1hdCcpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdCgnY29sdW1uRm9ybWF0JykgfHwgLy8gZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlQ29sSGVhZEZvcm1hdCgpO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgaG93IG1hbnkgY29sdW1ucyB0aGVyZSBzaG91bGQgYmUgaW4gdGhlIHRhYmxlXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5jb21wdXRlQ29sQ250ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheXNQZXJSb3c7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGFtYmlndW91c2x5LXRpbWVkIG1vbWVudCBmb3IgdGhlIGdpdmVuIGNlbGxcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENlbGxEYXRlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5RGF0ZXNbdGhpcy5nZXRDZWxsRGF5SW5kZXgocm93LCBjb2wpXS5jbG9uZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBkYXRlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gY2VsbFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q2VsbFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3Qgb2YgdGhlIGdyaWQgKDAtYmFzZWQpXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXRDZWxsRGF5SW5kZXggPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4gcm93ICogdGhpcy5kYXlzUGVyUm93ICsgdGhpcy5nZXRDb2xEYXlJbmRleChjb2wpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bW5lciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3QgY2VsbCBpbiAqYW55IGdpdmVuIHJvdypcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENvbERheUluZGV4ID0gZnVuY3Rpb24gKGNvbCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbENudCAtIDEgLSBjb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXHJcbiAgICAvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXHJcbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cclxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cclxuICAgIC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0RGF0ZURheUluZGV4ID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgZGF5SW5kaWNlcyA9IHRoaXMuZGF5SW5kaWNlcztcclxuICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gZGF0ZS5kaWZmKHRoaXMuZGF5RGF0ZXNbMF0sICdkYXlzJyk7XHJcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheUluZGljZXNbMF0gLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXlPZmZzZXQgPj0gZGF5SW5kaWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheUluZGljZXNbZGF5SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kaWNlc1tkYXlPZmZzZXRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBPcHRpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuY29tcHV0ZUNvbEhlYWRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcclxuICAgICAgICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcclxuICAgICAgICBpZiAodGhpcy5yb3dDbnQgPiAxIHx8IHRoaXMuY29sQ250ID4gMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGQnOyAvLyBcIlNhdFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29sQ250ID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2RheU9mTW9udGhGb3JtYXQnKTsgLy8gXCJTYXQgMTIvMTBcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkJzsgLy8gXCJTYXR1cmRheVwiXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFNsaWNpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSB3ZWVrLXJvdyBpdCBpbnRlcnNlY3RzIHdpdGhcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnNsaWNlUmFuZ2VCeVJvdyA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcclxuICAgICAgICB2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHVuem9uZWRSYW5nZSk7IC8vIG1ha2Ugd2hvbGUtZGF5IHJhbmdlLCBjb25zaWRlcmluZyBuZXh0RGF5VGhyZXNob2xkXHJcbiAgICAgICAgdmFyIHJhbmdlRmlyc3QgPSB0aGlzLmdldERhdGVEYXlJbmRleChub3JtYWxSYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxyXG4gICAgICAgIHZhciByYW5nZUxhc3QgPSB0aGlzLmdldERhdGVEYXlJbmRleChub3JtYWxSYW5nZS5lbmQuY2xvbmUoKS5zdWJ0cmFjdCgxLCAnZGF5cycpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgdmFyIHJvd0ZpcnN0O1xyXG4gICAgICAgIHZhciByb3dMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBjdXJyZW50IHJvd1xyXG4gICAgICAgIHZhciBzZWdGaXJzdDtcclxuICAgICAgICB2YXIgc2VnTGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3Igc2VnbWVudFxyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHJvd0ZpcnN0ID0gcm93ICogZGF5c1BlclJvdztcclxuICAgICAgICAgICAgcm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XHJcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXHJcbiAgICAgICAgICAgIHNlZ0ZpcnN0ID0gTWF0aC5tYXgocmFuZ2VGaXJzdCwgcm93Rmlyc3QpO1xyXG4gICAgICAgICAgICBzZWdMYXN0ID0gTWF0aC5taW4ocmFuZ2VMYXN0LCByb3dMYXN0KTtcclxuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxyXG4gICAgICAgICAgICBzZWdMYXN0ID0gTWF0aC5mbG9vcihzZWdMYXN0KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxyXG4gICAgICAgICAgICBpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkge1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ0xhc3QgPT09IHJhbmdlTGFzdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgZGF5LWNlbGwgaXQgaW50ZXJzZWN0cyB3aXRoLlxyXG4gICAgLy8gVE9ETzogbWFrZSBtb3JlIERSWSB3aXRoIHNsaWNlUmFuZ2VCeVJvdyBzb21laG93LlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuc2xpY2VSYW5nZUJ5RGF5ID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBkYXlzUGVyUm93ID0gdGhpcy5kYXlzUGVyUm93O1xyXG4gICAgICAgIHZhciBub3JtYWxSYW5nZSA9IHRoaXMudmlldy5jb21wdXRlRGF5UmFuZ2UodW56b25lZFJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcclxuICAgICAgICB2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XHJcbiAgICAgICAgdmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICB2YXIgcm93Rmlyc3Q7XHJcbiAgICAgICAgdmFyIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZ0ZpcnN0O1xyXG4gICAgICAgIHZhciBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLnJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICByb3dMYXN0ID0gcm93Rmlyc3QgKyBkYXlzUGVyUm93IC0gMTtcclxuICAgICAgICAgICAgZm9yIChpID0gcm93Rmlyc3Q7IGkgPD0gcm93TGFzdDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Qgc2VnbWVudCdzIG9mZnNldCByYW5nZSB3aXRoIHRoZSByb3cnc1xyXG4gICAgICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLm1heChyYW5nZUZpcnN0LCBpKTtcclxuICAgICAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIGkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLmNlaWwoc2VnRmlyc3QpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcclxuICAgICAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLmZsb29yKHNlZ0xhc3QpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Um93RGF5SW5kZXg6IHNlZ0ZpcnN0IC0gcm93Rmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ0ZpcnN0ID09PSByYW5nZUZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogSGVhZGVyIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJvdyAnICsgdGhlbWUuZ2V0Q2xhc3MoJ2hlYWRlclJvdycpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzx0aGVhZD4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkVHJIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC90aGVhZD4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZFRySHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxzSHRtbCgpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwoKSA6ICcnKSArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsc0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGh0bWxzID0gW107XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVySGVhZERhdGVDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiB3aGVuIGludGVybmFsQXBpVmVyc2lvbiwgYWNjZXB0IGFuIG9iamVjdCBmb3IgSFRNTCBhdHRyaWJ1dGVzXHJcbiAgICAvLyAoY29sc3BhbiBzaG91bGQgYmUgbm8gZGlmZmVyZW50KVxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlLCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdC52aWV3O1xyXG4gICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IHQuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAnZmMtZGF5LWhlYWRlcicsXHJcbiAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgaW5uZXJIdG1sO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdC5vcHQoJ2NvbHVtbkhlYWRlckh0bWwnKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSB0Lm9wdCgnY29sdW1uSGVhZGVySHRtbCcpKGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdC5vcHQoJ2NvbHVtbkhlYWRlclRleHQnKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSB1dGlsXzEuaHRtbEVzY2FwZSh0Lm9wdCgnY29sdW1uSGVhZGVyVGV4dCcpKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKGRhdGUuZm9ybWF0KHQuY29sSGVhZEZvcm1hdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBvbmx5IG9uZSByb3cgb2YgZGF5cywgdGhlIGNsYXNzTmFtZXMgb24gdGhlIGhlYWRlciBjYW4gcmVwcmVzZW50IHRoZSBzcGVjaWZpYyBkYXlzIGJlbmVhdGhcclxuICAgICAgICBpZiAodC5yb3dDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuY29uY2F0KFxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICAgICAgLy8gbm9UaGVtZUhpZ2hsaWdodD10cnVlIChkb24ndCBoaWdobGlnaHQgdGhlIGhlYWRlcilcclxuICAgICAgICAgICAgdC5nZXREYXlDbGFzc2VzKGRhdGUsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtJyArIHV0aWxfMS5kYXlJRHNbZGF0ZS5kYXkoKV0pOyAvLyBvbmx5IGFkZCB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoKGlzRGF0ZVZhbGlkICYmIHQucm93Q250KSA9PT0gMSA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoY29sc3BhbiA+IDEgP1xyXG4gICAgICAgICAgICAgICAgJyBjb2xzcGFuPVwiJyArIGNvbHNwYW4gKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChvdGhlckF0dHJzID9cclxuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1ha2UgYSBsaW5rIGlmIHRoZSBoZWFkaW5nIGNvdWxkIHJlcHJlc2VudCBtdWx0aXBsZSBkYXlzLCBvciBpZiB0aGVyZSdzIG9ubHkgb25lIGRheSAoZm9yY2VPZmYpXHJcbiAgICAgICAgICAgICAgICB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoeyBkYXRlOiBkYXRlLCBmb3JjZU9mZjogdC5yb3dDbnQgPiAxIHx8IHQuY29sQ250ID09PSAxIH0sIGlubmVySHRtbCkgOlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IHZhbGlkLCBkaXNwbGF5IHRleHQsIGJ1dCBubyBsaW5rXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwpICtcclxuICAgICAgICAgICAgJzwvdGg+JztcclxuICAgIH07XHJcbiAgICAvKiBCYWNrZ3JvdW5kIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnVHJIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ0NlbGxzSHRtbChyb3cpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykgOiAnJykgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnSW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckludHJvSHRtbCgpOyAvLyBmYWxsIGJhY2sgdG8gZ2VuZXJpY1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBodG1scyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyQmdDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJCZ0NlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUsIG90aGVyQXR0cnMpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gdC5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSB0LmdldERheUNsYXNzZXMoZGF0ZSk7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXknLCB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykpO1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6IC8vIGlmIGRhdGUgaGFzIGEgdGltZSwgd29uJ3QgZm9ybWF0IGl0XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAob3RoZXJBdHRycyA/XHJcbiAgICAgICAgICAgICAgICAnICcgKyBvdGhlckF0dHJzIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+PC90ZD4nO1xyXG4gICAgfTtcclxuICAgIC8qIEdlbmVyaWNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBkZWZhdWx0IEhUTUwgaW50cm8gZm9yIGFueSByb3cuIFVzZXIgY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiBhIGdlbmVyaWMgbWV0aG9kIGZvciBkZWFsaW5nIHdpdGggPHRyPiwgUlRMLCBpbnRyb1xyXG4gICAgLy8gd2hlbiBpbmNyZW1lbnQgaW50ZXJuYWxBcGlWZXJzaW9uXHJcbiAgICAvLyB3cmFwVHIgKHNjaGVkdWxlcilcclxuICAgIC8qIFV0aWxzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQXBwbGllcyB0aGUgZ2VuZXJpYyBcImludHJvXCIgYW5kIFwib3V0cm9cIiBIVE1MIHRvIHRoZSBnaXZlbiBjZWxscy5cclxuICAgIC8vIEludHJvIG1lYW5zIHRoZSBsZWZ0bW9zdCBjZWxsIHdoZW4gdGhlIGNhbGVuZGFyIGlzIExUUiBhbmQgdGhlIHJpZ2h0bW9zdCBjZWxsIHdoZW4gUlRMLiBWaWNlLXZlcnNhIGZvciBvdXRyby5cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmJvb2tlbmRDZWxscyA9IGZ1bmN0aW9uICh0ckVsKSB7XHJcbiAgICAgICAgdmFyIGludHJvSHRtbCA9IHRoaXMucmVuZGVySW50cm9IdG1sKCk7XHJcbiAgICAgICAgaWYgKGludHJvSHRtbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgdHJFbC5hcHBlbmQoaW50cm9IdG1sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyRWwucHJlcGVuZChpbnRyb0h0bWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlUYWJsZU1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlUYWJsZU1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wbGVtZW50czpcclxuICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgIC0gZXZlbnRGb290cHJpbnRzVG9TZWdzXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gQnVzaW5lc3NIb3VyUmVuZGVyZXIoY29tcG9uZW50LCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmZpbGxSZW5kZXJlciA9IGZpbGxSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBjb21wb25lbnQuX2dldERhdGVQcm9maWxlKCkuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSBidXNpbmVzc0hvdXJHZW5lcmF0b3IuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAoY29tcG9uZW50Lmhhc0FsbERheUJ1c2luZXNzSG91cnMsIHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IGV2ZW50SW5zdGFuY2VHcm91cCA/XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyh1bnpvbmVkUmFuZ2UpKSA6XHJcbiAgICAgICAgICAgIFtdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2VncyhzZWdzKTtcclxuICAgICAgICB0aGlzLnNlZ3MgPSBzZWdzO1xyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnYnVzaW5lc3NIb3VycycsIHNlZ3MsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmYy1ub25idXNpbmVzcycsICdmYy1iZ2V2ZW50J107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdidXNpbmVzc0hvdXJzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VncyB8fCBbXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnVzaW5lc3NIb3VyUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91clJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWxsUmVuZGVyZXIoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy5maWxsU2VnVGFnID0gJ2Rpdic7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5lbHNCeUZpbGwgPSB7fTtcclxuICAgIH1cclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRm9vdHByaW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBvbmVudEZvb3RwcmludCwgcHJvcHMpIHtcclxuICAgICAgICB0aGlzLnJlbmRlclNlZ3ModHlwZSwgdGhpcy5jb21wb25lbnQuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKGNvbXBvbmVudEZvb3RwcmludCksIHByb3BzKTtcclxuICAgIH07XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAodHlwZSwgc2VncywgcHJvcHMpIHtcclxuICAgICAgICB2YXIgZWxzO1xyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmJ1aWxkU2VnRWxzKHR5cGUsIHNlZ3MsIHByb3BzKTsgLy8gYXNzaWduZXMgYC5lbGAgdG8gZWFjaCBzZWcuIHJldHVybnMgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHNlZ3NcclxuICAgICAgICBlbHMgPSB0aGlzLmF0dGFjaFNlZ0Vscyh0eXBlLCBzZWdzKTtcclxuICAgICAgICBpZiAoZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RWxzKHR5cGUsIGVscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHNwZWNpZmljIHR5cGUgb2YgZmlsbCB0aGF0IGlzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MsIHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmJ1aWxkU2VnSHRtbCh0eXBlLCBzZWdzW2ldLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC5cclxuICAgICAgICAgICAgJChodG1sKS5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIG1ldGhvZHMgcGVyLXR5cGVcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5maWx0ZXJFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gcHJvcHMuZmlsdGVyRWwoc2VnLCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbCA9ICQoZWwpOyAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIHRvIHJldHVybiByYXcgRE9NIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGVsZW1lbnQgdHlwZT8gKHdvdWxkIGJlIGJhZCBpZiBhIG5vbi1URCB3ZXJlIGluc2VydGVkIGludG8gYSB0YWJsZSBmb3IgZXhhbXBsZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuaXMoX3RoaXMuZmlsbFNlZ1RhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkU2VncztcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIEhUTUwgbmVlZGVkIGZvciBvbmUgZmlsbCBzZWdtZW50LiBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5idWlsZFNlZ0h0bWwgPSBmdW5jdGlvbiAodHlwZSwgc2VnLCBwcm9wcykge1xyXG4gICAgICAgIC8vIGN1c3RvbSBob29rcyBwZXItdHlwZVxyXG4gICAgICAgIHZhciBjbGFzc2VzID0gcHJvcHMuZ2V0Q2xhc3NlcyA/IHByb3BzLmdldENsYXNzZXMoc2VnKSA6IFtdO1xyXG4gICAgICAgIHZhciBjc3MgPSB1dGlsXzEuY3NzVG9TdHIocHJvcHMuZ2V0Q3NzID8gcHJvcHMuZ2V0Q3NzKHNlZykgOiB7fSk7XHJcbiAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuZmlsbFNlZ1RhZyArXHJcbiAgICAgICAgICAgIChjbGFzc2VzLmxlbmd0aCA/ICcgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInIDogJycpICtcclxuICAgICAgICAgICAgKGNzcyA/ICcgc3R5bGU9XCInICsgY3NzICsgJ1wiJyA6ICcnKSArXHJcbiAgICAgICAgICAgICcgLz4nO1xyXG4gICAgfTtcclxuICAgIC8vIFNob3VsZCByZXR1cm4gd3JhcHBpbmcgRE9NIHN0cnVjdHVyZVxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlcG9ydEVscyA9IGZ1bmN0aW9uICh0eXBlLCBub2Rlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmVsc0J5RmlsbFt0eXBlXSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsc0J5RmlsbFt0eXBlXSA9IHRoaXMuZWxzQnlGaWxsW3R5cGVdLmFkZChub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVsc0J5RmlsbFt0eXBlXSA9ICQobm9kZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRmlsbFJlbmRlcmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGaWxsUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV2ZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgSGVscGVyUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIZWxwZXJSZW5kZXJlcihjb21wb25lbnQsIGV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSBjb21wb25lbnQuX2dldFZpZXcoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIgPSBldmVudFJlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudEZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhbXHJcbiAgICAgICAgICAgIHRoaXMuZmFicmljYXRlRXZlbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KVxyXG4gICAgICAgIF0pO1xyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudERyYWdnaW5nRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCAnZmMtZHJhZ2dpbmcnLCBpc1RvdWNoID8gbnVsbCA6IHRoaXMudmlldy5vcHQoJ2RyYWdPcGFjaXR5JykpO1xyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCAnZmMtcmVzaXppbmcnKTtcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCBleHRyYUNsYXNzTmFtZXMsIG9wYWNpdHkpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gJ2ZjLWhlbHBlciAnICsgKGV4dHJhQ2xhc3NOYW1lcyB8fCAnJyk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gYXNzaWducyBlYWNoIHNlZydzIGVsIGFuZCByZXR1cm5zIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkXHJcbiAgICAgICAgc2VncyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJGZ1NlZ0VscyhzZWdzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzW2ldLmVsLmFkZENsYXNzKGNsYXNzTmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3BhY2l0eSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzW2ldLmVsLmNzcygnb3BhY2l0eScsIG9wYWNpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVscGVyRWxzID0gdGhpcy5yZW5kZXJTZWdzKHNlZ3MsIHNvdXJjZVNlZyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE11c3QgcmV0dXJuIGFsbCBtb2NrIGV2ZW50IGVsZW1lbnRzXHJcbiAgICAqL1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWxwZXJFbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJFbHMucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLmZhYnJpY2F0ZUV2ZW50Rm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnREYXRlUHJvZmlsZSA9IGNhbGVuZGFyLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB2YXIgZHVtbXlFdmVudCA9IG5ldyBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQobmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdChjYWxlbmRhcikpO1xyXG4gICAgICAgIHZhciBkdW1teUluc3RhbmNlO1xyXG4gICAgICAgIGR1bW15RXZlbnQuZGF0ZVByb2ZpbGUgPSBldmVudERhdGVQcm9maWxlO1xyXG4gICAgICAgIGR1bW15SW5zdGFuY2UgPSBkdW1teUV2ZW50LmJ1aWxkSW5zdGFuY2UoKTtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdChjb21wb25lbnRGb290cHJpbnQsIGR1bW15RXZlbnQsIGR1bW15SW5zdGFuY2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBIZWxwZXJSZW5kZXJlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSGVscGVyUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBFdmVudFBvaW50aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXZlbnRQb2ludGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UG9pbnRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBtdXN0IGltcGxlbWVudDpcclxuICAgICAgLSBwdWJsaWNseVRyaWdnZXJcclxuICAgICovXHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWVudGVyJywgdGhpcy5oYW5kbGVNb3VzZW92ZXIuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlbGVhdmUnLCB0aGlzLmhhbmRsZU1vdXNlb3V0LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudENsaWNrJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksIGV2LCB0aGlzLnZpZXddXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMgZm9yIHdoZW4gYW4gZXZlbnQgZWxlbWVudCBpcyBtb3VzZWQgb3ZlclxyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VvdmVyID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAoIUdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgIXRoaXMubW91c2VkT3ZlclNlZykge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlZE92ZXJTZWcgPSBzZWc7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gRXZlbnRTZWxlY3RpbmcncyByZXNwb25zaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3ZlcicsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IFtzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksIGV2LCB0aGlzLnZpZXddXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdXQuXHJcbiAgICAvLyBDYW4gYmUgZ2l2ZW4gbm8gYXJndW1lbnRzLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgbW91c2VvdXQgdGhlIHNlZ21lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VzZWQgb3Zlci5cclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZU1vdXNlb3V0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VkT3ZlclNlZyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gRXZlbnRTZWxlY3RpbmcncyByZXNwb25zaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3V0Jywge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgICAgICBldiB8fCB7fSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VvdXQodGhpcy5tb3VzZWRPdmVyU2VnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UG9pbnRpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UG9pbnRpbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgRGF0ZUNsaWNraW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NSk7XHJcbnZhciBEYXRlU2VsZWN0aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNSk7XHJcbnZhciBFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxudmFyIEV2ZW50RHJhZ2dpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI0KTtcclxudmFyIEV2ZW50UmVzaXppbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIzKTtcclxudmFyIEV4dGVybmFsRHJvcHBpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIyKTtcclxudmFyIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGFuZGFyZEludGVyYWN0aW9uc01peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbjtcclxufShNaXhpbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbjtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZGF0ZUNsaWNraW5nQ2xhc3MgPSBEYXRlQ2xpY2tpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5kYXRlU2VsZWN0aW5nQ2xhc3MgPSBEYXRlU2VsZWN0aW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXZlbnRQb2ludGluZ0NsYXNzID0gRXZlbnRQb2ludGluZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV2ZW50RHJhZ2dpbmdDbGFzcyA9IEV2ZW50RHJhZ2dpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5ldmVudFJlc2l6aW5nQ2xhc3MgPSBFdmVudFJlc2l6aW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXh0ZXJuYWxEcm9wcGluZ0NsYXNzID0gRXh0ZXJuYWxEcm9wcGluZ18xLmRlZmF1bHQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbnZhciBQb3BvdmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0OSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG52YXIgQnVzaW5lc3NIb3VyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG52YXIgRGF5VGFibGVNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcbnZhciBEYXlHcmlkRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTApO1xyXG52YXIgRGF5R3JpZEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MSk7XHJcbnZhciBEYXlHcmlkRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1Mik7XHJcbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBhIGdyaWQgb2Ygd2hvbGUtZGF5cyB0aGF0IHJ1bnMgaG9yaXpvbnRhbGx5LiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgcm93cywgb25lIHBlciB3ZWVrLlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIERheUdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF5R3JpZCh2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7IC8vIGRpc3BsYXkgd2VlayBudW1iZXJzIGluIGRheSBjZWxsP1xyXG4gICAgICAgIF90aGlzLmJvdHRvbUNvb3JkUGFkZGluZyA9IDA7IC8vIGhhY2sgZm9yIGV4dGVuZGluZyB0aGUgaGl0IGFyZWEgZm9yIHRoZSBsYXN0IHJvdyBvZiB0aGUgY29vcmRpbmF0ZSBncmlkXHJcbiAgICAgICAgLy8gaXNSaWdpZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGluZGl2aWR1YWwgcm93cyBzaG91bGQgaWdub3JlIHRoZSBjb250ZW50cyBhbmQgYmUgYSBjb25zdGFudCBoZWlnaHQuXHJcbiAgICAgICAgLy8gUmVsaWVzIG9uIHRoZSB2aWV3J3MgY29sQ250IGFuZCByb3dDbnQuIEluIHRoZSBmdXR1cmUsIHRoaXMgY29tcG9uZW50IHNob3VsZCBwcm9iYWJseSBiZSBzZWxmLXN1ZmZpY2llbnQuXHJcbiAgICAgICAgX3RoaXMuaXNSaWdpZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmhhc0FsbERheUJ1c2luZXNzSG91cnMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIFNsaWNlcyB1cCB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcclxuICAgIERheUdyaWQucHJvdG90eXBlLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5Um93KGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5sZWZ0Q29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZy5sYXN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzZWcucmlnaHRDb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2VnLmZpcnN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWcubGVmdENvbCA9IHNlZy5maXJzdFJvd0RheUluZGV4O1xyXG4gICAgICAgICAgICAgICAgc2VnLnJpZ2h0Q29sID0gc2VnLmxhc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGF5VGFibGUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckdyaWQoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU2VnUG9wb3ZlcigpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgdGhlIHJvd3MgYW5kIGNvbHVtbnMgaW50byB0aGUgY29tcG9uZW50J3MgYHRoaXMuZWxgLCB3aGljaCBzaG91bGQgYWxyZWFkeSBiZSBhc3NpZ25lZC5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckdyaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHJvd0NudCA9IHRoaXMucm93Q250O1xyXG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICBpZiAodGhpcy5oZWFkQ29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkQ29udGFpbmVyRWwuaHRtbCh0aGlzLnJlbmRlckhlYWRIdG1sKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgaHRtbCArPSB0aGlzLnJlbmRlckRheVJvd0h0bWwocm93LCB0aGlzLmlzUmlnaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmh0bWwoaHRtbCk7XHJcbiAgICAgICAgdGhpcy5yb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3cnKTtcclxuICAgICAgICB0aGlzLmNlbGxFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1kYXksIC5mYy1kaXNhYmxlZC1kYXknKTtcclxuICAgICAgICB0aGlzLnJvd0Nvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMucm93RWxzLFxyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLmNlbGxFbHMuc2xpY2UoMCwgdGhpcy5jb2xDbnQpLFxyXG4gICAgICAgICAgICBpc0hvcml6b250YWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0cmlnZ2VyIGRheVJlbmRlciB3aXRoIGVhY2ggY2VsbCdzIGVsZW1lbnRcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF5UmVuZGVyJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSByb3csIHdoaWNoIGlzIGEgZGl2IHRoYXQgd3JhcHMgYSB0YWJsZS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRGF5Um93SHRtbCA9IGZ1bmN0aW9uIChyb3csIGlzUmlnaWQpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2ZjLXJvdycsICdmYy13ZWVrJywgdGhlbWUuZ2V0Q2xhc3MoJ2RheVJvdycpXTtcclxuICAgICAgICBpZiAoaXNSaWdpZCkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXJpZ2lkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJnXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJnVHJIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZT4nICtcclxuICAgICAgICAgICAgKHRoaXMuZ2V0SXNOdW1iZXJzVmlzaWJsZSgpID9cclxuICAgICAgICAgICAgICAgICc8dGhlYWQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOdW1iZXJUckh0bWwocm93KSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JztcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldElzRGF5TnVtYmVyc1Zpc2libGUoKSB8fCB0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGU7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3dDbnQgPiAxO1xyXG4gICAgfTtcclxuICAgIC8qIEdyaWQgTnVtYmVyIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlclRySHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93KSkgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck51bWJlckNlbGxzSHRtbChyb3cpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpIDogJycpICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBodG1scyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyTnVtYmVyQ2VsbEh0bWwoZGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHRtbHMuam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgPHRkPnMgb2YgdGhlIFwibnVtYmVyXCIgcm93IGluIHRoZSBEYXlHcmlkJ3MgY29udGVudCBza2VsZXRvbi5cclxuICAgIC8vIFRoZSBudW1iZXIgcm93IHdpbGwgb25seSBleGlzdCBpZiBlaXRoZXIgZGF5IG51bWJlcnMgb3Igd2VlayBudW1iZXJzIGFyZSB0dXJuZWQgb24uXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgaXNEYXRlVmFsaWQgPSB0aGlzLmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc0RhdGUoZGF0ZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cclxuICAgICAgICB2YXIgaXNEYXlOdW1iZXJWaXNpYmxlID0gdGhpcy5nZXRJc0RheU51bWJlcnNWaXNpYmxlKCkgJiYgaXNEYXRlVmFsaWQ7XHJcbiAgICAgICAgdmFyIGNsYXNzZXM7XHJcbiAgICAgICAgdmFyIHdlZWtDYWxjRmlyc3REb1c7XHJcbiAgICAgICAgaWYgKCFpc0RheU51bWJlclZpc2libGUgJiYgIXRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBubyBudW1iZXJzIGluIGRheSBjZWxsICh3ZWVrIG51bWJlciBtdXN0IGJlIGFsb25nIHRoZSBzaWRlKVxyXG4gICAgICAgICAgICByZXR1cm4gJzx0ZC8+JzsgLy8gIHdpbGwgY3JlYXRlIGFuIGVtcHR5IHNwYWNlIGFib3ZlIGV2ZW50cyA6KFxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzc2VzID0gdGhpcy5nZXREYXlDbGFzc2VzKGRhdGUpO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LXRvcCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gVG8gZGV0ZXJtaW5lIHRoZSBkYXkgb2Ygd2VlayBudW1iZXIgY2hhbmdlIHVuZGVyIElTTywgd2UgY2Fubm90XHJcbiAgICAgICAgICAgIC8vIHJlbHkgb24gbW9tZW50LmpzIG1ldGhvZHMgc3VjaCBhcyBmaXJzdERheU9mV2VlaygpIG9yIHdlZWtkYXkoKSxcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGV5IHJlbHkgb24gdGhlIGxvY2FsZSdzIGRvdyAocG9zc2libHkgb3ZlcnJpZGRlbiBieVxyXG4gICAgICAgICAgICAvLyBvdXIgZmlyc3REYXkgb3B0aW9uKSwgd2hpY2ggbWF5IG5vdCBiZSBNb25kYXkuIFdlIGNhbm5vdCBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gZG93LCBiZWNhdXNlIHRoYXQgd291bGQgYWZmZWN0IHRoZSBjYWxlbmRhciBzdGFydCBkYXkgYXMgd2VsbC5cclxuICAgICAgICAgICAgaWYgKGRhdGUuX2xvY2FsZS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgd2Vla0NhbGNGaXJzdERvVyA9IDE7IC8vIE1vbmRheSBieSBJU08gODYwMSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrQ2FsY0ZpcnN0RG9XID0gZGF0ZS5fbG9jYWxlLmZpcnN0RGF5T2ZXZWVrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPic7XHJcbiAgICAgICAgaWYgKHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSAmJiAoZGF0ZS5kYXkoKSA9PT0gd2Vla0NhbGNGaXJzdERvVykpIHtcclxuICAgICAgICAgICAgaHRtbCArPSB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoeyBkYXRlOiBkYXRlLCB0eXBlOiAnd2VlaycgfSwgeyAnY2xhc3MnOiAnZmMtd2Vlay1udW1iZXInIH0sIGRhdGUuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEYXlOdW1iZXJWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKGRhdGUsIHsgJ2NsYXNzJzogJ2ZjLWRheS1udW1iZXInIH0sIGRhdGUuZm9ybWF0KCdEJykgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sICs9ICc8L3RkPic7XHJcbiAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9O1xyXG4gICAgLyogSGl0IFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5ib3R0b21zW3RoaXMucm93Q250IC0gMV0gKz0gdGhpcy5ib3R0b21Db29yZFBhZGRpbmc7IC8vIGhhY2tcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZWxlYXNlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJvd0Nvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMucm93Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbCA9IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRIb3Jpem9udGFsSW5kZXgobGVmdE9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbGxIaXQocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldENlbGxSYW5nZShoaXQucm93LCBoaXQuY29sKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCksIHRydWUgLy8gYWxsLWRheT9cclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxFbChoaXQucm93LCBoaXQuY29sKTtcclxuICAgIH07XHJcbiAgICAvKiBDZWxsIFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEZZSTogdGhlIGZpcnN0IGNvbHVtbiBpcyB0aGUgbGVmdG1vc3QgY29sdW1uLCByZWdhcmRsZXNzIG9mIGRhdGVcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxIaXQgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgY29sOiBjb2wsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5jb2xDb29yZENhY2hlLmdldExlZnRPZmZzZXQoY29sKSxcclxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRSaWdodE9mZnNldChjb2wpLFxyXG4gICAgICAgICAgICB0b3A6IHRoaXMucm93Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQocm93KSxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0Qm90dG9tT2Zmc2V0KHJvdylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxFbCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxFbHMuZXEocm93ICogdGhpcy5jb2xDbnQgKyBjb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFVucmVuZGVycyBhbGwgZXZlbnRzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIHJlbW92ZXMgdGhlIFwibW9yZS4uXCIgZXZlbnRzIHBvcG92ZXJcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0cmlldmVzIGFsbCByZW5kZXJlZCBzZWdtZW50IG9iamVjdHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRPd25FdmVudFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBzZWdtZW50cyBmcm9tIHRoZSBcIm1vcmUuLi5cIiBwb3BvdmVyXHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0T3duRXZlbnRTZWdzLmNhbGwodGhpcykuY29uY2F0KHRoaXMucG9wb3ZlclNlZ3MgfHwgW10pO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbCBlbGVtZW50IGJlaW5nIGRyYWdnZWQuXHJcbiAgICAvLyBgZXZlbnRMb2NhdGlvbmAgaGFzIHpvbmVkIHN0YXJ0IGFuZCBlbmQgKG9wdGlvbmFsKVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbmRlciBkcmFncyBmcm9tIE9USEVSIGNvbXBvbmVudHMgYXMgaGVscGVyc1xyXG4gICAgICAgIGlmIChldmVudEZvb3RwcmludHMubGVuZ3RoICYmIHNlZyAmJiBzZWcuY29tcG9uZW50ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIGhlbHBlcnMgcmVuZGVyZWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIGhvdmVyaW5nIGV2ZW50XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnRSZXNpemluZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBNb3JlKyBMaW5rIFBvcG92ZXJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW1vdmVTZWdQb3BvdmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlZ1BvcG92ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWdQb3BvdmVyLmhpZGUoKTsgLy8gaW4gaGFuZGxlciwgd2lsbCBjYWxsIHNlZ1BvcG92ZXIncyByZW1vdmVFbGVtZW50XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIExpbWl0cyB0aGUgbnVtYmVyIG9mIFwibGV2ZWxzXCIgKHZlcnRpY2FsbHkgc3RhY2tpbmcgbGF5ZXJzIG9mIGV2ZW50cykgZm9yIGVhY2ggcm93IG9mIHRoZSBncmlkLlxyXG4gICAgLy8gYGxldmVsTGltaXRgIGNhbiBiZSBmYWxzZSAoZG9uJ3QgbGltaXQpLCBhIG51bWJlciwgb3IgdHJ1ZSAoc2hvdWxkIGJlIGNvbXB1dGVkKS5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmxpbWl0Um93cyA9IGZ1bmN0aW9uIChsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0cyB8fCBbXTtcclxuICAgICAgICB2YXIgcm93OyAvLyByb3cgI1xyXG4gICAgICAgIHZhciByb3dMZXZlbExpbWl0O1xyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93U3RydWN0cy5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5saW1pdFJvdyhyb3cpO1xyXG4gICAgICAgICAgICBpZiAoIWxldmVsTGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGV2ZWxMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSBsZXZlbExpbWl0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IHRoaXMuY29tcHV0ZVJvd0xldmVsTGltaXQocm93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocm93TGV2ZWxMaW1pdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRSb3cocm93LCByb3dMZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIGxldmVscyBhIHJvdyB3aWxsIGFjY29tb2RhdGUgd2l0aG91dCBnb2luZyBvdXRzaWRlIGl0cyBib3VuZHMuXHJcbiAgICAvLyBBc3N1bWVzIHRoZSByb3cgaXMgXCJyaWdpZFwiIChtYWludGFpbnMgYSBjb25zdGFudCBoZWlnaHQgcmVnYXJkbGVzcyBvZiB3aGF0IGlzIGluc2lkZSkuXHJcbiAgICAvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmNvbXB1dGVSb3dMZXZlbExpbWl0ID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciByb3dFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHRoZSBjb250YWluaW5nIFwiZmFrZVwiIHJvdyBkaXZcclxuICAgICAgICB2YXIgcm93SGVpZ2h0ID0gcm93RWwuaGVpZ2h0KCk7IC8vIFRPRE86IGNhY2hlIHNvbWVob3c/XHJcbiAgICAgICAgdmFyIHRyRWxzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XS50Ym9keUVsLmNoaWxkcmVuKCk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRyRWw7XHJcbiAgICAgICAgdmFyIHRySGVpZ2h0O1xyXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJJbm5lckhlaWdodHMoaSwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgIHRySGVpZ2h0ID0gTWF0aC5tYXgodHJIZWlnaHQsICQoY2hpbGROb2RlKS5vdXRlckhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV2ZWFsIG9uZSBsZXZlbCA8dHI+IGF0IGEgdGltZSBhbmQgc3RvcCB3aGVuIHdlIGZpbmQgb25lIG91dCBvZiBib3VuZHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJFbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJFbCA9IHRyRWxzLmVxKGkpLnJlbW92ZUNsYXNzKCdmYy1saW1pdGVkJyk7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHN0YXRlIChyZXZlYWwpXHJcbiAgICAgICAgICAgIC8vIHdpdGggcm93c3BhbnM+MSBhbmQgSUU4LCB0ckVsLm91dGVySGVpZ2h0KCkgd291bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIGxhcmdlc3QgY2VsbCxcclxuICAgICAgICAgICAgLy8gc28gaW5zdGVhZCwgZmluZCB0aGUgdGFsbGVzdCBpbm5lciBjb250ZW50IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIHRySGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdHJFbC5maW5kKCc+IHRkID4gOmZpcnN0LWNoaWxkJykuZWFjaChpdGVySW5uZXJIZWlnaHRzKTtcclxuICAgICAgICAgICAgaWYgKHRyRWwucG9zaXRpb24oKS50b3AgKyB0ckhlaWdodCA+IHJvd0hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaG91bGQgbm90IGxpbWl0IGF0IGFsbFxyXG4gICAgfTtcclxuICAgIC8vIExpbWl0cyB0aGUgZ2l2ZW4gZ3JpZCByb3cgdG8gdGhlIG1heGltdW0gbnVtYmVyIG9mIGxldmVscyBhbmQgaW5qZWN0cyBcIm1vcmVcIiBsaW5rcyBpZiBuZWNlc3NhcnkuXHJcbiAgICAvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cclxuICAgIC8vIGBsZXZlbExpbWl0YCBpcyBhIG51bWJlciBmb3IgdGhlIG1heGltdW0gKGluY2x1c2l2ZSkgbnVtYmVyIG9mIGxldmVscyBhbGxvd2VkLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3cgPSBmdW5jdGlvbiAocm93LCBsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcm93U3RydWN0ID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XTtcclxuICAgICAgICB2YXIgbW9yZU5vZGVzID0gW107IC8vIGFycmF5IG9mIFwibW9yZVwiIDxhPiBsaW5rcyBhbmQgPHRkPiBET00gbm9kZXNcclxuICAgICAgICB2YXIgY29sID0gMDsgLy8gY29sICMsIGxlZnQtdG8tcmlnaHQgKG5vdCBjaHJvbm9sb2dpY2FsbHkpXHJcbiAgICAgICAgdmFyIGxldmVsU2VnczsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbCwgb3JkZXJlZCBsZWZ0LXRvLXJpZ2h0XHJcbiAgICAgICAgdmFyIGNlbGxNYXRyaXg7IC8vIGEgbWF0cml4IChieSBsZXZlbCwgdGhlbiBjb2x1bW4pIG9mIGFsbCA8dGQ+IGpRdWVyeSBlbGVtZW50cyBpbiB0aGUgcm93XHJcbiAgICAgICAgdmFyIGxpbWl0ZWROb2RlczsgLy8gYXJyYXkgb2YgdGVtcG9yYXJpbHkgaGlkZGVuIGxldmVsIDx0cj4gYW5kIHNlZ21lbnQgPHRkPiBET00gbm9kZXNcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBzZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBiZWxvdyBgc2VnYCBpbiB0aGUgY3VycmVudCBgY29sYFxyXG4gICAgICAgIHZhciB0b3RhbFNlZ3NCZWxvdzsgLy8gdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGJlbG93IGBzZWdgIGluIGFueSBvZiB0aGUgY29sdW1ucyBgc2VnYCBvY2N1cGllc1xyXG4gICAgICAgIHZhciBjb2xTZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgYXJyYXlzLCBiZWxvdyBzZWcsIG9uZSBmb3IgZWFjaCBjb2x1bW4gKG9mZnNldCBmcm9tIHNlZ3MncyBmaXJzdCBjb2x1bW4pXHJcbiAgICAgICAgdmFyIHRkO1xyXG4gICAgICAgIHZhciByb3dzcGFuO1xyXG4gICAgICAgIHZhciBzZWdNb3JlTm9kZXM7IC8vIGFycmF5IG9mIFwibW9yZVwiIDx0ZD4gY2VsbHMgdGhhdCB3aWxsIHN0YW5kLWluIGZvciB0aGUgY3VycmVudCBzZWcncyBjZWxsXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgdmFyIG1vcmVUZDtcclxuICAgICAgICB2YXIgbW9yZVdyYXA7XHJcbiAgICAgICAgdmFyIG1vcmVMaW5rO1xyXG4gICAgICAgIC8vIEl0ZXJhdGVzIHRocm91Z2ggZW1wdHkgbGV2ZWwgY2VsbHMgYW5kIHBsYWNlcyBcIm1vcmVcIiBsaW5rcyBpbnNpZGUgaWYgbmVlZCBiZVxyXG4gICAgICAgIHZhciBlbXB0eUNlbGxzVW50aWwgPSBmdW5jdGlvbiAoZW5kQ29sKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NCZWxvdyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdzQmVsb3cubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gX3RoaXMucmVuZGVyTW9yZUxpbmsocm93LCBjb2wsIHNlZ3NCZWxvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIHRkLmFwcGVuZChtb3JlV3JhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVdyYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsZXZlbExpbWl0ICYmIGxldmVsTGltaXQgPCByb3dTdHJ1Y3Quc2VnTGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXZlbFNlZ3MgPSByb3dTdHJ1Y3Quc2VnTGV2ZWxzW2xldmVsTGltaXQgLSAxXTtcclxuICAgICAgICAgICAgY2VsbE1hdHJpeCA9IHJvd1N0cnVjdC5jZWxsTWF0cml4O1xyXG4gICAgICAgICAgICBsaW1pdGVkTm9kZXMgPSByb3dTdHJ1Y3QudGJvZHlFbC5jaGlsZHJlbigpLnNsaWNlKGxldmVsTGltaXQpIC8vIGdldCBsZXZlbCA8dHI+IGVsZW1lbnRzIHBhc3QgdGhlIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5nZXQoKTsgLy8gaGlkZSBlbGVtZW50cyBhbmQgZ2V0IGEgc2ltcGxlIERPTS1ub2RlcyBhcnJheVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRlIHRob3VnaCBzZWdtZW50cyBpbiB0aGUgbGFzdCBhbGxvd2FibGUgbGV2ZWxcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VnID0gbGV2ZWxTZWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTsgLy8gcHJvY2VzcyBlbXB0eSBjZWxscyBiZWZvcmUgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSAqYWxsKiBzZWdtZW50cyBiZWxvdyBgc2VnYCB0aGF0IG9jY3VweSB0aGUgc2FtZSBjb2x1bW5zXHJcbiAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRvdGFsU2Vnc0JlbG93ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb2wgPD0gc2VnLnJpZ2h0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCwgbGV2ZWxMaW1pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sU2Vnc0JlbG93LnB1c2goc2Vnc0JlbG93KTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbFNlZ3NCZWxvdyArPSBzZWdzQmVsb3cubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsU2Vnc0JlbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtzZWcubGVmdENvbF07IC8vIHRoZSBzZWdtZW50J3MgcGFyZW50IGNlbGxcclxuICAgICAgICAgICAgICAgICAgICByb3dzcGFuID0gdGQuYXR0cigncm93c3BhbicpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnTW9yZU5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBhIHJlcGxhY2VtZW50IDx0ZD4gZm9yIGVhY2ggY29sdW1uIHRoZSBzZWdtZW50IG9jY3VwaWVzLiB3aWxsIGJlIG9uZSBmb3IgZWFjaCBjb2xzcGFuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbFNlZ3NCZWxvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQgPSAkKCc8dGQgY2xhc3M9XCJmYy1tb3JlLWNlbGxcIi8+JykuYXR0cigncm93c3BhbicsIHJvd3NwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSBjb2xTZWdzQmVsb3dbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIHNlZy5sZWZ0Q29sICsgaiwgW3NlZ10uY29uY2F0KHNlZ3NCZWxvdykgLy8gY291bnQgc2VnIGFzIGhpZGRlbiB0b29cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQuYXBwZW5kKG1vcmVXcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5hZnRlcigkKHNlZ01vcmVOb2RlcykpOyAvLyBoaWRlIG9yaWdpbmFsIDx0ZD4gYW5kIGluamVjdCByZXBsYWNlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBsaW1pdGVkTm9kZXMucHVzaCh0ZFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHRoaXMuY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgbGV2ZWxcclxuICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSAkKG1vcmVOb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSAkKGxpbWl0ZWROb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUmV2ZWFscyBhbGwgbGV2ZWxzIGFuZCByZW1vdmVzIGFsbCBcIm1vcmVcIi1yZWxhdGVkIGVsZW1lbnRzIGZvciBhIGdyaWQncyByb3cuXHJcbiAgICAvLyBgcm93YCBpcyBhIHJvdyBudW1iZXIuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bmxpbWl0Um93ID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3QgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddO1xyXG4gICAgICAgIGlmIChyb3dTdHJ1Y3QubW9yZUVscykge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm93U3RydWN0LmxpbWl0ZWRFbHMpIHtcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTtcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGFuIDxhPiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBoaWRkZW4gZXZlbnQgZWxlbWVudCBmb3IgYSBjZWxsLlxyXG4gICAgLy8gUmVzcG9uc2libGUgZm9yIGF0dGFjaGluZyBjbGljayBoYW5kbGVyIGFzIHdlbGwuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJNb3JlTGluayA9IGZ1bmN0aW9uIChyb3csIGNvbCwgaGlkZGVuU2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgcmV0dXJuICQoJzxhIGNsYXNzPVwiZmMtbW9yZVwiLz4nKVxyXG4gICAgICAgICAgICAudGV4dCh0aGlzLmdldE1vcmVMaW5rVGV4dChoaWRkZW5TZWdzLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGNsaWNrT3B0aW9uID0gX3RoaXMub3B0KCdldmVudExpbWl0Q2xpY2snKTtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIHZhciBtb3JlRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgZGF5RWwgPSBfdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB2YXIgYWxsU2VncyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sKTtcclxuICAgICAgICAgICAgLy8gcmVzY29wZSB0aGUgc2VnbWVudHMgdG8gYmUgd2l0aGluIHRoZSBjZWxsJ3MgZGF0ZVxyXG4gICAgICAgICAgICB2YXIgcmVzbGljZWRBbGxTZWdzID0gX3RoaXMucmVzbGljZURheVNlZ3MoYWxsU2VncywgZGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciByZXNsaWNlZEhpZGRlblNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhoaWRkZW5TZWdzLCBkYXRlKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSBhbiBhdG9taWMgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICBjbGlja09wdGlvbiA9IF90aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRMaW1pdENsaWNrJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbDogZGF5RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JlRWw6IG1vcmVFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ3M6IHJlc2xpY2VkQWxsU2VncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHJlc2xpY2VkSGlkZGVuU2Vnc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1xyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbGlja09wdGlvbiA9PT0gJ3BvcG92ZXInKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zaG93U2VnUG9wb3Zlcihyb3csIGNvbCwgbW9yZUVsLCByZXNsaWNlZEFsbFNlZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIuem9vbVRvKGRhdGUsIGNsaWNrT3B0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFJldmVhbHMgdGhlIHBvcG92ZXIgdGhhdCBkaXNwbGF5cyBhbGwgZXZlbnRzIHdpdGhpbiBhIGNlbGxcclxuICAgIERheUdyaWQucHJvdG90eXBlLnNob3dTZWdQb3BvdmVyID0gZnVuY3Rpb24gKHJvdywgY29sLCBtb3JlTGluaywgc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG1vcmVXcmFwID0gbW9yZUxpbmsucGFyZW50KCk7IC8vIHRoZSA8ZGl2PiB3cmFwcGVyIGFyb3VuZCB0aGUgPGE+XHJcbiAgICAgICAgdmFyIHRvcEVsOyAvLyB0aGUgZWxlbWVudCB3ZSB3YW50IHRvIG1hdGNoIHRoZSB0b3AgY29vcmRpbmF0ZSBvZlxyXG4gICAgICAgIHZhciBvcHRpb25zO1xyXG4gICAgICAgIGlmICh0aGlzLnJvd0NudCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0b3BFbCA9IHZpZXcuZWw7IC8vIHdpbGwgY2F1c2UgdGhlIHBvcG92ZXIgdG8gY292ZXIgYW55IHNvcnQgb2YgaGVhZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0b3BFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHdpbGwgYWxpZ24gd2l0aCB0b3Agb2Ygcm93XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZjLW1vcmUtcG9wb3ZlciAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygncG9wb3ZlcicpLFxyXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlclNlZ1BvcG92ZXJDb250ZW50KHJvdywgY29sLCBzZWdzKSxcclxuICAgICAgICAgICAgcGFyZW50RWw6IHZpZXcuZWwsXHJcbiAgICAgICAgICAgIHRvcDogdG9wRWwub2Zmc2V0KCkudG9wLFxyXG4gICAgICAgICAgICBhdXRvSGlkZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmlld3BvcnRDb25zdHJhaW46IHRoaXMub3B0KCdwb3BvdmVyVmlld3BvcnRDb25zdHJhaW4nKSxcclxuICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8ga2lsbCBldmVyeXRoaW5nIHdoZW4gdGhlIHBvcG92ZXIgaXMgaGlkZGVuXHJcbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgZXZlbnRzIHRvIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wb3BvdmVyU2Vncykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJCZWZvcmVFdmVudFNlZ3NEZXN0cm95ZWQoX3RoaXMucG9wb3ZlclNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3Zlci5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdQb3BvdmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBvcG92ZXJTZWdzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGhvcml6b250YWwgY29vcmRpbmF0ZS5cclxuICAgICAgICAvLyBXZSB1c2UgdGhlIG1vcmVXcmFwIGluc3RlYWQgb2YgdGhlIDx0ZD4gdG8gYXZvaWQgYm9yZGVyIGNvbmZ1c2lvbi5cclxuICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLnJpZ2h0ID0gbW9yZVdyYXAub2Zmc2V0KCkubGVmdCArIG1vcmVXcmFwLm91dGVyV2lkdGgoKSArIDE7IC8vICsxIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG1vcmVXcmFwLm9mZnNldCgpLmxlZnQgLSAxOyAvLyAtMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VnUG9wb3ZlciA9IG5ldyBQb3BvdmVyXzEuZGVmYXVsdChvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnNlZ1BvcG92ZXIuc2hvdygpO1xyXG4gICAgICAgIC8vIHRoZSBwb3BvdmVyIGRvZXNuJ3QgbGl2ZSB3aXRoaW4gdGhlIGdyaWQncyBjb250YWluZXIgZWxlbWVudCwgYW5kIHRodXMgd29uJ3QgZ2V0IHRoZSBldmVudFxyXG4gICAgICAgIC8vIGRlbGVnYXRlZC1oYW5kbGVycyBmb3IgZnJlZS4gYXR0YWNoIGV2ZW50LXJlbGF0ZWQgaGFuZGxlcnMgdG8gdGhlIHBvcG92ZXIuXHJcbiAgICAgICAgdGhpcy5iaW5kQWxsU2VnSGFuZGxlcnNUb0VsKHRoaXMuc2VnUG9wb3Zlci5lbCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyQWZ0ZXJFdmVudFNlZ3NSZW5kZXJlZChzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIGlubmVyIERPTSBjb250ZW50cyBvZiB0aGUgc2VnbWVudCBwb3BvdmVyXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJTZWdQb3BvdmVyQ29udGVudCA9IGZ1bmN0aW9uIChyb3csIGNvbCwgc2Vncykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCkuZm9ybWF0KHRoaXMub3B0KCdkYXlQb3BvdmVyRm9ybWF0JykpO1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gJCgnPGRpdiBjbGFzcz1cImZjLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSArICdcIj48L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHRpdGxlKSArXHJcbiAgICAgICAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIi8+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgICAgIHZhciBzZWdDb250YWluZXIgPSBjb250ZW50LmZpbmQoJy5mYy1ldmVudC1jb250YWluZXInKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICAvLyByZW5kZXIgZWFjaCBzZWcncyBgZWxgIGFuZCBvbmx5IHJldHVybiB0aGUgdmlzaWJsZSBzZWdzXHJcbiAgICAgICAgc2VncyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJGZ1NlZ0VscyhzZWdzLCB0cnVlKTsgLy8gZGlzYWJsZVJlc2l6aW5nPXRydWVcclxuICAgICAgICB0aGlzLnBvcG92ZXJTZWdzID0gc2VncztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHNlZ21lbnRzIGluIHRoZSBwb3BvdmVyIGFyZSBub3QgcGFydCBvZiBhIGdyaWQgY29vcmRpbmF0ZSBzeXN0ZW0sIHByb3ZpZGUgYSBoaW50IHRvIGFueVxyXG4gICAgICAgICAgICAvLyBncmlkcyB0aGF0IHdhbnQgdG8gZG8gZHJhZy1uLWRyb3AgYWJvdXQgd2hpY2ggY2VsbCBpdCBjYW1lIGZyb21cclxuICAgICAgICAgICAgdGhpcy5oaXRzTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHNlZ3NbaV0uaGl0ID0gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcclxuICAgICAgICAgICAgdGhpcy5oaXRzTm90TmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHNlZ0NvbnRhaW5lci5hcHBlbmQoc2Vnc1tpXS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHRoZSBldmVudHMgd2l0aGluIGFuIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cywgcmVzbGljZSB0aGVtIHRvIGJlIGluIGEgc2luZ2xlIGRheVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVzbGljZURheVNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZGF5RGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXlTdGFydCA9IGRheURhdGUuY2xvbmUoKTtcclxuICAgICAgICB2YXIgZGF5RW5kID0gZGF5U3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB2YXIgZGF5UmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChkYXlTdGFydCwgZGF5RW5kKTtcclxuICAgICAgICB2YXIgbmV3U2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNsaWNlZFJhbmdlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNsaWNlZFJhbmdlID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLmludGVyc2VjdChkYXlSYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U2Vncy5wdXNoKCQuZXh0ZW5kKHt9LCBzZWcsIHtcclxuICAgICAgICAgICAgICAgICAgICBmb290cHJpbnQ6IG5ldyBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQoc2xpY2VkUmFuZ2UsIHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSwgc2VnLmZvb3RwcmludC5ldmVudERlZiwgc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5pc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQgJiYgc2xpY2VkUmFuZ2UuaXNFbmRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3JjZSBhbiBvcmRlciBiZWNhdXNlIGV2ZW50c1RvU2VncyBkb2Vzbid0IGd1YXJhbnRlZSBvbmVcclxuICAgICAgICAvLyBUT0RPOiByZXNlYXJjaCBpZiBzdGlsbCBuZWVkZWRcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuc29ydEV2ZW50U2VncyhuZXdTZWdzKTtcclxuICAgICAgICByZXR1cm4gbmV3U2VncztcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgaW5zaWRlIGEgXCJtb3JlXCIgbGluaywgZ2l2ZW4gdGhlIG51bWJlciBvZiBldmVudHMgaXQgcmVwcmVzZW50c1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0TW9yZUxpbmtUZXh0ID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdFRleHQnKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0KG51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJysnICsgbnVtICsgJyAnICsgb3B0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHNlZ21lbnRzIHdpdGhpbiBhIGdpdmVuIGNlbGwuXHJcbiAgICAvLyBJZiBgc3RhcnRMZXZlbGAgaXMgc3BlY2lmaWVkLCByZXR1cm5zIG9ubHkgZXZlbnRzIGluY2x1ZGluZyBhbmQgYmVsb3cgdGhhdCBsZXZlbC4gT3RoZXJ3aXNlIHJldHVybnMgYWxsIHNlZ3MuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRDZWxsU2VncyA9IGZ1bmN0aW9uIChyb3csIGNvbCwgc3RhcnRMZXZlbCkge1xyXG4gICAgICAgIHZhciBzZWdNYXRyaXggPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddLnNlZ01hdHJpeDtcclxuICAgICAgICB2YXIgbGV2ZWwgPSBzdGFydExldmVsIHx8IDA7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHdoaWxlIChsZXZlbCA8IHNlZ01hdHJpeC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc2VnID0gc2VnTWF0cml4W2xldmVsXVtjb2xdO1xyXG4gICAgICAgICAgICBpZiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXZlbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZDtcclxufShJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERheUdyaWQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmV2ZW50UmVuZGVyZXJDbGFzcyA9IERheUdyaWRFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyA9IEJ1c2luZXNzSG91clJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuaGVscGVyUmVuZGVyZXJDbGFzcyA9IERheUdyaWRIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmZpbGxSZW5kZXJlckNsYXNzID0gRGF5R3JpZEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRGF5R3JpZCk7XHJcbkRheVRhYmxlTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRGF5R3JpZCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgU2Nyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbnZhciBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjgpO1xyXG52YXIgRGF5R3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgXCJiYXNpY1wiIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgRGF5R3JpZCBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cclxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cclxudmFyIEJhc2ljVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJhc2ljVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhc2ljVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjYWxlbmRhciwgdmlld1NwZWMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZCA9IF90aGlzLmluc3RhbnRpYXRlRGF5R3JpZCgpO1xyXG4gICAgICAgIF90aGlzLmRheUdyaWQuaXNSaWdpZCA9IF90aGlzLmhhc1JpZ2lkUm93cygpO1xyXG4gICAgICAgIGlmIChfdGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnNXaXRoaW5EYXlzJykpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuZGF5R3JpZCk7XHJcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bydcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIERheUdyaWQgb2JqZWN0IHRoaXMgdmlldyBuZWVkcy4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5pbnN0YW50aWF0ZURheUdyaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgYSBzdWJjbGFzcyBvbiB0aGUgZmx5IHdpdGggQmFzaWNWaWV3LXNwZWNpZmljIGJlaGF2aW9yXHJcbiAgICAgICAgLy8gVE9ETzogY2FjaGUgdGhpcyBzdWJjbGFzc1xyXG4gICAgICAgIHZhciBzdWJjbGFzcyA9IG1ha2VEYXlHcmlkU3ViY2xhc3ModGhpcy5kYXlHcmlkQ2xhc3MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgc3ViY2xhc3ModGhpcyk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5icmVha09uV2Vla3MgPSAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIuY2FsbCh0aGlzLCBkYXRlUHJvZmlsZSk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF5R3JpZENvbnRhaW5lckVsO1xyXG4gICAgICAgIHZhciBkYXlHcmlkRWw7XHJcbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnZmMtYmFzaWMtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcclxuICAgICAgICBkYXlHcmlkQ29udGFpbmVyRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy1kYXktZ3JpZC1jb250YWluZXInKTtcclxuICAgICAgICBkYXlHcmlkRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtZGF5LWdyaWRcIiAvPicpLmFwcGVuZFRvKGRheUdyaWRDb250YWluZXJFbCk7XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQoZGF5R3JpZENvbnRhaW5lckVsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuaGVhZENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCcuZmMtaGVhZC1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuc2V0RWxlbWVudChkYXlHcmlkRWwpO1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXHJcbiAgICAvLyBUaGUgZGF5LWdyaWQgY29tcG9uZW50IHdpbGwgcmVuZGVyIGluc2lkZSBvZiBhIGNvbnRhaW5lciBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b25IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLm9wdCgnY29sdW1uSGVhZGVyJykgP1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiPiZuYnNwOzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSB3ZWVrIG51bWJlciBjb2x1bW4sIGlmIGl0IGlzIGtub3duXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLndlZWtOdW1iZXJTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlcldpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLndlZWtOdW1iZXJXaWR0aCArICdweFwiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgd2hldGhlciBlYWNoIHJvdyBzaG91bGQgaGF2ZSBhIGNvbnN0YW50IGhlaWdodFxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5oYXNSaWdpZFJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xyXG4gICAgICAgIHJldHVybiBldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJztcclxuICAgIH07XHJcbiAgICAvKiBEaW1lbnNpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcclxuICAgICAgICB2YXIgaGVhZFJvd0VsID0gdGhpcy5kYXlHcmlkLmhlYWRDb250YWluZXJFbC5maW5kKCcuZmMtcm93Jyk7XHJcbiAgICAgICAgdmFyIHNjcm9sbGVySGVpZ2h0O1xyXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgLy8gaGFjayB0byBnaXZlIHRoZSB2aWV3IHNvbWUgaGVpZ2h0IHByaW9yIHRvIGRheUdyaWQncyBjb2x1bW5zIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gVE9ETzogc2VwYXJhdGUgc2V0dGluZyBoZWlnaHQgZnJvbSBzY3JvbGxlciBWUyBkYXlHcmlkLlxyXG4gICAgICAgIGlmICghdGhpcy5kYXlHcmlkLnJvd0Vscykge1xyXG4gICAgICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZC5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCB3ZWVrIG51bWJlciBjZWxscyBydW5uaW5nIGRvd24gdGhlIHNpZGUgaGF2ZSB0aGUgc2FtZSB3aWR0aC5cclxuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSB3aWR0aCBmb3IgY2VsbHMgY3JlYXRlZCBsYXRlci5cclxuICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyV2lkdGggPSB1dGlsXzEubWF0Y2hDZWxsV2lkdGhzKHRoaXMuZWwuZmluZCgnLmZjLXdlZWstbnVtYmVyJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldCBhbGwgaGVpZ2h0cyB0byBiZSBuYXR1cmFsXHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpO1xyXG4gICAgICAgIHV0aWxfMS51bmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgIC8vIGlzIHRoZSBldmVudCBsaW1pdCBhIGNvbnN0YW50IGxldmVsIG51bWJlcj9cclxuICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBmaXJzdCBzbyB0aGUgaGVpZ2h0IGNhbiByZWRpc3RyaWJ1dGUgYWZ0ZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGlzdHJpYnV0ZSB0aGUgaGVpZ2h0IHRvIHRoZSByb3dzXHJcbiAgICAgICAgLy8gKHRvdGFsSGVpZ2h0IGlzIGEgXCJyZWNvbW1lbmRlZFwiIHZhbHVlIGlmIGlzQXV0bylcclxuICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldEdyaWRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQsIGlzQXV0byk7XHJcbiAgICAgICAgLy8gaXMgdGhlIGV2ZW50IGxpbWl0IGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQ/XHJcbiAgICAgICAgaWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7IC8vIGxpbWl0IHRoZSBsZXZlbHMgYWZ0ZXIgdGhlIGdyaWQncyByb3cgaGVpZ2h0cyBoYXZlIGJlZW4gc2V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGhzID0gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsLCBzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZG9pbmcgdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjcmVhdGVkIHRleHQgb3ZlcmZsb3cgd2hpY2ggY3JlYXRlZCBtb3JlIGhlaWdodC4gcmVkb1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIubG9ja092ZXJmbG93KHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGEgZGVzaXJlZCB0b3RhbCBoZWlnaHQgb2YgdGhlIHZpZXcsIHJldHVybnMgd2hhdCB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxlciBzaG91bGQgYmVcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIC8vIFNldHMgdGhlIGhlaWdodCBvZiBqdXN0IHRoZSBEYXlHcmlkIGNvbXBvbmVudCBpbiB0aGlzIHZpZXdcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuc2V0R3JpZEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgIGlmIChpc0F1dG8pIHtcclxuICAgICAgICAgICAgdXRpbF8xLnVuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzKTsgLy8gbGV0IHRoZSByb3dzIGJlIHRoZWlyIG5hdHVyYWwgaGVpZ2h0IHdpdGggbm8gZXhwYW5kaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1dGlsXzEuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsIHRydWUpOyAvLyB0cnVlID0gY29tcGVuc2F0ZSBmb3IgaGVpZ2h0LWhvZ2dpbmcgcm93c1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBTY3JvbGxcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IDAgfTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCkgfTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHNjcm9sbC50b3ApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzaWNWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2ljVmlldztcclxuQmFzaWNWaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG5CYXNpY1ZpZXcucHJvdG90eXBlLmRheUdyaWRDbGFzcyA9IERheUdyaWRfMS5kZWZhdWx0O1xyXG4vLyBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiBCYXNpY1ZpZXcncyBkYXlHcmlkXHJcbmZ1bmN0aW9uIG1ha2VEYXlHcmlkU3ViY2xhc3MoU3VwZXJDbGFzcykge1xyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlOyAvLyBkaXNwbGF5IHdlZWsgbnVtYmVycyBhbG9uZyB0aGUgc2lkZT9cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLm9wdCgnd2Vla051bWJlclRpdGxlJykpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgY29udGVudC1za2VsZXRvbiBjZWxscyB0aGF0IGRpc3BsYXkgdGhlIGRheS93ZWVrIG51bWJlcnNcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVyTnVtYmVySW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgdmFyIHdlZWtTdGFydCA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICB7IGRhdGU6IHdlZWtTdGFydCwgdHlwZTogJ3dlZWsnLCBmb3JjZU9mZjogdGhpcy5jb2xDbnQgPT09IDEgfSwgd2Vla1N0YXJ0LmZvcm1hdCgndycpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBkYXkgYmcgY2VsbHMgZm9yIGVhY2ggZGF5LXJvd1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlciAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgZXZlcnkgb3RoZXIgdHlwZSBvZiByb3cgZ2VuZXJhdGVkIGJ5IERheUdyaWQuXHJcbiAgICAgICAgLy8gQWZmZWN0cyBoZWxwZXItc2tlbGV0b24gYW5kIGhpZ2hsaWdodC1za2VsZXRvbiByb3dzLlxyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUuZ2V0SXNOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERheUdyaWRfMS5kZWZhdWx0LnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9KFN1cGVyQ2xhc3MpKTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiA2MyAqLyxcbi8qIDY0ICovLFxuLyogNjUgKi8sXG4vKiA2NiAqLyxcbi8qIDY3ICovLFxuLyogNjggKi8sXG4vKiA2OSAqLyxcbi8qIDcwICovLFxuLyogNzEgKi8sXG4vKiA3MiAqLyxcbi8qIDczICovLFxuLyogNzQgKi8sXG4vKiA3NSAqLyxcbi8qIDc2ICovLFxuLyogNzcgKi8sXG4vKiA3OCAqLyxcbi8qIDc5ICovLFxuLyogODAgKi8sXG4vKiA4MSAqLyxcbi8qIDgyICovLFxuLyogODMgKi8sXG4vKiA4NCAqLyxcbi8qIDg1ICovLFxuLyogODYgKi8sXG4vKiA4NyAqLyxcbi8qIDg4ICovLFxuLyogODkgKi8sXG4vKiA5MCAqLyxcbi8qIDkxICovLFxuLyogOTIgKi8sXG4vKiA5MyAqLyxcbi8qIDk0ICovLFxuLyogOTUgKi8sXG4vKiA5NiAqLyxcbi8qIDk3ICovLFxuLyogOTggKi8sXG4vKiA5OSAqLyxcbi8qIDEwMCAqLyxcbi8qIDEwMSAqLyxcbi8qIDEwMiAqLyxcbi8qIDEwMyAqLyxcbi8qIDEwNCAqLyxcbi8qIDEwNSAqLyxcbi8qIDEwNiAqLyxcbi8qIDEwNyAqLyxcbi8qIDEwOCAqLyxcbi8qIDEwOSAqLyxcbi8qIDExMCAqLyxcbi8qIDExMSAqLyxcbi8qIDExMiAqLyxcbi8qIDExMyAqLyxcbi8qIDExNCAqLyxcbi8qIDExNSAqLyxcbi8qIDExNiAqLyxcbi8qIDExNyAqLyxcbi8qIDExOCAqLyxcbi8qIDExOSAqLyxcbi8qIDEyMCAqLyxcbi8qIDEyMSAqLyxcbi8qIDEyMiAqLyxcbi8qIDEyMyAqLyxcbi8qIDEyNCAqLyxcbi8qIDEyNSAqLyxcbi8qIDEyNiAqLyxcbi8qIDEyNyAqLyxcbi8qIDEyOCAqLyxcbi8qIDEyOSAqLyxcbi8qIDEzMCAqLyxcbi8qIDEzMSAqLyxcbi8qIDEzMiAqLyxcbi8qIDEzMyAqLyxcbi8qIDEzNCAqLyxcbi8qIDEzNSAqLyxcbi8qIDEzNiAqLyxcbi8qIDEzNyAqLyxcbi8qIDEzOCAqLyxcbi8qIDEzOSAqLyxcbi8qIDE0MCAqLyxcbi8qIDE0MSAqLyxcbi8qIDE0MiAqLyxcbi8qIDE0MyAqLyxcbi8qIDE0NCAqLyxcbi8qIDE0NSAqLyxcbi8qIDE0NiAqLyxcbi8qIDE0NyAqLyxcbi8qIDE0OCAqLyxcbi8qIDE0OSAqLyxcbi8qIDE1MCAqLyxcbi8qIDE1MSAqLyxcbi8qIDE1MiAqLyxcbi8qIDE1MyAqLyxcbi8qIDE1NCAqLyxcbi8qIDE1NSAqLyxcbi8qIDE1NiAqLyxcbi8qIDE1NyAqLyxcbi8qIDE1OCAqLyxcbi8qIDE1OSAqLyxcbi8qIDE2MCAqLyxcbi8qIDE2MSAqLyxcbi8qIDE2MiAqLyxcbi8qIDE2MyAqLyxcbi8qIDE2NCAqLyxcbi8qIDE2NSAqLyxcbi8qIDE2NiAqLyxcbi8qIDE2NyAqLyxcbi8qIDE2OCAqLyxcbi8qIDE2OSAqLyxcbi8qIDE3MCAqLyxcbi8qIDE3MSAqLyxcbi8qIDE3MiAqLyxcbi8qIDE3MyAqLyxcbi8qIDE3NCAqLyxcbi8qIDE3NSAqLyxcbi8qIDE3NiAqLyxcbi8qIDE3NyAqLyxcbi8qIDE3OCAqLyxcbi8qIDE3OSAqLyxcbi8qIDE4MCAqLyxcbi8qIDE4MSAqLyxcbi8qIDE4MiAqLyxcbi8qIDE4MyAqLyxcbi8qIDE4NCAqLyxcbi8qIDE4NSAqLyxcbi8qIDE4NiAqLyxcbi8qIDE4NyAqLyxcbi8qIDE4OCAqLyxcbi8qIDE4OSAqLyxcbi8qIDE5MCAqLyxcbi8qIDE5MSAqLyxcbi8qIDE5MiAqLyxcbi8qIDE5MyAqLyxcbi8qIDE5NCAqLyxcbi8qIDE5NSAqLyxcbi8qIDE5NiAqLyxcbi8qIDE5NyAqLyxcbi8qIDE5OCAqLyxcbi8qIDE5OSAqLyxcbi8qIDIwMCAqLyxcbi8qIDIwMSAqLyxcbi8qIDIwMiAqLyxcbi8qIDIwMyAqLyxcbi8qIDIwNCAqLyxcbi8qIDIwNSAqLyxcbi8qIDIwNiAqLyxcbi8qIDIwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxudmFyIENvbnN0cmFpbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29uc3RyYWludHMoZXZlbnRNYW5hZ2VyLCBfY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9jYWxlbmRhciA9IF9jYWxlbmRhcjtcclxuICAgIH1cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxlbmRhci5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGRldGVybWluZXMgaWYgZXZlbnRJbnN0YW5jZUdyb3VwIGlzIGFsbG93ZWQsXHJcbiAgICBpbiByZWxhdGlvbiB0byBvdGhlciBFVkVOVFMgYW5kIGJ1c2luZXNzIGhvdXJzLlxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRJbnN0YW5jZUdyb3VwLmdldEV2ZW50RGVmKCk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZ2V0QWxsRXZlbnRSYW5nZXMoKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEluc3RhbmNlcyA9IHRoaXMuZ2V0UGVlckV2ZW50SW5zdGFuY2VzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50UmFuZ2VzID0gcGVlckV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMocGVlckV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgY29uc3RyYWludFZhbCA9IGV2ZW50RGVmLmdldENvbnN0cmFpbnQoKTtcclxuICAgICAgICB2YXIgb3ZlcmxhcFZhbCA9IGV2ZW50RGVmLmdldE92ZXJsYXAoKTtcclxuICAgICAgICB2YXIgZXZlbnRBbGxvd0Z1bmMgPSB0aGlzLm9wdCgnZXZlbnRBbGxvdycpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9vdHByaW50QWxsb3dlZChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCBjb25zdHJhaW50VmFsLCBvdmVybGFwVmFsLCBldmVudEZvb3RwcmludHNbaV0uZXZlbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRBbGxvd0Z1bmMpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50QWxsb3dGdW5jKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQudG9MZWdhY3kodGhpcy5fY2FsZW5kYXIpLCBldmVudEZvb3RwcmludHNbaV0uZ2V0RXZlbnRMZWdhY3koKSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5nZXRQZWVyRXZlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXNXaXRob3V0SWQoZXZlbnREZWYuaWQpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEluc3RhbmNlcyA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzKCk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudFJhbmdlcyA9IHBlZXJFdmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKHBlZXJFdmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIHNlbGVjdEFsbG93RnVuYztcclxuICAgICAgICBpZiAodGhpcy5pc0Zvb3RwcmludEFsbG93ZWQoY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCB0aGlzLm9wdCgnc2VsZWN0Q29uc3RyYWludCcpLCB0aGlzLm9wdCgnc2VsZWN0T3ZlcmxhcCcpKSkge1xyXG4gICAgICAgICAgICBzZWxlY3RBbGxvd0Z1bmMgPSB0aGlzLm9wdCgnc2VsZWN0QWxsb3cnKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdEFsbG93RnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdEFsbG93RnVuYyhjb21wb25lbnRGb290cHJpbnQudG9MZWdhY3kodGhpcy5fY2FsZW5kYXIpKSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmlzRm9vdHByaW50QWxsb3dlZCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHMsIGNvbnN0cmFpbnRWYWwsIG92ZXJsYXBWYWwsIHN1YmplY3RFdmVudEluc3RhbmNlIC8vIG9wdGlvbmFsXHJcbiAgICApIHtcclxuICAgICAgICB2YXIgY29uc3RyYWludEZvb3RwcmludHM7IC8vIENvbXBvbmVudEZvb3RwcmludFtdXHJcbiAgICAgICAgdmFyIG92ZXJsYXBFdmVudEZvb3RwcmludHM7IC8vIEV2ZW50Rm9vdHByaW50W11cclxuICAgICAgICBpZiAoY29uc3RyYWludFZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRGb290cHJpbnRzID0gdGhpcy5jb25zdHJhaW50VmFsVG9Gb290cHJpbnRzKGNvbnN0cmFpbnRWYWwsIGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Zvb3RwcmludFdpdGhpbkNvbnN0cmFpbnRzKGNvbXBvbmVudEZvb3RwcmludCwgY29uc3RyYWludEZvb3RwcmludHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29sbGVjdE92ZXJsYXBFdmVudEZvb3RwcmludHMocGVlckV2ZW50Rm9vdHByaW50cywgY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICBpZiAob3ZlcmxhcFZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBFdmVudEZvb3RwcmludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG92ZXJsYXBWYWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCFpc092ZXJsYXBzQWxsb3dlZEJ5RnVuYyhvdmVybGFwRXZlbnRGb290cHJpbnRzLCBvdmVybGFwVmFsLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKCFpc092ZXJsYXBFdmVudEluc3RhbmNlc0FsbG93ZWQob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgc3ViamVjdEV2ZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29uc3RyYWludFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNGb290cHJpbnRXaXRoaW5Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIGNvbnN0cmFpbnRGb290cHJpbnRzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvb3RwcmludENvbnRhaW5zRm9vdHByaW50KGNvbnN0cmFpbnRGb290cHJpbnRzW2ldLCBjb21wb25lbnRGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmNvbnN0cmFpbnRWYWxUb0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoY29uc3RyYWludFZhbCwgaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRWYWwgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEN1cnJlbnRCdXNpbmVzc0Zvb3RwcmludHMoaXNBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludFZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLnBhcnNlRXZlbnREZWZUb0luc3RhbmNlcyhjb25zdHJhaW50VmFsKTsgLy8gaGFuZGxlcyByZWN1cnJpbmcgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmICghZXZlbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9vdHByaW50cyhjb25zdHJhaW50VmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzVG9Gb290cHJpbnRzKGV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25zdHJhaW50VmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlc1dpdGhJZChjb25zdHJhaW50VmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMoZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyByZXR1cm5zIENvbXBvbmVudEZvb3RwcmludFtdXHJcbiAgICAvLyB1c2VzIGN1cnJlbnQgdmlldydzIHJhbmdlXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuYnVpbGRDdXJyZW50QnVzaW5lc3NGb290cHJpbnRzID0gZnVuY3Rpb24gKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jYWxlbmRhci52aWV3O1xyXG4gICAgICAgIHZhciBidXNpbmVzc0hvdXJHZW5lcmF0b3IgPSB2aWV3LmdldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJyk7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZSA9IHZpZXcuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSBidXNpbmVzc0hvdXJHZW5lcmF0b3IuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAoaXNBbGxEYXksIHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjb252ZXJzaW9uIHV0aWxcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlcykge1xyXG4gICAgICAgIHZhciBldmVudFJhbmdlcyA9IGV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlcyk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50cy5tYXAodXRpbF8xLmV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgfTtcclxuICAgIC8vIE92ZXJsYXBcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmNvbGxlY3RPdmVybGFwRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKHBlZXJFdmVudEZvb3RwcmludHMsIHRhcmdldEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBvdmVybGFwRXZlbnRGb290cHJpbnRzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBlZXJFdmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9vdHByaW50c0ludGVyc2VjdCh0YXJnZXRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5wdXNoKHBlZXJFdmVudEZvb3RwcmludHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdmVybGFwRXZlbnRGb290cHJpbnRzO1xyXG4gICAgfTtcclxuICAgIC8vIENvbnZlcnNpb246IGV2ZW50RGVmcyAtPiBldmVudEluc3RhbmNlcyAtPiBldmVudFJhbmdlcyAtPiBldmVudEZvb3RwcmludHMgLT4gY29tcG9uZW50Rm9vdHByaW50c1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBOT1RFOiB0aGlzIG1pZ2h0IHNlZW0gbGlrZSByZXBldGl0aXZlIGNvZGUgd2l0aCB0aGUgR3JpZCBjbGFzcywgaG93ZXZlciwgdGhpcyBjb2RlIGlzIHJlbGF0ZWQgdG9cclxuICAgIC8vIGNvbnN0cmFpbnRzIHdoZXJlYXMgdGhlIEdyaWQgY29kZSBpcyByZWxhdGVkIHRvIHJlbmRlcmluZy4gRWFjaCBhcHByb2FjaCBtaWdodCB3YW50IHRvIGNvbnZlcnRcclxuICAgIC8vIGV2ZW50UmFuZ2VzIC0+IGV2ZW50Rm9vdHByaW50cyBpbiBhIGRpZmZlcmVudCB3YXkuIFJlZ2FyZGxlc3MsIHRoZXJlIGFyZSBvcHBvcnR1bml0aWVzIHRvIG1ha2VcclxuICAgIC8vIHRoaXMgbW9yZSBEUlkuXHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBmYWxzZSBvbiBpbnZhbGlkIGlucHV0LlxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5wYXJzZUV2ZW50RGVmVG9JbnN0YW5jZXMgPSBmdW5jdGlvbiAoZXZlbnRJbnB1dCkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UoZXZlbnRJbnB1dCwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdCh0aGlzLl9jYWxlbmRhcikpO1xyXG4gICAgICAgIGlmICghZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXMoZXZlbnRNYW5hZ2VyLmN1cnJlbnRQZXJpb2QudW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLnB1c2guYXBwbHkoLy8gZm9vdHByaW50c1xyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMsIHRoaXMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHM7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1dGlsXzEuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSldO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBQYXJzZXMgZm9vdHByaW50cyBkaXJlY3RseS5cclxuICAgIFZlcnkgc2ltaWxhciB0byBFdmVudERhdGVQcm9maWxlOjpwYXJzZSA6KFxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5wYXJzZUZvb3RwcmludHMgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAocmF3SW5wdXQuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jYWxlbmRhci5tb21lbnQocmF3SW5wdXQuc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdJbnB1dC5lbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5fY2FsZW5kYXIubW9tZW50KHJhd0lucHV0LmVuZCk7XHJcbiAgICAgICAgICAgIGlmICghZW5kLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgKHN0YXJ0ICYmICFzdGFydC5oYXNUaW1lKCkpIHx8IChlbmQgJiYgIWVuZC5oYXNUaW1lKCkpIC8vIGlzQWxsRGF5XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIC8vIEZvb3RwcmludCBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmZvb3RwcmludENvbnRhaW5zRm9vdHByaW50ID0gZnVuY3Rpb24gKG91dGVyRm9vdHByaW50LCBpbm5lckZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiBvdXRlckZvb3RwcmludC51bnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShpbm5lckZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5mb290cHJpbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludDAsIGZvb3RwcmludDEpIHtcclxuICAgICAgICByZXR1cm4gZm9vdHByaW50MC51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0c1dpdGgoZm9vdHByaW50MS51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb25zdHJhaW50cztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uc3RyYWludHM7XHJcbi8vIG9wdGlvbmFsIHN1YmplY3RFdmVudEluc3RhbmNlXHJcbmZ1bmN0aW9uIGlzT3ZlcmxhcHNBbGxvd2VkQnlGdW5jKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIG92ZXJsYXBGdW5jLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb3ZlcmxhcEZ1bmMob3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlLnRvTGVnYWN5KCksIHN1YmplY3RFdmVudEluc3RhbmNlID8gc3ViamVjdEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSA6IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc092ZXJsYXBFdmVudEluc3RhbmNlc0FsbG93ZWQob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHZhciBzdWJqZWN0TGVnYWN5SW5zdGFuY2UgPSBzdWJqZWN0RXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50SW5zdGFuY2U7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50RGVmO1xyXG4gICAgdmFyIG92ZXJsYXBWYWw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG92ZXJsYXBFdmVudEluc3RhbmNlID0gb3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlO1xyXG4gICAgICAgIG92ZXJsYXBFdmVudERlZiA9IG92ZXJsYXBFdmVudEluc3RhbmNlLmRlZjtcclxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHBhc3MgaW4gY2FsZW5kYXIsIGJlY2F1c2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBnbG9iYWwgZXZlbnRPdmVybGFwIHByb3BlcnR5LFxyXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBjb25zaWRlcmVkIHRoYXQgZWFybGllciBpbiB0aGUgcHJvY2Vzcy5cclxuICAgICAgICBvdmVybGFwVmFsID0gb3ZlcmxhcEV2ZW50RGVmLmdldE92ZXJsYXAoKTtcclxuICAgICAgICBpZiAob3ZlcmxhcFZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3ZlcmxhcFZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoIW92ZXJsYXBWYWwob3ZlcmxhcEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSwgc3ViamVjdExlZ2FjeUluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXHJcblVTQUdFOlxyXG4gIGltcG9ydCB7IGRlZmF1bHQgYXMgUGFyc2FibGVNb2RlbE1peGluLCBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlIH0gZnJvbSAnLi9QYXJzYWJsZU1vZGVsTWl4aW4nXHJcbmluIGNsYXNzOlxyXG4gIGFwcGx5UHJvcHM6IFBhcnNhYmxlTW9kZWxJbnRlcmZhY2VbJ2FwcGx5UHJvcHMnXVxyXG4gIGFwcGx5TWFudWFsU3RhbmRhcmRQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzJ11cclxuICBhcHBseU1pc2NQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlNaXNjUHJvcHMnXVxyXG4gIGlzU3RhbmRhcmRQcm9wOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydpc1N0YW5kYXJkUHJvcCddXHJcbiAgc3RhdGljIGRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW4uZGVmaW5lU3RhbmRhcmRQcm9wc1xyXG4gIHN0YXRpYyBjb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHNcclxuYWZ0ZXIgY2xhc3M6XHJcbiAgUGFyc2FibGVNb2RlbE1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnNhYmxlTW9kZWxNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBhcnNhYmxlTW9kZWxNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4uZGVmaW5lU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wRGVmcykge1xyXG4gICAgICAgIHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlO1xyXG4gICAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ3N0YW5kYXJkUHJvcE1hcCcpKSB7XHJcbiAgICAgICAgICAgIHByb3RvLnN0YW5kYXJkUHJvcE1hcCA9IE9iamVjdC5jcmVhdGUocHJvdG8uc3RhbmRhcmRQcm9wTWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhwcm9wRGVmcywgcHJvdG8uc3RhbmRhcmRQcm9wTWFwKTtcclxuICAgIH07XHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4uY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QpIHtcclxuICAgICAgICB2YXIgbWFwID0gdGhpcy5wcm90b3R5cGUuc3RhbmRhcmRQcm9wTWFwO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICBpZiAoc3JjW3Byb3BOYW1lXSAhPSBudWxsICYmIC8vIGluIHRoZSBzcmMgb2JqZWN0P1xyXG4gICAgICAgICAgICAgICAgbWFwW3Byb3BOYW1lXSA9PT0gdHJ1ZSAvLyBmYWxzZSBtZWFucyBcImNvcHkgdmVyYmF0aW1cIlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGRlc3RbcHJvcE5hbWVdID0gc3JjW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyB0cnVlL2ZhbHNlIGZvciBzdWNjZXNzLlxyXG4gICAgTWVhbnQgdG8gYmUgb25seSBjYWxsZWQgT05DRSwgYXQgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BNYXAgPSB0aGlzLnN0YW5kYXJkUHJvcE1hcDtcclxuICAgICAgICB2YXIgbWFudWFsUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgbWlzY1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIHByb3BOYW1lO1xyXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkUHJvcE1hcFtwcm9wTmFtZV0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YW5kYXJkUHJvcE1hcFtwcm9wTmFtZV0gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYW51YWxQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtaXNjUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwbHlNaXNjUHJvcHMobWlzY1Byb3BzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMobWFudWFsUHJvcHMpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBJZiBzdWJjbGFzc2VzIG92ZXJyaWRlLCB0aGV5IG11c3QgY2FsbCB0aGlzIHN1cGVybWV0aG9kIGFuZCByZXR1cm4gdGhlIGJvb2xlYW4gcmVzcG9uc2UuXHJcbiAgICBNZWFudCB0byBiZSBvbmx5IGNhbGxlZCBPTkNFLCBhdCBvYmplY3QgY3JlYXRpb24uXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgQ2FuIGJlIGNhbGxlZCBldmVuIGFmdGVyIGluaXRpYWwgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgVE9ETzogd2h5IGlzIHRoaXMgYSBtZXRob2Qgd2hlbiBkZWZpbmVTdGFuZGFyZFByb3BzIGlzIHN0YXRpY1xyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuaXNTdGFuZGFyZFByb3AgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcHJvcE5hbWUgaW4gdGhpcy5zdGFuZGFyZFByb3BNYXA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhcnNhYmxlTW9kZWxNaXhpbjtcclxufShNaXhpbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGFyc2FibGVNb2RlbE1peGluO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLnN0YW5kYXJkUHJvcE1hcCA9IHt9OyAvLyB3aWxsIGJlIGNsb25lZCBieSBkZWZpbmVTdGFuZGFyZFByb3BzXHJcblxuXG4vKioqLyB9KSxcbi8qIDIwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudEluc3RhbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRJbnN0YW5jZShkZWYsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgfVxyXG4gICAgRXZlbnRJbnN0YW5jZS5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5kZWYudG9MZWdhY3koKTtcclxuICAgICAgICBvYmouc3RhcnQgPSBkYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIG9iai5lbmQgPSBkYXRlUHJvZmlsZS5lbmQgPyBkYXRlUHJvZmlsZS5lbmQuY2xvbmUoKSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRJbnN0YW5jZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRJbnN0YW5jZTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG52YXIgRXZlbnRJbnN0YW5jZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDkpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBSZWN1cnJpbmdFdmVudERlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFJlY3VycmluZ0V2ZW50RGVmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVjdXJyaW5nRXZlbnREZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGFydFRpbWUgJiYgIXRoaXMuZW5kVGltZTtcclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5zb3VyY2UuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHVuem9uZWREYXRlID0gdW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIHVuem9uZWRFbmQgPSB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgdmFyIHpvbmVkRGF5U3RhcnQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlU3RhcnQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlRW5kO1xyXG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAodW56b25lZERhdGUuaXNCZWZvcmUodW56b25lZEVuZCkpIHtcclxuICAgICAgICAgICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZG93SGFzaCB8fCB0aGlzLmRvd0hhc2hbdW56b25lZERhdGUuZGF5KCldKSB7XHJcbiAgICAgICAgICAgICAgICB6b25lZERheVN0YXJ0ID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZSh1bnpvbmVkRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gem9uZWREYXlTdGFydC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydC50aW1lKHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VFbmQgPSB6b25lZERheVN0YXJ0LmNsb25lKCkudGltZSh0aGlzLmVuZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2gobmV3IEV2ZW50SW5zdGFuY2VfMS5kZWZhdWx0KHRoaXMsIC8vIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICAgIG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChpbnN0YW5jZVN0YXJ0LCBpbnN0YW5jZUVuZCwgY2FsZW5kYXIpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW56b25lZERhdGUuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLnNldERvdyA9IGZ1bmN0aW9uIChkb3dOdW1iZXJzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvd0hhc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5kb3dIYXNoID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG93TnVtYmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmRvd0hhc2hbZG93TnVtYmVyc1tpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IF9zdXBlci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoZGVmLnN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICBkZWYuc3RhcnRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZi5lbmRUaW1lKSB7XHJcbiAgICAgICAgICAgIGRlZi5lbmRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMuZW5kVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRvd0hhc2gpIHtcclxuICAgICAgICAgICAgZGVmLmRvd0hhc2ggPSAkLmV4dGVuZCh7fSwgdGhpcy5kb3dIYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVjdXJyaW5nRXZlbnREZWY7XHJcbn0oRXZlbnREZWZfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlY3VycmluZ0V2ZW50RGVmO1xyXG4vKlxyXG5IQUNLIHRvIHdvcmsgd2l0aCBUeXBlU2NyaXB0IG1peGluc1xyXG5OT1RFOiBpZiBzdXBlci1tZXRob2QgZmFpbHMsIHNob3VsZCBzdGlsbCBhdHRlbXB0IHRvIGFwcGx5XHJcbiovXHJcblJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5hcHBseVByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICB2YXIgc3VwZXJTdWNjZXNzID0gRXZlbnREZWZfMS5kZWZhdWx0LnByb3RvdHlwZS5hcHBseVByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgaWYgKHJhd1Byb3BzLnN0YXJ0KSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBtb21lbnQuZHVyYXRpb24ocmF3UHJvcHMuc3RhcnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmVuZCkge1xyXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG1vbWVudC5kdXJhdGlvbihyYXdQcm9wcy5lbmQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmRvdykge1xyXG4gICAgICAgIHRoaXMuc2V0RG93KHJhd1Byb3BzLmRvdyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG59O1xyXG4vLyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5SZWN1cnJpbmdFdmVudERlZi5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIHN0YXJ0OiBmYWxzZSxcclxuICAgIGVuZDogZmFsc2UsXHJcbiAgICBkb3c6IGZhbHNlXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UmFuZ2UodW56b25lZFJhbmdlLCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMudW56b25lZFJhbmdlID0gdW56b25lZFJhbmdlO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWYgPSBldmVudERlZjtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBFdmVudFJhbmdlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFJhbmdlO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBSZWN1cnJpbmdFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTApO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTID0ge1xyXG4gICAgc3RhcnQ6ICcwOTowMCcsXHJcbiAgICBlbmQ6ICcxNzowMCcsXHJcbiAgICBkb3c6IFsxLCAyLCAzLCA0LCA1XSxcclxuICAgIHJlbmRlcmluZzogJ2ludmVyc2UtYmFja2dyb3VuZCdcclxuICAgIC8vIGNsYXNzTmFtZXMgYXJlIGRlZmluZWQgaW4gYnVzaW5lc3NIb3Vyc1NlZ0NsYXNzZXNcclxufTtcclxudmFyIEJ1c2luZXNzSG91ckdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1c2luZXNzSG91ckdlbmVyYXRvcihyYXdDb21wbGV4RGVmLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHRoaXMucmF3Q29tcGxleERlZiA9IHJhd0NvbXBsZXhEZWY7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgfVxyXG4gICAgQnVzaW5lc3NIb3VyR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEV2ZW50SW5zdGFuY2VHcm91cCA9IGZ1bmN0aW9uIChpc0FsbERheSwgdW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuYnVpbGRFdmVudERlZnMoaXNBbGxEYXkpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQodXRpbF8xLmV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMoZXZlbnREZWZzLCB1bnpvbmVkUmFuZ2UpKTtcclxuICAgICAgICAgICAgLy8gc28gdGhhdCBpbnZlcnNlLWJhY2tncm91bmQgcmVuZGVyaW5nIGNhbiBoYXBwZW4gZXZlbiB3aGVuIG5vIGV2ZW50UmFuZ2VzIGluIHZpZXdcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwLmV4cGxpY2l0RXZlbnREZWYgPSBldmVudERlZnNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91ckdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRFdmVudERlZnMgPSBmdW5jdGlvbiAoaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmF3Q29tcGxleERlZiA9IHRoaXMucmF3Q29tcGxleERlZjtcclxuICAgICAgICB2YXIgcmF3RGVmcyA9IFtdO1xyXG4gICAgICAgIHZhciByZXF1aXJlRG93ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBbXTtcclxuICAgICAgICBpZiAocmF3Q29tcGxleERlZiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByYXdEZWZzID0gW3t9XTsgLy8gd2lsbCBnZXQgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUyB2ZXJiYXRpbVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QocmF3Q29tcGxleERlZikpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFtyYXdDb21wbGV4RGVmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHJhd0NvbXBsZXhEZWYpKSB7XHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSByYXdDb21wbGV4RGVmO1xyXG4gICAgICAgICAgICByZXF1aXJlRG93ID0gdHJ1ZTsgLy8gZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXJlcXVpcmVEb3cgfHwgcmF3RGVmc1tpXS5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGRlZnMucHVzaCh0aGlzLmJ1aWxkRXZlbnREZWYoaXNBbGxEYXksIHJhd0RlZnNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmcztcclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRXZlbnREZWYgPSBmdW5jdGlvbiAoaXNBbGxEYXksIHJhd0RlZikge1xyXG4gICAgICAgIHZhciBmdWxsUmF3RGVmID0gJC5leHRlbmQoe30sIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMsIHJhd0RlZik7XHJcbiAgICAgICAgaWYgKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGZ1bGxSYXdEZWYuc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICBmdWxsUmF3RGVmLmVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWN1cnJpbmdFdmVudERlZl8xLmRlZmF1bHQucGFyc2UoZnVsbFJhd0RlZiwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdCh0aGlzLmNhbGVuZGFyKSAvLyBkdW1teSBzb3VyY2VcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCdXNpbmVzc0hvdXJHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91ckdlbmVyYXRvcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFN0YW5kYXJkVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFyZFRoZW1lO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xyXG4gICAgd2lkZ2V0OiAnZmMtdW50aGVtZWQnLFxyXG4gICAgd2lkZ2V0SGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICB3aWRnZXRDb250ZW50OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uJyxcclxuICAgIGNvcm5lckxlZnQ6ICdmYy1jb3JuZXItbGVmdCcsXHJcbiAgICBjb3JuZXJSaWdodDogJ2ZjLWNvcm5lci1yaWdodCcsXHJcbiAgICBzdGF0ZURlZmF1bHQ6ICdmYy1zdGF0ZS1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnZmMtc3RhdGUtYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdmYy1zdGF0ZS1kaXNhYmxlZCcsXHJcbiAgICBzdGF0ZUhvdmVyOiAnZmMtc3RhdGUtaG92ZXInLFxyXG4gICAgc3RhdGVEb3duOiAnZmMtc3RhdGUtZG93bicsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICBoZWFkZXJSb3c6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIGRheVJvdzogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICdmYy13aWRnZXQtY29udGVudCdcclxufTtcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ2ZjLWljb24teCcsXHJcbiAgICBwcmV2OiAnZmMtaWNvbi1sZWZ0LXNpbmdsZS1hcnJvdycsXHJcbiAgICBuZXh0OiAnZmMtaWNvbi1yaWdodC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWxlZnQtZG91YmxlLWFycm93JyxcclxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1yaWdodC1kb3VibGUtYXJyb3cnXHJcbn07XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdidXR0b25JY29ucyc7XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcclxuXG5cbi8qKiovIH0pLFxuLyogMjE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgSnF1ZXJ5VWlUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEpxdWVyeVVpVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBKcXVlcnlVaVRoZW1lKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBKcXVlcnlVaVRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBKcXVlcnlVaVRoZW1lO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xyXG4gICAgd2lkZ2V0OiAndWktd2lkZ2V0JyxcclxuICAgIHdpZGdldEhlYWRlcjogJ3VpLXdpZGdldC1oZWFkZXInLFxyXG4gICAgd2lkZ2V0Q29udGVudDogJ3VpLXdpZGdldC1jb250ZW50JyxcclxuICAgIGJ1dHRvbkdyb3VwOiAnZmMtYnV0dG9uLWdyb3VwJyxcclxuICAgIGJ1dHRvbjogJ3VpLWJ1dHRvbicsXHJcbiAgICBjb3JuZXJMZWZ0OiAndWktY29ybmVyLWxlZnQnLFxyXG4gICAgY29ybmVyUmlnaHQ6ICd1aS1jb3JuZXItcmlnaHQnLFxyXG4gICAgc3RhdGVEZWZhdWx0OiAndWktc3RhdGUtZGVmYXVsdCcsXHJcbiAgICBzdGF0ZUFjdGl2ZTogJ3VpLXN0YXRlLWFjdGl2ZScsXHJcbiAgICBzdGF0ZURpc2FibGVkOiAndWktc3RhdGUtZGlzYWJsZWQnLFxyXG4gICAgc3RhdGVIb3ZlcjogJ3VpLXN0YXRlLWhvdmVyJyxcclxuICAgIHN0YXRlRG93bjogJ3VpLXN0YXRlLWRvd24nLFxyXG4gICAgdG9kYXk6ICd1aS1zdGF0ZS1oaWdobGlnaHQnLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ3VpLXdpZGdldC1oZWFkZXInLFxyXG4gICAgcG9wb3ZlckNvbnRlbnQ6ICd1aS13aWRnZXQtY29udGVudCcsXHJcbiAgICAvLyBkYXkgZ3JpZFxyXG4gICAgaGVhZGVyUm93OiAndWktd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBkYXlSb3c6ICd1aS13aWRnZXQtY29udGVudCcsXHJcbiAgICAvLyBsaXN0IHZpZXdcclxuICAgIGxpc3RWaWV3OiAndWktd2lkZ2V0LWNvbnRlbnQnXHJcbn07XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAndWktaWNvbic7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICd1aS1pY29uLWNsb3NldGhpY2snLFxyXG4gICAgcHJldjogJ3VpLWljb24tY2lyY2xlLXRyaWFuZ2xlLXcnLFxyXG4gICAgbmV4dDogJ3VpLWljb24tY2lyY2xlLXRyaWFuZ2xlLWUnLFxyXG4gICAgcHJldlllYXI6ICd1aS1pY29uLXNlZWstcHJldicsXHJcbiAgICBuZXh0WWVhcjogJ3VpLWljb24tc2Vlay1uZXh0J1xyXG59O1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAndGhlbWVCdXR0b25JY29ucyc7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICd0aGVtZUljb24nO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAndWktaWNvbi0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBGdW5jRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGdW5jRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGdW5jRXZlbnRTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRnVuY0V2ZW50U291cmNlLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciByYXdQcm9wcztcclxuICAgICAgICAvLyBub3JtYWxpemUgcmF3IGlucHV0XHJcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihyYXdJbnB1dC5ldmVudHMpKSB7XHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0gcmF3SW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihyYXdJbnB1dCkpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSB7IGV2ZW50czogcmF3SW5wdXQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudFNvdXJjZV8xLmRlZmF1bHQucGFyc2UuY2FsbCh0aGlzLCByYXdQcm9wcywgY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRnVuY0V2ZW50U291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhci5wdXNoTG9hZGluZygpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5mdW5jLmNhbGwoX3RoaXMuY2FsZW5kYXIsIHN0YXJ0LmNsb25lKCksIGVuZC5jbG9uZSgpLCB0aW1lem9uZSwgZnVuY3Rpb24gKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIucG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgb25SZXNvbHZlKF90aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mdW5jO1xyXG4gICAgfTtcclxuICAgIEZ1bmNFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyU3VjY2VzcyA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgICAgIHRoaXMuZnVuYyA9IHJhd1Byb3BzLmV2ZW50cztcclxuICAgICAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGdW5jRXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZ1bmNFdmVudFNvdXJjZTtcclxuRnVuY0V2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgZXZlbnRzOiBmYWxzZSAvLyBkb24ndCBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgSnNvbkZlZWRFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEpzb25GZWVkRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBKc29uRmVlZEV2ZW50U291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAodHlwZW9mIHJhd0lucHV0LnVybCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhd0lucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgdXJsOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFqYXhTZXR0aW5ncyA9IHRoaXMuYWpheFNldHRpbmdzO1xyXG4gICAgICAgIHZhciBvblN1Y2Nlc3MgPSBhamF4U2V0dGluZ3Muc3VjY2VzcztcclxuICAgICAgICB2YXIgb25FcnJvciA9IGFqYXhTZXR0aW5ncy5lcnJvcjtcclxuICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IHRoaXMuYnVpbGRSZXF1ZXN0UGFyYW1zKHN0YXJ0LCBlbmQsIHRpbWV6b25lKTtcclxuICAgICAgICAvLyB0b2RvOiBldmVudHVhbGx5IGhhbmRsZSB0aGUgcHJvbWlzZSdzIHRoZW4sXHJcbiAgICAgICAgLy8gZG9uJ3QgaW50ZXJjZXB0IHN1Y2Nlc3MvZXJyb3JcclxuICAgICAgICAvLyB0aG8gd2lsbCBiZSBhIGJyZWFraW5nIEFQSSBjaGFuZ2VcclxuICAgICAgICB0aGlzLmNhbGVuZGFyLnB1c2hMb2FkaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LmNvbnN0cnVjdChmdW5jdGlvbiAob25SZXNvbHZlLCBvblJlamVjdCkge1xyXG4gICAgICAgICAgICAkLmFqYXgoJC5leHRlbmQoe30sIC8vIGRlc3RpbmF0aW9uXHJcbiAgICAgICAgICAgIEpzb25GZWVkRXZlbnRTb3VyY2UuQUpBWF9ERUZBVUxUUywgYWpheFNldHRpbmdzLCB7XHJcbiAgICAgICAgICAgICAgICB1cmw6IF90aGlzLnVybCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3RQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmF3RXZlbnREZWZzLCBzdGF0dXMsIHhocikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja1JlcztcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWxlbmRhci5wb3BMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1JlcyA9IHV0aWxfMS5hcHBseUFsbChvblN1Y2Nlc3MsIF90aGlzLCBbcmF3RXZlbnREZWZzLCBzdGF0dXMsIHhocl0pOyAvLyByZWRpcmVjdCBgdGhpc2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShjYWxsYmFja1JlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50RGVmcyA9IGNhbGxiYWNrUmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzb2x2ZShfdGhpcy5wYXJzZUV2ZW50RGVmcyhyYXdFdmVudERlZnMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoeGhyLCBzdGF0dXNUZXh0LCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXBwbHlBbGwob25FcnJvciwgX3RoaXMsIFt4aHIsIHN0YXR1c1RleHQsIGVycm9yVGhyb3duXSk7IC8vIHJlZGlyZWN0IGB0aGlzYFxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5idWlsZFJlcXVlc3RQYXJhbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBhamF4U2V0dGluZ3MgPSB0aGlzLmFqYXhTZXR0aW5ncztcclxuICAgICAgICB2YXIgc3RhcnRQYXJhbTtcclxuICAgICAgICB2YXIgZW5kUGFyYW07XHJcbiAgICAgICAgdmFyIHRpbWV6b25lUGFyYW07XHJcbiAgICAgICAgdmFyIGN1c3RvbVJlcXVlc3RQYXJhbXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHN0YXJ0UGFyYW0gPSB0aGlzLnN0YXJ0UGFyYW07XHJcbiAgICAgICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGFydFBhcmFtID0gY2FsZW5kYXIub3B0KCdzdGFydFBhcmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZFBhcmFtID0gdGhpcy5lbmRQYXJhbTtcclxuICAgICAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmRQYXJhbSA9IGNhbGVuZGFyLm9wdCgnZW5kUGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGltZXpvbmVQYXJhbSA9IHRoaXMudGltZXpvbmVQYXJhbTtcclxuICAgICAgICBpZiAodGltZXpvbmVQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRpbWV6b25lUGFyYW0gPSBjYWxlbmRhci5vcHQoJ3RpbWV6b25lUGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUICQuYWpheCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcclxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGFqYXhTZXR0aW5ncy5kYXRhKSkge1xyXG4gICAgICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IGFqYXhTZXR0aW5ncy5kYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IGFqYXhTZXR0aW5ncy5kYXRhIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAkLmV4dGVuZChwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xyXG4gICAgICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IHN0YXJ0LmZvcm1hdCgpO1xyXG4gICAgICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBlbmQuZm9ybWF0KCk7XHJcbiAgICAgICAgaWYgKHRpbWV6b25lICYmIHRpbWV6b25lICE9PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1t0aW1lem9uZVBhcmFtXSA9IHRpbWV6b25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cmw7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB0aGlzLmFqYXhTZXR0aW5ncyA9IHJhd1Byb3BzO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UuQUpBWF9ERUZBVUxUUyA9IHtcclxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIGNhY2hlOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBKc29uRmVlZEV2ZW50U291cmNlO1xyXG59KEV2ZW50U291cmNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBKc29uRmVlZEV2ZW50U291cmNlO1xyXG5Kc29uRmVlZEV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgLy8gYXV0b21hdGljYWxseSB0cmFuc2ZlciAodHJ1ZSkuLi5cclxuICAgIHVybDogdHJ1ZSxcclxuICAgIHN0YXJ0UGFyYW06IHRydWUsXHJcbiAgICBlbmRQYXJhbTogdHJ1ZSxcclxuICAgIHRpbWV6b25lUGFyYW06IHRydWVcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgVGFza1F1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGFza1F1ZXVlKCkge1xyXG4gICAgICAgIHRoaXMucSA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5xLnB1c2guYXBwbHkodGhpcy5xLCBhcmdzKTsgLy8gYXBwZW5kXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHJ5U3RhcnQoKTtcclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLmdldElzSWRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUudHJ5U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiB0aGlzLmNhblJ1bk5leHQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcclxuICAgICAgICAgICAgdGhpcy5ydW5SZW1haW5pbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5jYW5SdW5OZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1BhdXNlZCAmJiB0aGlzLnEubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuUmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRhc2s7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRhc2sgPSB0aGlzLnEuc2hpZnQoKTsgLy8gYWx3YXlzIGZyZXNobHkgcmVmZXJlbmNlIHEuIG1pZ2h0IGhhdmUgYmVlbiByZWFzc2lnbmVkLlxyXG4gICAgICAgICAgICByZXMgPSB0aGlzLnJ1blRhc2sodGFzayk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FuUnVuTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJ1blJlbWFpbmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBwcmV2ZW50IG1hcmtpbmcgYXMgc3RvcHBlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jYW5SdW5OZXh0KCkpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc3RvcCcpOyAvLyBub3QgcmVhbGx5IGEgJ3N0b3AnIC4uLiBtb3JlIG9mIGEgJ2RyYWluZWQnXHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyBpZiAnc3RvcCcgaGFuZGxlciBhZGRlZCBtb3JlIHRhc2tzLi4uLiBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhc2soKTsgLy8gdGFzayAqaXMqIHRoZSBmdW5jdGlvbiwgYnV0IHN1YmNsYXNzZXMgY2FuIGNoYW5nZSB0aGUgZm9ybWF0IG9mIGEgdGFza1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYXNrUXVldWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRhc2tRdWV1ZTtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKFRhc2tRdWV1ZSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFRhc2tRdWV1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTcpO1xyXG52YXIgUmVuZGVyUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZW5kZXJRdWV1ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlbmRlclF1ZXVlKHdhaXRzQnlOYW1lc3BhY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLndhaXRzQnlOYW1lc3BhY2UgPSB3YWl0c0J5TmFtZXNwYWNlIHx8IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICh0YXNrRnVuYywgbmFtZXNwYWNlLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHRhc2sgPSB7XHJcbiAgICAgICAgICAgIGZ1bmM6IHRhc2tGdW5jLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHdhaXRNcztcclxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIHdhaXRNcyA9IHRoaXMud2FpdHNCeU5hbWVzcGFjZVtuYW1lc3BhY2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRoaXMud2FpdE5hbWVzcGFjZSAmJiB3YWl0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVdhaXQod2FpdE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG91bmRUYXNrKHRhc2spKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy53YWl0TmFtZXNwYWNlICYmIHdhaXRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0V2FpdChuYW1lc3BhY2UsIHdhaXRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLnN0YXJ0V2FpdCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIHdhaXRNcykge1xyXG4gICAgICAgIHRoaXMud2FpdE5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuICAgICAgICB0aGlzLnNwYXduV2FpdCh3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5kZWxheVdhaXQgPSBmdW5jdGlvbiAod2FpdE1zKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FpdElkKTtcclxuICAgICAgICB0aGlzLnNwYXduV2FpdCh3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5zcGF3bldhaXQgPSBmdW5jdGlvbiAod2FpdE1zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLndhaXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy53YWl0TmFtZXNwYWNlID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMudHJ5U3RhcnQoKTtcclxuICAgICAgICB9LCB3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5jbGVhcldhaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53YWl0SWQpO1xyXG4gICAgICAgICAgICB0aGlzLndhaXRJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMud2FpdE5hbWVzcGFjZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5jYW5SdW5OZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX3N1cGVyLnByb3RvdHlwZS5jYW5SdW5OZXh0LmNhbGwodGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3YWl0aW5nIGZvciBhIGNlcnRhaW4gbmFtZXNwYWNlIHRvIHN0b3AgcmVjZWl2aW5nIHRhc2tzP1xyXG4gICAgICAgIGlmICh0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnE7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIGRpZmZlcmVudCBuYW1lc3BhY2UgdGFzayBpbiB0aGUgbWVhbnRpbWUsXHJcbiAgICAgICAgICAgIC8vIHRoYXQgZm9yY2VzIGFsbCBwcmV2aW91c2x5LXdhaXRpbmcgdGFza3MgdG8gc3VkZGVubHkgZXhlY3V0ZS5cclxuICAgICAgICAgICAgLy8gVE9ETzogZmluZCBhIHdheSB0byBkbyB0aGlzIGluIGNvbnN0YW50IHRpbWUuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHFbaV0ubmFtZXNwYWNlICE9PSB0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gYWxsb3cgZXhlY3V0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgdGFzay5mdW5jKCk7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLmNvbXBvdW5kVGFzayA9IGZ1bmN0aW9uIChuZXdUYXNrKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLnE7XHJcbiAgICAgICAgdmFyIHNob3VsZEFwcGVuZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRhc2s7XHJcbiAgICAgICAgaWYgKG5ld1Rhc2submFtZXNwYWNlICYmIG5ld1Rhc2sudHlwZSA9PT0gJ2Rlc3Ryb3knKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgaW5pdC9hZGQvcmVtb3ZlIG9wcyB3aXRoIHNhbWUgbmFtZXNwYWNlLCByZWdhcmRsZXNzIG9mIG9yZGVyXHJcbiAgICAgICAgICAgIGZvciAoaSA9IHEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHRhc2sgPSBxW2ldO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YXNrLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbml0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQXBwZW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxhdGVzdCBkZXN0cm95IGlzIGNhbmNlbGxlZCBvdXQgYnkgbm90IGRvaW5nIHRoZSBpbml0XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuc3BsaWNlKGksIDEpOyAvLyByZW1vdmUgdGFza1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRBcHBlbmQpIHtcclxuICAgICAgICAgICAgcS5wdXNoKG5ld1Rhc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hvdWxkQXBwZW5kO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZW5kZXJRdWV1ZTtcclxufShUYXNrUXVldWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlclF1ZXVlO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBkYXRlX2Zvcm1hdHRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG52YXIgQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNyk7XHJcbnZhciB1dGlsXzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxudmFyIERhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXRlQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF0ZUNvbXBvbmVudChfdmlldywgX29wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlzUlRMID0gZmFsc2U7IC8vIGZyZXF1ZW50bHkgYWNjZXNzZWQgb3B0aW9uc1xyXG4gICAgICAgIF90aGlzLmhpdHNOZWVkZWREZXB0aCA9IDA7IC8vIG5lY2Vzc2FyeSBiZWNhdXNlIG11bHRpcGxlIGNhbGxlcnMgbWlnaHQgbmVlZCB0aGUgc2FtZSBoaXRzXHJcbiAgICAgICAgX3RoaXMuaGFzQWxsRGF5QnVzaW5lc3NIb3VycyA9IGZhbHNlOyAvLyBUT0RPOiB1bmlmeSB3aXRoIGxhcmdlVW5pdCBhbmQgaXNUaW1lU2NhbGU/XHJcbiAgICAgICAgX3RoaXMuaXNEYXRlc1JlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gaGFjayB0byBzZXQgb3B0aW9ucyBwcmlvciB0byB0aGUgdGhpcy5vcHQgY2FsbHNcclxuICAgICAgICBpZiAoX3ZpZXcpIHtcclxuICAgICAgICAgICAgX3RoaXNbJ3ZpZXcnXSA9IF92aWV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX29wdGlvbnMpIHtcclxuICAgICAgICAgICAgX3RoaXNbJ29wdGlvbnMnXSA9IF9vcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy51aWQgPSBTdHJpbmcoRGF0ZUNvbXBvbmVudC5ndWlkKyspO1xyXG4gICAgICAgIF90aGlzLmNoaWxkcmVuQnlVaWQgPSB7fTtcclxuICAgICAgICBfdGhpcy5uZXh0RGF5VGhyZXNob2xkID0gbW9tZW50LmR1cmF0aW9uKF90aGlzLm9wdCgnbmV4dERheVRocmVzaG9sZCcpKTtcclxuICAgICAgICBfdGhpcy5pc1JUTCA9IF90aGlzLm9wdCgnaXNSVEwnKTtcclxuICAgICAgICBpZiAoX3RoaXMuZmlsbFJlbmRlcmVyQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZmlsbFJlbmRlcmVyID0gbmV3IF90aGlzLmZpbGxSZW5kZXJlckNsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV2ZW50UmVuZGVyZXJDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFJlbmRlcmVyID0gbmV3IF90aGlzLmV2ZW50UmVuZGVyZXJDbGFzcyhfdGhpcywgX3RoaXMuZmlsbFJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmhlbHBlclJlbmRlcmVyQ2xhc3MgJiYgX3RoaXMuZXZlbnRSZW5kZXJlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5oZWxwZXJSZW5kZXJlciA9IG5ldyBfdGhpcy5oZWxwZXJSZW5kZXJlckNsYXNzKF90aGlzLCBfdGhpcy5ldmVudFJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyQ2xhc3MgJiYgX3RoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyID0gbmV3IF90aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyQ2xhc3MoX3RoaXMsIF90aGlzLmZpbGxSZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXSA9IGNoaWxkO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiBvbmx5IGRvIGlmIGlzSW5Eb20/XHJcbiAgICAvLyBUT0RPOiBtYWtlIHBhcnQgb2YgQ29tcG9uZW50LCBhbG9uZyB3aXRoIGNoaWxkcmVuL2JhdGNoLXJlbmRlciBzeXN0ZW0/XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VwZGF0ZVNpemUnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIE9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWV3KCkub3B0KG5hbWUpOyAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uXHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLl9nZXRDYWxlbmRhcigpO1xyXG4gICAgICAgIHJldHVybiBjYWxlbmRhci5wdWJsaWNseVRyaWdnZXIuYXBwbHkoY2FsZW5kYXIsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhhc1B1YmxpY0hhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLl9nZXRDYWxlbmRhcigpO1xyXG4gICAgICAgIHJldHVybiBjYWxlbmRhci5oYXNQdWJsaWNIYW5kbGVycy5hcHBseShjYWxlbmRhciwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlOyAvLyBmb3IgcmVuZGVyaW5nXHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRlcyhkYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgdGhpcy5pc0RhdGVzUmVuZGVyZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdleGVjdXRlRGF0ZVJlbmRlcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZURhdGVVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZURhdGVVbnJlbmRlcicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckRhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5pc0RhdGVzUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBkYXRlLWNlbGwgY29udGVudCBvbmx5XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIGRhdGUtY2VsbCBjb250ZW50IG9ubHlcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICAvLyBOb3ctSW5kaWNhdG9yXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmV0dXJucyBhIHN0cmluZyB1bml0LCBsaWtlICdzZWNvbmQnIG9yICdtaW51dGUnIHRoYXQgZGVmaW5lZCBob3cgb2Z0ZW4gdGhlIGN1cnJlbnQgdGltZSBpbmRpY2F0b3JcclxuICAgIC8vIHNob3VsZCBiZSByZWZyZXNoZWQuIElmIHNvbWV0aGluZyBmYWxzeSBpcyByZXR1cm5lZCwgbm8gdGltZSBpbmRpY2F0b3IgaXMgcmVuZGVyZWQgYXQgYWxsLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0Tm93SW5kaWNhdG9yVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGEgY3VycmVudCB0aW1lIGluZGljYXRvciBhdCB0aGUgZ2l2ZW4gZGF0ZXRpbWVcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlck5vd0luZGljYXRvcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5kb2VzIHRoZSByZW5kZXJpbmcgYWN0aW9ucyBmcm9tIHJlbmRlck5vd0luZGljYXRvclxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyTm93SW5kaWNhdG9yJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBCdXNpbmVzcyBIb3Vyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJCdXNpbmVzc0hvdXJzID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91ckdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIucmVuZGVyKGJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJCdXNpbmVzc0hvdXJzJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgcHJldmlvdXNseS1yZW5kZXJlZCBidXNpbmVzcy1ob3Vyc1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJCdXNpbmVzc0hvdXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckJ1c2luZXNzSG91cnMnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgRGlzcGxheWluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVFdmVudFJlbmRlciA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIucmFuZ2VVcGRhdGVkKCk7IC8vIHBvb3JseSBuYW1lZCBub3dcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlcihldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpc1sncmVuZGVyRXZlbnRzJ10pIHtcclxuICAgICAgICAgICAgdGhpc1sncmVuZGVyRXZlbnRzJ10oY29udmVydEV2ZW50c1BheWxvYWRUb0xlZ2FjeUFycmF5KGV2ZW50c1BheWxvYWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVFdmVudFJlbmRlcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVFdmVudFVucmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzWydkZXN0cm95RXZlbnRzJ10pIHtcclxuICAgICAgICAgICAgdGhpc1snZGVzdHJveUV2ZW50cyddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEJ1c2luZXNzSG91clNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmdldE93bkJ1c2luZXNzSG91clNlZ3MoKTtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIGNoaWxkLmdldEJ1c2luZXNzSG91clNlZ3MoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3duQnVzaW5lc3NIb3VyU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlci5nZXRTZWdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRFdmVudFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmdldE93bkV2ZW50U2VncygpO1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgY2hpbGQuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldE93bkV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmVuZGVyZXIuZ2V0U2VncygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVuZGVyaW5nIFRyaWdnZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQWZ0ZXJFdmVudHNSZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXJBZnRlckV2ZW50U2Vnc1JlbmRlcmVkKHRoaXMuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudEFmdGVyQWxsUmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpc11cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQWZ0ZXJFdmVudFNlZ3NSZW5kZXJlZCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBhbiBvcHRpbWl6YXRpb24sIGJlY2F1c2UgZ2V0RXZlbnRMZWdhY3kgaXMgZXhwZW5zaXZlXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50QWZ0ZXJSZW5kZXInKSkge1xyXG4gICAgICAgICAgICBzZWdzLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZ2FjeTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdhY3kgPSBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudEFmdGVyUmVuZGVyJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBsZWdhY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtsZWdhY3ksIHNlZy5lbCwgX3RoaXNdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQmVmb3JlRXZlbnRzRGVzdHJveWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckJlZm9yZUV2ZW50U2Vnc0Rlc3Ryb3llZCh0aGlzLmdldEV2ZW50U2VncygpKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQmVmb3JlRXZlbnRTZWdzRGVzdHJveWVkID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1B1YmxpY0hhbmRsZXJzKCdldmVudERlc3Ryb3knKSkge1xyXG4gICAgICAgICAgICBzZWdzLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZ2FjeTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdhY3kgPSBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudERlc3Ryb3knLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGxlZ2FjeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xlZ2FjeSwgc2VnLmVsLCBfdGhpc11cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IFJlbmRlcmluZyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEhpZGVzIGFsbCByZW5kZXJlZCBldmVudCBzZWdtZW50cyBsaW5rZWQgdG8gdGhlIGdpdmVuIGV2ZW50XHJcbiAgICAvLyBSRUNVUlNJVkUgd2l0aCBzdWJjb21wb25lbnRzXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zaG93RXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCA9PT0gZXZlbnREZWZJZCAmJlxyXG4gICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3Nob3dFdmVudHNXaXRoSWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFNob3dzIGFsbCByZW5kZXJlZCBldmVudCBzZWdtZW50cyBsaW5rZWQgdG8gdGhlIGdpdmVuIGV2ZW50XHJcbiAgICAvLyBSRUNVUlNJVkUgd2l0aCBzdWJjb21wb25lbnRzXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlRXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCA9PT0gZXZlbnREZWZJZCAmJlxyXG4gICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2hpZGVFdmVudHNXaXRoSWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIERyYWctbi1Ecm9wIFJlbmRlcmluZyAoZm9yIGJvdGggZXZlbnRzIGFuZCBleHRlcm5hbCBlbGVtZW50cylcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgZXZlbnQgb3IgZXh0ZXJuYWwtZWxlbWVudCBkcmFnIG92ZXIgdGhlIGdpdmVuIGRyb3Agem9uZS5cclxuICAgIC8vIElmIGFuIGV4dGVybmFsLWVsZW1lbnQsIHNlZyB3aWxsIGJlIGBudWxsYC5cclxuICAgIC8vIE11c3QgcmV0dXJuIGVsZW1lbnRzIHVzZWQgZm9yIGFueSBtb2NrIGV2ZW50cy5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZWRIZWxwZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnJlbmRlckRyYWcoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZEhlbHBlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRIZWxwZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwtZWxlbWVudCBiZWluZyBkcmFnZ2VkLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckRyYWcnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IFJlc2l6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyRXZlbnRSZXNpemUnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckV2ZW50UmVzaXplJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWxlY3Rpb25cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIHRoZSBzZWxlY3Rpb25cclxuICAgIC8vIFRPRE86IHJlbmFtZSB0byBgcmVuZGVyU2VsZWN0aW9uYCBhZnRlciBsZWdhY3kgaXMgZ29uZVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlclNlbGVjdGlvbkZvb3RwcmludCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2Ygc2VsZWN0aW9uXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyU2VsZWN0aW9uJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBIaWdobGlnaHRcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhbiBlbXBoYXNpcyBvbiB0aGUgZ2l2ZW4gZGF0ZSByYW5nZS4gR2l2ZW4gYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVySGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci5yZW5kZXJGb290cHJpbnQoJ2hpZ2hsaWdodCcsIGNvbXBvbmVudEZvb3RwcmludCwge1xyXG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZjLWhpZ2hsaWdodCddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlckhpZ2hsaWdodCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHRoZSBlbXBoYXNpcyBvbiBhIGRhdGUgcmFuZ2VcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVySGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignaGlnaGxpZ2h0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlckhpZ2hsaWdodCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gSGl0IEFyZWFzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGp1c3QgYmVjYXVzZSBhbGwgRGF0ZUNvbXBvbmVudHMgc3VwcG9ydCB0aGlzIGludGVyZmFjZVxyXG4gICAgLy8gZG9lc24ndCBtZWFuIHRoZXkgbmVlZCB0byBoYXZlIHRoZWlyIG93biBpbnRlcm5hbCBjb29yZCBzeXN0ZW0uIHRoZXkgY2FuIGRlZmVyIHRvIHN1Yi1jb21wb25lbnRzLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGl0c05lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmhpdHNOZWVkZWREZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXBhcmVIaXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdoaXRzTmVlZGVkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oaXRzTm90TmVlZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhpdHNOZWVkZWREZXB0aCAmJiAhKC0tdGhpcy5oaXRzTmVlZGVkRGVwdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUhpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2hpdHNOb3ROZWVkZWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGNvb3JkaW5hdGVzIGZyb20gdGhlIHRvcGxlZnQgb2YgdGhlIGRvY3VtZW50LCByZXR1cm4gZGF0YSBhYm91dCB0aGUgZGF0ZS1yZWxhdGVkIGFyZWEgdW5kZXJuZWF0aC5cclxuICAgIC8vIENhbiByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXJiaXRyYXJ5IHByb3BlcnRpZXMgKGFsdGhvdWdoIHRvcC9yaWdodC9sZWZ0L2JvdHRvbSBhcmUgZW5jb3VyYWdlZCkuXHJcbiAgICAvLyBNdXN0IGhhdmUgYSBgZ3JpZGAgcHJvcGVydHksIGEgcmVmZXJlbmNlIHRvIHRoaXMgY3VycmVudCBncmlkLiBUT0RPOiBhdm9pZCB0aGlzXHJcbiAgICAvLyBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IGdldEhpdEZvb3RwcmludCBhbmQgZ2V0SGl0RWwuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW5CeVVpZCA9IHRoaXMuY2hpbGRyZW5CeVVpZDtcclxuICAgICAgICB2YXIgdWlkO1xyXG4gICAgICAgIHZhciBoaXQ7XHJcbiAgICAgICAgZm9yICh1aWQgaW4gY2hpbGRyZW5CeVVpZCkge1xyXG4gICAgICAgICAgICBoaXQgPSBjaGlsZHJlbkJ5VWlkW3VpZF0ucXVlcnlIaXQobGVmdE9mZnNldCwgdG9wT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpdDtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRTYWZlSGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciBmb290cHJpbnQgPSB0aGlzLmdldEhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShmb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvb3RwcmludDtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gd2hhdCBhYm91dCBiZWluZyBhYnN0cmFjdCE/XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gcG9zaXRpb24tbGV2ZWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlLXJlbGF0ZWQgYXJlYSB3aXRoaW4gdGhlIGdyaWQsXHJcbiAgICAvLyBzaG91bGQgcmV0dXJuIGEgalF1ZXJ5IGVsZW1lbnQgdGhhdCBiZXN0IHJlcHJlc2VudHMgaXQuIHBhc3NlZCB0byBkYXlDbGljayBjYWxsYmFjay5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIHdoYXQgYWJvdXQgYmVpbmcgYWJzdHJhY3QhP1xyXG4gICAgfTtcclxuICAgIC8qIENvbnZlcnRpbmcgZXZlbnRSYW5nZSAtPiBldmVudEZvb3RwcmludFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50UmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50Rm9vdHByaW50cy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMsIHRoaXMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHM7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gW3V0aWxfMi5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludChldmVudFJhbmdlKV07XHJcbiAgICB9O1xyXG4gICAgLyogQ29udmVydGluZyBjb21wb25lbnRGb290cHJpbnQvZXZlbnRGb290cHJpbnQgLT4gc2Vnc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50Rm9vdHByaW50c1RvU2VncyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMpIHtcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIHRoaXMuZXZlbnRGb290cHJpbnRUb1NlZ3MoZXZlbnRGb290cHJpbnRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFuIGV2ZW50J3Mgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIG1pc2MgZGF0YSksIGFuZCB0aGUgZXZlbnQgaXRzZWxmLFxyXG4gICAgLy8gc2xpY2VzIGludG8gc2VnbWVudHMgYW5kIGF0dGFjaGVzIGV2ZW50LWRlcml2ZWQgcHJvcGVydGllcyB0byB0aGVtLlxyXG4gICAgLy8gZXZlbnRTcGFuIC0geyBzdGFydCwgZW5kLCBpc1N0YXJ0LCBpc0VuZCwgb3RoZXJ0aGluZ3MuLi4gfVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlID0gZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgc2VncztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyhldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIGlmICghdW56b25lZFJhbmdlLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5pc1N0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1bnpvbmVkUmFuZ2UuaXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5pc0VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZy5mb290cHJpbnQgPSBldmVudEZvb3RwcmludDtcclxuICAgICAgICAgICAgLy8gVE9ETzogcmVuYW1lIHRvIHNlZy5ldmVudEZvb3RwcmludFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmNhbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5pdGVyQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGNoaWxkW21ldGhvZE5hbWVdLmFwcGx5KGNoaWxkLCBhcmdzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pdGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkJ5VWlkID0gdGhpcy5jaGlsZHJlbkJ5VWlkO1xyXG4gICAgICAgIHZhciB1aWQ7XHJcbiAgICAgICAgZm9yICh1aWQgaW4gY2hpbGRyZW5CeVVpZCkge1xyXG4gICAgICAgICAgICBmdW5jKGNoaWxkcmVuQnlVaWRbdWlkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLl9nZXRDYWxlbmRhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHQuY2FsZW5kYXIgfHwgdC52aWV3LmNhbGVuZGFyO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLl9nZXRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXc7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuX2dldERhdGVQcm9maWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWV3KCkuZ2V0KCdkYXRlUHJvZmlsZScpO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBIVE1MIGZvciBhbiBhbmNob3IgdG8gYW5vdGhlciB2aWV3IGludG8gdGhlIGNhbGVuZGFyLlxyXG4gICAgLy8gV2lsbCBlaXRoZXIgZ2VuZXJhdGUgYW4gPGE+IHRhZyBvciBhIG5vbi1jbGlja2FibGUgPHNwYW4+IHRhZywgZGVwZW5kaW5nIG9uIGVuYWJsZWQgc2V0dGluZ3MuXHJcbiAgICAvLyBgZ290b09wdGlvbnNgIGNhbiBlaXRoZXIgYmUgYSBtb21lbnQgaW5wdXQsIG9yIGFuIG9iamVjdCB3aXRoIHRoZSBmb3JtOlxyXG4gICAgLy8geyBkYXRlLCB0eXBlLCBmb3JjZU9mZiB9XHJcbiAgICAvLyBgdHlwZWAgaXMgYSB2aWV3LXR5cGUgbGlrZSBcImRheVwiIG9yIFwid2Vla1wiLiBkZWZhdWx0IHZhbHVlIGlzIFwiZGF5XCIuXHJcbiAgICAvLyBgYXR0cnNgIGFuZCBgaW5uZXJIdG1sYCBhcmUgdXNlIHRvIGdlbmVyYXRlIHRoZSByZXN0IG9mIHRoZSBIVE1MIHRhZy5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkR290b0FuY2hvckh0bWwgPSBmdW5jdGlvbiAoZ290b09wdGlvbnMsIGF0dHJzLCBpbm5lckh0bWwpIHtcclxuICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICB2YXIgdHlwZTtcclxuICAgICAgICB2YXIgZm9yY2VPZmY7XHJcbiAgICAgICAgdmFyIGZpbmFsT3B0aW9ucztcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGdvdG9PcHRpb25zKSkge1xyXG4gICAgICAgICAgICBkYXRlID0gZ290b09wdGlvbnMuZGF0ZTtcclxuICAgICAgICAgICAgdHlwZSA9IGdvdG9PcHRpb25zLnR5cGU7XHJcbiAgICAgICAgICAgIGZvcmNlT2ZmID0gZ290b09wdGlvbnMuZm9yY2VPZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRlID0gZ290b09wdGlvbnM7IC8vIGEgc2luZ2xlIG1vbWVudCBpbnB1dFxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlID0gbW9tZW50X2V4dF8xLmRlZmF1bHQoZGF0ZSk7IC8vIGlmIGEgc3RyaW5nLCBwYXJzZSBpdFxyXG4gICAgICAgIGZpbmFsT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZGF0ZTogZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZSB8fCAnZGF5J1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaW5uZXJIdG1sID0gYXR0cnM7XHJcbiAgICAgICAgICAgIGF0dHJzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXR0cnMgPSBhdHRycyA/ICcgJyArIHV0aWxfMS5hdHRyc1RvU3RyKGF0dHJzKSA6ICcnOyAvLyB3aWxsIGhhdmUgYSBsZWFkaW5nIHNwYWNlXHJcbiAgICAgICAgaW5uZXJIdG1sID0gaW5uZXJIdG1sIHx8ICcnO1xyXG4gICAgICAgIGlmICghZm9yY2VPZmYgJiYgdGhpcy5vcHQoJ25hdkxpbmtzJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8YScgKyBhdHRycyArXHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZ290bz1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShKU09OLnN0cmluZ2lmeShmaW5hbE9wdGlvbnMpKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgIGlubmVySHRtbCArXHJcbiAgICAgICAgICAgICAgICAnPC9hPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxzcGFuJyArIGF0dHJzICsgJz4nICtcclxuICAgICAgICAgICAgICAgIGlubmVySHRtbCArXHJcbiAgICAgICAgICAgICAgICAnPC9zcGFuPic7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEFsbERheUh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdhbGxEYXlIdG1sJykgfHwgdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5vcHQoJ2FsbERheVRleHQnKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgSFRNTCBjbGFzc05hbWVzIGZvciBhIHNpbmdsZS1kYXkgZWxlbWVudFxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGF5Q2xhc3NlcyA9IGZ1bmN0aW9uIChkYXRlLCBub1RoZW1lSGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcclxuICAgICAgICB2YXIgdG9kYXk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc0RhdGUoZGF0ZSkpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kaXNhYmxlZC1kYXknKTsgLy8gVE9ETzogalF1ZXJ5IFVJIHRoZW1lP1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy0nICsgdXRpbF8xLmRheUlEc1tkYXRlLmRheSgpXSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3LmlzRGF0ZUluT3RoZXJNb250aChkYXRlLCB0aGlzLmRhdGVQcm9maWxlKSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1vdGhlci1tb250aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvZGF5ID0gdmlldy5jYWxlbmRhci5nZXROb3coKTtcclxuICAgICAgICAgICAgaWYgKGRhdGUuaXNTYW1lKHRvZGF5LCAnZGF5JykpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtdG9kYXknKTtcclxuICAgICAgICAgICAgICAgIGlmIChub1RoZW1lSGlnaGxpZ2h0ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGUgPCB0b2RheSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1wYXN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWZ1dHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxpdHkgZm9yIGZvcm1hdHRpbmcgYSByYW5nZS4gQWNjZXB0cyBhIHJhbmdlIG9iamVjdCwgZm9ybWF0dGluZyBzdHJpbmcsIGFuZCBvcHRpb25hbCBzZXBhcmF0b3IuXHJcbiAgICAvLyBEaXNwbGF5cyBhbGwtZGF5IHJhbmdlcyBuYXR1cmFsbHksIHdpdGggYW4gaW5jbHVzaXZlIGVuZC4gVGFrZXMgdGhlIGN1cnJlbnQgaXNSVEwgaW50byBhY2NvdW50LlxyXG4gICAgLy8gVGhlIHRpbWV6b25lcyBvZiB0aGUgZGF0ZXMgd2l0aGluIGByYW5nZWAgd2lsbCBiZSByZXNwZWN0ZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgaXNBbGxEYXksIGZvcm1hdFN0ciwgc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcclxuICAgICAgICBpZiAoaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgZW5kID0gZW5kLmNsb25lKCkuc3VidHJhY3QoMSk7IC8vIGNvbnZlcnQgdG8gaW5jbHVzaXZlLiBsYXN0IG1zIG9mIHByZXZpb3VzIGRheVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZV9mb3JtYXR0aW5nXzEuZm9ybWF0UmFuZ2UocmFuZ2Uuc3RhcnQsIGVuZCwgZm9ybWF0U3RyLCBzZXBhcmF0b3IsIHRoaXMuaXNSVEwpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiB0aGUgZ2l2ZSB1bml0cyBpbiB0aGUgXCJjdXJyZW50XCIgcmFuZ2UuXHJcbiAgICAvLyBXaWxsIHJldHVybiBhIGZsb2F0aW5nLXBvaW50IG51bWJlci4gV29uJ3Qgcm91bmQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50UmFuZ2VBcyA9IGZ1bmN0aW9uICh1bml0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERhdGVQcm9maWxlKCkuY3VycmVudFVuem9uZWRSYW5nZS5hcyh1bml0KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBkYXRlIHJhbmdlIG9mIHRoZSBmdWxsIGRheXMgdGhlIGdpdmVuIHJhbmdlIHZpc3VhbGx5IGFwcGVhcnMgdG8gb2NjdXB5LlxyXG4gICAgLy8gUmV0dXJucyBhIHBsYWluIG9iamVjdCB3aXRoIHN0YXJ0L2VuZCwgTk9UIGFuIFVuem9uZWRSYW5nZSFcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmNvbXB1dGVEYXlSYW5nZSA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLl9nZXRDYWxlbmRhcigpO1xyXG4gICAgICAgIHZhciBzdGFydERheSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodW56b25lZFJhbmdlLnN0YXJ0TXMsIHRydWUpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xyXG4gICAgICAgIHZhciBlbmQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KHVuem9uZWRSYW5nZS5lbmRNcyk7XHJcbiAgICAgICAgdmFyIGVuZFRpbWVNUyA9ICtlbmQudGltZSgpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXHJcbiAgICAgICAgdmFyIGVuZERheSA9IGVuZC5jbG9uZSgpLnN0cmlwVGltZSgpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIGV4Y2x1c2l2ZWx5IGVuZHNcclxuICAgICAgICAvLyBJZiB0aGUgZW5kIHRpbWUgaXMgYWN0dWFsbHkgaW5jbHVzaXZlbHkgcGFydCBvZiB0aGUgbmV4dCBkYXkgYW5kIGlzIGVxdWFsIHRvIG9yXHJcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxyXG4gICAgICAgIGlmIChlbmRUaW1lTVMgJiYgZW5kVGltZU1TID49IHRoaXMubmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICBlbmREYXkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXHJcbiAgICAgICAgaWYgKGVuZERheSA8PSBzdGFydERheSkge1xyXG4gICAgICAgICAgICBlbmREYXkgPSBzdGFydERheS5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XHJcbiAgICB9O1xyXG4gICAgLy8gRG9lcyB0aGUgZ2l2ZW4gcmFuZ2UgdmlzdWFsbHkgYXBwZWFyIHRvIG9jY3VweSBtb3JlIHRoYW4gb25lIGRheT9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzTXVsdGlEYXlSYW5nZSA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgZGF5UmFuZ2UgPSB0aGlzLmNvbXB1dGVEYXlSYW5nZSh1bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHJldHVybiBkYXlSYW5nZS5lbmQuZGlmZihkYXlSYW5nZS5zdGFydCwgJ2RheXMnKSA+IDE7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5ndWlkID0gMDsgLy8gVE9ETzogYmV0dGVyIHN5c3RlbSBmb3IgdGhpcz9cclxuICAgIHJldHVybiBEYXRlQ29tcG9uZW50O1xyXG59KENvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZUNvbXBvbmVudDtcclxuLy8gbGVnYWN5XHJcbmZ1bmN0aW9uIGNvbnZlcnRFdmVudHNQYXlsb2FkVG9MZWdhY3lBcnJheShldmVudHNQYXlsb2FkKSB7XHJcbiAgICB2YXIgZXZlbnREZWZJZDtcclxuICAgIHZhciBldmVudEluc3RhbmNlcztcclxuICAgIHZhciBsZWdhY3lFdmVudHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChldmVudERlZklkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICBldmVudEluc3RhbmNlcyA9IGV2ZW50c1BheWxvYWRbZXZlbnREZWZJZF0uZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeUV2ZW50cy5wdXNoKGV2ZW50SW5zdGFuY2VzW2ldLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWdhY3lFdmVudHM7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxudmFyIEl0ZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOCk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgVG9vbGJhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzkpO1xyXG52YXIgT3B0aW9uc01hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQwKTtcclxudmFyIFZpZXdTcGVjTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDEpO1xyXG52YXIgQ29uc3RyYWludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA3KTtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEV2ZW50TWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDIpO1xyXG52YXIgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMik7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBFdmVudERlZlBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFdmVudERlZk11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgVGhlbWVSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XHJcbnZhciBDYWxlbmRhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhbGVuZGFyKGVsLCBvdmVycmlkZXMpIHtcclxuICAgICAgICB0aGlzLmxvYWRpbmdMZXZlbCA9IDA7IC8vIG51bWJlciBvZiBzaW11bHRhbmVvdXMgbG9hZGluZyB0YXNrc1xyXG4gICAgICAgIHRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoID0gMDtcclxuICAgICAgICAvLyBkZWNsYXJlIHRoZSBjdXJyZW50IGNhbGVuZGFyIGluc3RhbmNlIHJlbGllcyBvbiBHbG9iYWxFbWl0dGVyLiBuZWVkZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cclxuICAgICAgICAvLyB1bm5lZWRlZCgpIGlzIGNhbGxlZCBpbiBkZXN0cm95LlxyXG4gICAgICAgIEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0Lm5lZWRlZCgpO1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLnZpZXdzQnlUeXBlID0ge307XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlciA9IG5ldyBPcHRpb25zTWFuYWdlcl8xLmRlZmF1bHQodGhpcywgb3ZlcnJpZGVzKTtcclxuICAgICAgICB0aGlzLnZpZXdTcGVjTWFuYWdlciA9IG5ldyBWaWV3U3BlY01hbmFnZXJfMS5kZWZhdWx0KHRoaXMub3B0aW9uc01hbmFnZXIsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdE1vbWVudEludGVybmFscygpOyAvLyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgb3B0aW9ucyBoYXNoIGluaXRpYWxpemVkXHJcbiAgICAgICAgdGhpcy5pbml0Q3VycmVudERhdGUoKTtcclxuICAgICAgICB0aGlzLmluaXRFdmVudE1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gbmV3IENvbnN0cmFpbnRzXzEuZGVmYXVsdCh0aGlzLmV2ZW50TWFuYWdlciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RlZCgpO1xyXG4gICAgfVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbnN0cnVjdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHVzZWZ1bCBmb3IgbW9ua2V5cGF0Y2hpbmcuIHVzZWQ/XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIHRyaWdnZXJJbmZvKSB7XHJcbiAgICAgICAgdmFyIG9wdEhhbmRsZXIgPSB0aGlzLm9wdChuYW1lKTtcclxuICAgICAgICB2YXIgY29udGV4dDtcclxuICAgICAgICB2YXIgYXJncztcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHRyaWdnZXJJbmZvKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gdHJpZ2dlckluZm8uY29udGV4dDtcclxuICAgICAgICAgICAgYXJncyA9IHRyaWdnZXJJbmZvLmFyZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNBcnJheSh0cmlnZ2VySW5mbykpIHtcclxuICAgICAgICAgICAgYXJncyA9IHRyaWdnZXJJbmZvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmVsWzBdOyAvLyBmYWxsYmFjayBjb250ZXh0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJncykge1xyXG4gICAgICAgICAgICBhcmdzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcldpdGgobmFtZSwgY29udGV4dCwgYXJncyk7IC8vIEVtaXR0ZXIncyBtZXRob2RcclxuICAgICAgICBpZiAob3B0SGFuZGxlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0SGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmhhc1B1YmxpY0hhbmRsZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNIYW5kbGVycyhuYW1lKSB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdChuYW1lKTsgLy8gaGFuZGxlciBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIC8vIE9wdGlvbnMgUHVibGljIEFQSVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHB1YmxpYyBnZXR0ZXIvc2V0dGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG5ld09wdGlvbkhhc2g7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uSGFzaFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5hZGQobmV3T3B0aW9uSGFzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIuYWRkKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBwcml2YXRlIGdldHRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIFZpZXdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBHaXZlbiBhIHZpZXcgbmFtZSBmb3IgYSBjdXN0b20gdmlldyBvciBhIHN0YW5kYXJkIHZpZXcsIGNyZWF0ZXMgYSByZWFkeS10by1nbyBWaWV3IG9iamVjdFxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluc3RhbnRpYXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBzcGVjID0gdGhpcy52aWV3U3BlY01hbmFnZXIuZ2V0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIGlmICghc3BlYykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3IHR5cGUgXFxcIlwiICsgdmlld1R5cGUgKyBcIlxcXCIgaXMgbm90IHZhbGlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IHNwZWNbJ2NsYXNzJ10odGhpcywgc3BlYyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgdmlldyBpcyBva2F5IHRvIGluc3RhbnRpYXRlIGF0IHNvbWUgcG9pbnRcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc1ZhbGlkVmlld1R5cGUgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyh2aWV3VHlwZSkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jaGFuZ2VWaWV3ID0gZnVuY3Rpb24gKHZpZXdOYW1lLCBkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnJlY29yZE92ZXJyaWRlcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVJhbmdlOiBkYXRlT3JSYW5nZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGF0ZU9yUmFuZ2UpLnN0cmlwWm9uZSgpOyAvLyBqdXN0IGxpa2UgZ290b0RhdGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcodmlld05hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS56b29tVG8gPSBmdW5jdGlvbiAobmV3RGF0ZSwgdmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgc3BlYztcclxuICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXHJcbiAgICAgICAgc3BlYyA9IHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKHZpZXdUeXBlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBuZXdEYXRlLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KHNwZWMgPyBzcGVjLnR5cGUgOiBudWxsKTtcclxuICAgIH07XHJcbiAgICAvLyBDdXJyZW50IERhdGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdEN1cnJlbnREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWZhdWx0RGF0ZUlucHV0ID0gdGhpcy5vcHQoJ2RlZmF1bHREYXRlJyk7XHJcbiAgICAgICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXHJcbiAgICAgICAgaWYgKGRlZmF1bHREYXRlSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGVmYXVsdERhdGVJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBwcmV2SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAocHJldkluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gcHJldkluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBuZXh0SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAobmV4dEluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gbmV4dEluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2WWVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlLmFkZCgtMSwgJ3llYXJzJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKDEsICd5ZWFycycpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gc2hvdWxkIGRlbnkgbGlrZSBwcmV2L25leHQ/XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdvdG9EYXRlID0gZnVuY3Rpb24gKHpvbmVkRGF0ZUlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9IHRoaXMubW9tZW50KHpvbmVkRGF0ZUlucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5jcmVtZW50RGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKG1vbWVudC5kdXJhdGlvbihkZWx0YSkpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIC8vIGZvciBleHRlcm5hbCBBUElcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VGltZXpvbmUodGhpcy5jdXJyZW50RGF0ZSk7IC8vIGluZnVzZSB0aGUgY2FsZW5kYXIncyB0aW1lem9uZVxyXG4gICAgfTtcclxuICAgIC8vIExvYWRpbmcgVHJpZ2dlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGJlZ2luc1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnB1c2hMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMubG9hZGluZ0xldmVsKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW3RydWUsIHRoaXMudmlld10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYW55IHR5cGUgb2YgYXN5bmMgZGF0YSBmZXRjaGluZyBjb21wbGV0ZXNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wb3BMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKC0tdGhpcy5sb2FkaW5nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW2ZhbHNlLCB0aGlzLnZpZXddKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RWwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICAvLyBtYWlubHkgZm9yIHRoZSBwdWJsaWMgQVBJXHJcbiAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3U2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdGlhbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgZWwuYWRkQ2xhc3MoJ2ZjJyk7XHJcbiAgICAgICAgLy8gZXZlbnQgZGVsZWdhdGlvbiBmb3IgbmF2IGxpbmtzXHJcbiAgICAgICAgZWwub24oJ2NsaWNrLmZjJywgJ2FbZGF0YS1nb3RvXScsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgZ290b09wdGlvbnMgPSBhbmNob3JFbC5kYXRhKCdnb3RvJyk7IC8vIHdpbGwgYXV0b21hdGljYWxseSBwYXJzZSBKU09OXHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gX3RoaXMubW9tZW50KGdvdG9PcHRpb25zLmRhdGUpO1xyXG4gICAgICAgICAgICB2YXIgdmlld1R5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSBsaWtlIFwibmF2TGlua0RheUNsaWNrXCIuIG1pZ2h0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IF90aGlzLnZpZXcub3B0KCduYXZMaW5rJyArIHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIodmlld1R5cGUpICsgJ0NsaWNrJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24oZGF0ZSwgZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUgPSBjdXN0b21BY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy56b29tVG8oZGF0ZSwgdmlld1R5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnc2V0dGluZ1RoZW1lJywgWyc/dGhlbWUnLCAnP3RoZW1lU3lzdGVtJ10sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGVtZUNsYXNzID0gVGhlbWVSZWdpc3RyeV8xLmdldFRoZW1lU3lzdGVtQ2xhc3Mob3B0cy50aGVtZVN5c3RlbSB8fCBvcHRzLnRoZW1lKTtcclxuICAgICAgICAgICAgdmFyIHRoZW1lID0gbmV3IHRoZW1lQ2xhc3MoX3RoaXMub3B0aW9uc01hbmFnZXIpO1xyXG4gICAgICAgICAgICB2YXIgd2lkZ2V0Q2xhc3MgPSB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Jyk7XHJcbiAgICAgICAgICAgIF90aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXRDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3Mod2lkZ2V0Q2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkZ2V0Q2xhc3MgPSBfdGhpcy50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Jyk7XHJcbiAgICAgICAgICAgIF90aGlzLnRoZW1lID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHdpZGdldENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyh3aWRnZXRDbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdzZXR0aW5nQnVzaW5lc3NIb3VyR2VuZXJhdG9yJywgWyc/YnVzaW5lc3NIb3VycyddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBuZXcgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEuZGVmYXVsdChkZXBzLmJ1c2luZXNzSG91cnMsIF90aGlzKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuc2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InLCBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHVwb24gb3B0aW9uIGNoYW5nZS5cclxuICAgICAgICAvLyBIQUNLOiBsb2NhbGUgb2Z0ZW4gYWZmZWN0cyBpc1JUTCwgc28gd2UgZXhwbGljaXRseSBsaXN0ZW4gdG8gdGhhdCB0b28uXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnYXBwbHlpbmdEaXJDbGFzc2VzJywgWyc/aXNSVEwnLCAnP2xvY2FsZSddLCBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgICAgICBlbC50b2dnbGVDbGFzcygnZmMtbHRyJywgIW9wdHMuaXNSVEwpO1xyXG4gICAgICAgICAgICBlbC50b2dnbGVDbGFzcygnZmMtcnRsJywgb3B0cy5pc1JUTCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdmlldy1jb250YWluZXInLz5cIikucHJlcGVuZFRvKGVsKTtcclxuICAgICAgICB0aGlzLmluaXRUb29sYmFycygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVySGVhZGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGb290ZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcodGhpcy5vcHQoJ2RlZmF1bHRWaWV3JykpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnaGFuZGxlV2luZG93UmVzaXplJykpIHtcclxuICAgICAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZSh0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gdXRpbF8xLmRlYm91bmNlKC8vIHByZXZlbnRzIHJhcGlkIGNhbGxzXHJcbiAgICAgICAgICAgIHRoaXMud2luZG93UmVzaXplLmJpbmQodGhpcyksIHRoaXMub3B0KCd3aW5kb3dSZXNpemVEZWxheScpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCdyZW1vdmVFbGVtZW50Jyk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVDbGFzcygnZmMgZmMtbHRyIGZjLXJ0bCcpO1xyXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlbWUtcmVsYXRlZCByb290IGNsYXNzTmFtZVxyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIudW53YXRjaCgnc2V0dGluZ1RoZW1lJyk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci51bndhdGNoKCdzZXR0aW5nQnVzaW5lc3NIb3VyR2VuZXJhdG9yJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJy5mYycpOyAvLyB1bmJpbmQgbmF2IGxpbmsgaGFuZGxlcnNcclxuICAgICAgICBpZiAodGhpcy53aW5kb3dSZXNpemVQcm94eSkge1xyXG4gICAgICAgICAgICAkKHdpbmRvdykudW5iaW5kKCdyZXNpemUnLCB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dSZXNpemVQcm94eSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LnVubmVlZGVkKCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmVsZW1lbnRWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsLmlzKCc6dmlzaWJsZScpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlciBRdWV1ZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5iaW5kVmlld0hhbmRsZXJzID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZpZXcud2F0Y2goJ3RpdGxlRm9yQ2FsZW5kYXInLCBbJ3RpdGxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3ID09PSBfdGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRUb29sYmFyc1RpdGxlKGRlcHMudGl0bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmlldy53YXRjaCgnZGF0ZVByb2ZpbGVGb3JDYWxlbmRhcicsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgaWYgKHZpZXcgPT09IF90aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnREYXRlID0gZGVwcy5kYXRlUHJvZmlsZS5kYXRlOyAvLyBtaWdodCBoYXZlIGJlZW4gY29uc3RyYWluZWQgYnkgdmlldyBkYXRlc1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVG9vbGJhckJ1dHRvbnMoZGVwcy5kYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudW5iaW5kVmlld0hhbmRsZXJzID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2aWV3LnVud2F0Y2goJ3RpdGxlRm9yQ2FsZW5kYXInKTtcclxuICAgICAgICB2aWV3LnVud2F0Y2goJ2RhdGVQcm9maWxlRm9yQ2FsZW5kYXInKTtcclxuICAgIH07XHJcbiAgICAvLyBWaWV3IFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aWV3IGJlY2F1c2Ugb2YgYSBkYXRlIGNoYW5nZSwgdmlldy10eXBlIGNoYW5nZSwgb3IgZm9yIHRoZSBmaXJzdCB0aW1lLlxyXG4gICAgLy8gSWYgbm90IGdpdmVuIGEgdmlld1R5cGUsIGtlZXAgdGhlIGN1cnJlbnQgdmlldyBidXQgcmVuZGVyIGRpZmZlcmVudCBkYXRlcy5cclxuICAgIC8vIEFjY2VwdHMgYW4gb3B0aW9uYWwgc2Nyb2xsIHN0YXRlIHRvIHJlc3RvcmUgdG8uXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBvbGRWaWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBuZXdWaWV3O1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIGlmIChvbGRWaWV3ICYmIHZpZXdUeXBlICYmIG9sZFZpZXcudHlwZSAhPT0gdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdmlld1R5cGUgY2hhbmdlZCwgb3IgdGhlIHZpZXcgd2FzIG5ldmVyIGNyZWF0ZWQsIGNyZWF0ZSBhIGZyZXNoIHZpZXdcclxuICAgICAgICBpZiAoIXRoaXMudmlldyAmJiB2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICBuZXdWaWV3ID0gdGhpcy52aWV3ID1cclxuICAgICAgICAgICAgICAgIHRoaXMudmlld3NCeVR5cGVbdmlld1R5cGVdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudmlld3NCeVR5cGVbdmlld1R5cGVdID0gdGhpcy5pbnN0YW50aWF0ZVZpZXcodmlld1R5cGUpKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kVmlld0hhbmRsZXJzKG5ld1ZpZXcpO1xyXG4gICAgICAgICAgICBuZXdWaWV3LnN0YXJ0QmF0Y2hSZW5kZXIoKTsgLy8gc28gdGhhdCBzZXRFbGVtZW50K3NldERhdGUgcmVuZGVyaW5nIGFyZSBqb2luZWRcclxuICAgICAgICAgICAgbmV3Vmlldy5zZXRFbGVtZW50KCQoXCI8ZGl2IGNsYXNzPSdmYy12aWV3IGZjLVwiICsgdmlld1R5cGUgKyBcIi12aWV3JyAvPlwiKS5hcHBlbmRUbyh0aGlzLmNvbnRlbnRFbCkpO1xyXG4gICAgICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ2FjdGl2YXRlQnV0dG9uJywgdmlld1R5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIC8vIHByZXZlbnQgdW5uZWNlc3NhcnkgY2hhbmdlIGZpcmluZ1xyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmdldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJykgIT09IHRoaXMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InLCB0aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52aWV3LnNldERhdGUodGhpcy5jdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3LnN0b3BCYXRjaFJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGhhd0NvbnRlbnRIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgdGhlIGN1cnJlbnQgdmlldyBhbmQgcmVmbGVjdHMgdGhpcyBjaGFuZ2UgaW4gdGhlIEhlYWRlci5cclxuICAgIC8vIFVucmVnc2l0ZXJzIHRoZSBgdmlld2AsIGJ1dCBkb2VzIG5vdCByZW1vdmUgZnJvbSB2aWV3QnlUeXBlIGhhc2guXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY2xlYXJWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50VmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ2RlYWN0aXZhdGVCdXR0b24nLCBjdXJyZW50Vmlldy50eXBlKTtcclxuICAgICAgICB0aGlzLnVuYmluZFZpZXdIYW5kbGVycyhjdXJyZW50Vmlldyk7XHJcbiAgICAgICAgY3VycmVudFZpZXcucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIGN1cnJlbnRWaWV3LnVuc2V0RGF0ZSgpOyAvLyBzbyBiaW5kVmlld0hhbmRsZXJzIGRvZXNuJ3QgZmlyZSB3aXRoIG9sZCB2YWx1ZXMgbmV4dCB0aW1lXHJcbiAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBEZXN0cm95cyB0aGUgdmlldywgaW5jbHVkaW5nIHRoZSB2aWV3IG9iamVjdC4gVGhlbiwgcmUtaW5zdGFudGlhdGVzIGl0IGFuZCByZW5kZXJzIGl0LlxyXG4gICAgLy8gTWFpbnRhaW5zIHRoZSBzYW1lIHNjcm9sbCBzdGF0ZS5cclxuICAgIC8vIFRPRE86IG1haW50YWluIGFueSBvdGhlciB1c2VyLW1hbmlwdWxhdGVkIHN0YXRlLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlaW5pdFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9sZFZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHNjcm9sbCA9IG9sZFZpZXcucXVlcnlTY3JvbGwoKTsgLy8gd291bGRuJ3QgYmUgc28gY29tcGxpY2F0ZWQgaWYgQ2FsZW5kYXIgb3duZWQgdGhlIHNjcm9sbFxyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldyhvbGRWaWV3LnR5cGUpOyAvLyBuZWVkcyB0aGUgdHlwZSB0byBmcmVzaGx5IHJlbmRlclxyXG4gICAgICAgIHRoaXMudmlldy5hcHBseVNjcm9sbChzY3JvbGwpO1xyXG4gICAgICAgIHRoaXMudGhhd0NvbnRlbnRIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXNpemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGNTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmlzSGVpZ2h0QXV0byA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2NvbnRlbnRIZWlnaHQnKSA9PT0gJ2F1dG8nIHx8IHRoaXMub3B0KCdoZWlnaHQnKSA9PT0gJ2F1dG8nO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVWaWV3U2l6ZSA9IGZ1bmN0aW9uIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgIGlmIChpc1Jlc2l6ZSA9PT0gdm9pZCAwKSB7IGlzUmVzaXplID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgc2Nyb2xsO1xyXG4gICAgICAgIGlmICghdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZSAmJiB2aWV3KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsID0gdmlldy5xdWVyeVNjcm9sbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUrKztcclxuICAgICAgICAgICAgdmlldy51cGRhdGVTaXplKHRoaXMuZ2V0U3VnZ2VzdGVkVmlld0hlaWdodCgpLCB0aGlzLmlzSGVpZ2h0QXV0bygpLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUtLTtcclxuICAgICAgICAgICAgaWYgKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmFwcGx5U2Nyb2xsKHNjcm9sbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHNpZ25hbCBzdWNjZXNzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jYWxjU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50VmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGNTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5fY2FsY1NpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRIZWlnaHRJbnB1dCA9IHRoaXMub3B0KCdjb250ZW50SGVpZ2h0Jyk7XHJcbiAgICAgICAgdmFyIGhlaWdodElucHV0ID0gdGhpcy5vcHQoJ2hlaWdodCcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudEhlaWdodElucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBjb250ZW50SGVpZ2h0SW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhlaWdodElucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGhlaWdodElucHV0KCkgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGVpZ2h0SW5wdXQgPT09ICdwYXJlbnQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IHRoaXMuZWwucGFyZW50KCkuaGVpZ2h0KCkgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IE1hdGgucm91bmQodGhpcy5jb250ZW50RWwud2lkdGgoKSAvXHJcbiAgICAgICAgICAgICAgICBNYXRoLm1heCh0aGlzLm9wdCgnYXNwZWN0UmF0aW8nKSwgLjUpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLndpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvLyB0aGUgcHVycG9zZTogc28gd2UgZG9uJ3QgcHJvY2VzcyBqcXVpIFwicmVzaXplXCIgZXZlbnRzIHRoYXQgaGF2ZSBidWJibGVkIHVwXHJcbiAgICAgICAgLy8gY2FzdCB0byBhbnkgYmVjYXVzZSAudGFyZ2V0LCB3aGljaCBpcyBFbGVtZW50LCBjYW4ndCBiZSBjb21wYXJlZCB0byB3aW5kb3cgZm9yIHNvbWUgcmVhc29uLlxyXG4gICAgICAgIGV2LnRhcmdldCA9PT0gd2luZG93ICYmXHJcbiAgICAgICAgICAgIHRoaXMudmlldyAmJlxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuaXNEYXRlc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZVZpZXdTaXplKHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignd2luZG93UmVzaXplJywgW3RoaXMudmlld10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEhlaWdodCBcIkZyZWV6aW5nXCJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mcmVlemVDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VGcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb3JjZUZyZWV6ZUNvbnRlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuY3NzKHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRlbnRFbC5oZWlnaHQoKSxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnRoYXdDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoLS07XHJcbiAgICAgICAgLy8gYWx3YXlzIGJyaW5nIGJhY2sgdG8gbmF0dXJhbCBoZWlnaHRcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5jc3Moe1xyXG4gICAgICAgICAgICB3aWR0aDogJycsXHJcbiAgICAgICAgICAgIGhlaWdodDogJycsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGJ1dCBpZiB0aGVyZSBhcmUgZnV0dXJlIHRoYXdzLCByZS1mcmVlemVcclxuICAgICAgICBpZiAodGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JjZUZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVG9vbGJhclxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0VG9vbGJhcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgVG9vbGJhcl8xLmRlZmF1bHQodGhpcywgdGhpcy5jb21wdXRlSGVhZGVyT3B0aW9ucygpKTtcclxuICAgICAgICB0aGlzLmZvb3RlciA9IG5ldyBUb29sYmFyXzEuZGVmYXVsdCh0aGlzLCB0aGlzLmNvbXB1dGVGb290ZXJPcHRpb25zKCkpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyID0gbmV3IEl0ZXJhdG9yXzEuZGVmYXVsdChbdGhpcy5oZWFkZXIsIHRoaXMuZm9vdGVyXSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXB1dGVIZWFkZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NlczogJ2ZjLWhlYWRlci10b29sYmFyJyxcclxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLm9wdCgnaGVhZGVyJylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jb21wdXRlRm9vdGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBleHRyYUNsYXNzZXM6ICdmYy1mb290ZXItdG9vbGJhcicsXHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5vcHQoJ2Zvb3RlcicpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIEhlYWRlciB3aWxsIHJlcmVuZGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcjtcclxuICAgICAgICBoZWFkZXIuc2V0VG9vbGJhck9wdGlvbnModGhpcy5jb21wdXRlSGVhZGVyT3B0aW9ucygpKTtcclxuICAgICAgICBoZWFkZXIucmVuZGVyKCk7XHJcbiAgICAgICAgaWYgKGhlYWRlci5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnByZXBlbmQoaGVhZGVyLmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBGb290ZXIgd2lsbCByZXJlbmRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckZvb3RlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZm9vdGVyID0gdGhpcy5mb290ZXI7XHJcbiAgICAgICAgZm9vdGVyLnNldFRvb2xiYXJPcHRpb25zKHRoaXMuY29tcHV0ZUZvb3Rlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgZm9vdGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGlmIChmb290ZXIuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmQoZm9vdGVyLmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldFRvb2xiYXJzVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3VwZGF0ZVRpdGxlJywgdGl0bGUpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVUb29sYmFyQnV0dG9ucyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBub3cgPSB0aGlzLmdldE5vdygpO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciB0b2RheUluZm8gPSB2aWV3LmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdyk7XHJcbiAgICAgICAgdmFyIHByZXZJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIHZhciBuZXh0SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoKHRvZGF5SW5mby5pc1ZhbGlkICYmICFkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShub3cpKSA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAndG9kYXknKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwocHJldkluZm8uaXNWYWxpZCA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAncHJldicpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbChuZXh0SW5mby5pc1ZhbGlkID9cclxuICAgICAgICAgICAgJ2VuYWJsZUJ1dHRvbicgOlxyXG4gICAgICAgICAgICAnZGlzYWJsZUJ1dHRvbicsICduZXh0Jyk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnF1ZXJ5VG9vbGJhcnNIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhcnNNYW5hZ2VyLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIHRvb2xiYXIpIHtcclxuICAgICAgICAgICAgdmFyIHRvb2xiYXJIZWlnaHQgPSB0b29sYmFyLmVsID8gdG9vbGJhci5lbC5vdXRlckhlaWdodCh0cnVlKSA6IDA7IC8vIGluY2x1ZGVzIG1hcmdpblxyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyB0b29sYmFySGVpZ2h0O1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuICAgIC8vIFNlbGVjdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHRoaXMgcHVibGljIG1ldGhvZCByZWNlaXZlcyBzdGFydC9lbmQgZGF0ZXMgaW4gYW55IGZvcm1hdCwgd2l0aCBhbnkgdGltZXpvbmVcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoem9uZWRTdGFydElucHV0LCB6b25lZEVuZElucHV0KSB7XHJcbiAgICAgICAgdGhpcy52aWV3LnNlbGVjdCh0aGlzLmJ1aWxkU2VsZWN0Rm9vdHByaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy51bnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhcmd1bWVudHMgdG8gdGhlIHNlbGVjdCBtZXRob2QgaW4gdGhlIEFQSSwgcmV0dXJucyBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBpbmZvKVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmJ1aWxkU2VsZWN0Rm9vdHByaW50ID0gZnVuY3Rpb24gKHpvbmVkU3RhcnRJbnB1dCwgem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMubW9tZW50KHpvbmVkU3RhcnRJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAoem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLm1vbWVudCh6b25lZEVuZElucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpLCAhc3RhcnQuaGFzVGltZSgpKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluaXRNb21lbnRJbnRlcm5hbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbicpKTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ2RlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24nKSk7XHJcbiAgICAgICAgLy8gQ2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgd2hlbiBhbnkgb2YgdGhlIG9wdGlvbnMgY2hhbmdlLlxyXG4gICAgICAgIC8vIEhhcHBlbnMgYmVmb3JlIGFueSBpbnRlcm5hbCBvYmplY3RzIHJlYnVpbGQgb3IgcmVyZW5kZXIsIGJlY2F1c2UgdGhpcyBpcyB2ZXJ5IGNvcmUuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnYnVpbGRpbmdNb21lbnRMb2NhbGUnLCBbXHJcbiAgICAgICAgICAgICc/bG9jYWxlJywgJz9tb250aE5hbWVzJywgJz9tb250aE5hbWVzU2hvcnQnLCAnP2RheU5hbWVzJywgJz9kYXlOYW1lc1Nob3J0JyxcclxuICAgICAgICAgICAgJz9maXJzdERheScsICc/d2Vla051bWJlckNhbGN1bGF0aW9uJ1xyXG4gICAgICAgIF0sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPSBvcHRzLndlZWtOdW1iZXJDYWxjdWxhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGZpcnN0RGF5ID0gb3B0cy5maXJzdERheTtcclxuICAgICAgICAgICAgdmFyIF93ZWVrO1xyXG4gICAgICAgICAgICAvLyBub3JtYWxpemVcclxuICAgICAgICAgICAgaWYgKHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2lzbycpIHtcclxuICAgICAgICAgICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9ICdJU08nOyAvLyBub3JtYWxpemVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbG9jYWxlRGF0YSA9IE9iamVjdC5jcmVhdGUoLy8gbWFrZSBhIGNoZWFwIGNvcHlcclxuICAgICAgICAgICAgbG9jYWxlXzEuZ2V0TW9tZW50TG9jYWxlRGF0YShvcHRzLmxvY2FsZSkgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKG9wdHMubW9udGhOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fbW9udGhzID0gb3B0cy5tb250aE5hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRzLm1vbnRoTmFtZXNTaG9ydCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fbW9udGhzU2hvcnQgPSBvcHRzLm1vbnRoTmFtZXNTaG9ydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0cy5kYXlOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fd2Vla2RheXMgPSBvcHRzLmRheU5hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmRheU5hbWVzU2hvcnQpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWtkYXlzU2hvcnQgPSBvcHRzLmRheU5hbWVzU2hvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpcnN0RGF5ID09IG51bGwgJiYgd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgZmlyc3REYXkgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaXJzdERheSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfd2VlayA9IE9iamVjdC5jcmVhdGUobG9jYWxlRGF0YS5fd2Vlayk7IC8vIF93ZWVrOiB7IGRvdzogIyB9XHJcbiAgICAgICAgICAgICAgICBfd2Vlay5kb3cgPSBmaXJzdERheTtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWsgPSBfd2VlaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJyB8fFxyXG4gICAgICAgICAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnbG9jYWwnIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGMgPSB3ZWVrTnVtYmVyQ2FsY3VsYXRpb247IC8vIG1vbWVudC1leHQgd2lsbCBrbm93IHdoYXQgdG8gZG8gd2l0aCBpdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaW50ZXJuYWwgY3VycmVudCBkYXRlIG9iamVjdCBhbHJlYWR5IGV4aXN0cywgbW92ZSB0byBuZXcgbG9jYWxlLlxyXG4gICAgICAgICAgICAvLyBXZSBkbyBOT1QgbmVlZCB0byBkbyB0aGlzIHRlY2huaXF1ZSBmb3IgZXZlbnQgZGF0ZXMsIGJlY2F1c2UgdGhpcyBoYXBwZW5zIHdoZW4gY29udmVydGluZyB0byBcInNlZ21lbnRzXCIuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50RGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9jYWxpemVNb21lbnQoX3RoaXMuY3VycmVudERhdGUpOyAvLyBzZXRzIHRvIGxvY2FsZURhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIG1vbWVudCB1c2luZyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGN1cnJlbnQgY2FsZW5kYXI6IHRpbWV6b25lIGFuZCBsb2NhbGUuXHJcbiAgICAvLyBBY2NlcHRzIGFueXRoaW5nIHRoZSB2YW5pbGxhIG1vbWVudCgpIGNvbnN0cnVjdG9yIGFjY2VwdHMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubW9tZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9tO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgndGltZXpvbmUnKSA9PT0gJ2xvY2FsJykge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIG1vbWVudCB0byBiZSBsb2NhbCwgYmVjYXVzZSBtb21lbnRFeHQgZG9lc24ndCBndWFyYW50ZWUgaXQuXHJcbiAgICAgICAgICAgIGlmIChtb20uaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtb20ubG9jYWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdCgndGltZXpvbmUnKSA9PT0gJ1VUQycpIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjLmFwcGx5KG51bGwsIGFyZ3MpOyAvLyBwcm9jZXNzIGFzIFVUQ1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQucGFyc2Vab25lLmFwcGx5KG51bGwsIGFyZ3MpOyAvLyBsZXQgdGhlIGlucHV0IGRlY2lkZSB0aGUgem9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7IC8vIFRPRE9cclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tc1RvTW9tZW50ID0gZnVuY3Rpb24gKG1zLCBmb3JjZUFsbERheSkge1xyXG4gICAgICAgIHZhciBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMobXMpOyAvLyBUT0RPOiBvcHRpbWl6ZSBieSB1c2luZyBEYXRlLlVUQ1xyXG4gICAgICAgIGlmIChmb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBtb20uc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20gPSB0aGlzLmFwcGx5VGltZXpvbmUobW9tKTsgLy8gbWF5IG9yIG1heSBub3QgYXBwbHkgbG9jYWxlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQobW9tKTtcclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tc1RvVXRjTW9tZW50ID0gZnVuY3Rpb24gKG1zLCBmb3JjZUFsbERheSkge1xyXG4gICAgICAgIHZhciBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMobXMpOyAvLyBUT0RPOiBvcHRpbWl6ZSBieSB1c2luZyBEYXRlLlVUQ1xyXG4gICAgICAgIGlmIChmb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBtb20uc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQobW9tKTtcclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdGhlIGdpdmVuIG1vbWVudCdzIGxvY2FsZSBzZXR0aW5ncyB0byB0aGUgY3VycmVudCBjYWxlbmRhciBsb2NhbGUgc2V0dGluZ3MuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubG9jYWxpemVNb21lbnQgPSBmdW5jdGlvbiAobW9tKSB7XHJcbiAgICAgICAgbW9tLl9sb2NhbGUgPSB0aGlzLmxvY2FsZURhdGE7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciBvciBub3QgdGhlIGNhbGVuZGFyIGtub3dzIGhvdyB0byBjYWxjdWxhdGVcclxuICAgIC8vIHRoZSB0aW1lem9uZSBvZmZzZXQgb2YgYXJiaXRyYXJ5IGRhdGVzIGluIHRoZSBjdXJyZW50IHRpbWV6b25lLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldElzQW1iaWdUaW1lem9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdsb2NhbCcgJiYgdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdVVEMnO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBjdXJyZW50IHRpbWV6b25lLiBIYXMgbm8gZWZmZWN0IG9uIGRhdGVzIHdpdGhvdXQgdGltZXMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYXBwbHlUaW1lem9uZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgaWYgKCFkYXRlLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgem9uZWREYXRlID0gdGhpcy5tb21lbnQoZGF0ZS50b0FycmF5KCkpO1xyXG4gICAgICAgIHZhciB0aW1lQWRqdXN0ID0gZGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKSAtIHpvbmVkRGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKTtcclxuICAgICAgICB2YXIgYWRqdXN0ZWRab25lZERhdGU7XHJcbiAgICAgICAgLy8gU2FmYXJpIHNvbWV0aW1lcyBoYXMgcHJvYmxlbXMgd2l0aCB0aGlzIGNvZXJzaW9uIHdoZW4gbmVhciBEU1QuIEFkanVzdCBpZiBuZWNlc3NhcnkuIChidWcgIzIzOTYpXHJcbiAgICAgICAgaWYgKHRpbWVBZGp1c3QpIHtcclxuICAgICAgICAgICAgYWRqdXN0ZWRab25lZERhdGUgPSB6b25lZERhdGUuY2xvbmUoKS5hZGQodGltZUFkanVzdCk7IC8vIGFkZCBtaWxsaXNlY29uZHNcclxuICAgICAgICAgICAgaWYgKGRhdGUudGltZSgpLmFzTWlsbGlzZWNvbmRzKCkgLSBhZGp1c3RlZFpvbmVkRGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgem9uZWREYXRlID0gYWRqdXN0ZWRab25lZERhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHpvbmVkRGF0ZTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgQXNzdW1lcyB0aGUgZm9vdHByaW50IGlzIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgKi9cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb290cHJpbnRUb0RhdGVQcm9maWxlID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCwgaWdub3JlRW5kKSB7XHJcbiAgICAgICAgaWYgKGlnbm9yZUVuZCA9PT0gdm9pZCAwKSB7IGlnbm9yZUVuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2Uuc3RhcnRNcyk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAoIWlnbm9yZUVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZS5lbmRNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLmFwcGx5VGltZXpvbmUoZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBtb21lbnQgZm9yIHRoZSBjdXJyZW50IGRhdGUsIGFzIGRlZmluZWQgYnkgdGhlIGNsaWVudCdzIGNvbXB1dGVyIG9yIGZyb20gdGhlIGBub3dgIG9wdGlvbi5cclxuICAgIC8vIFdpbGwgcmV0dXJuIGFuIG1vbWVudCB3aXRoIGFuIGFtYmlndW91cyB0aW1lem9uZS5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXROb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMub3B0KCdub3cnKTtcclxuICAgICAgICBpZiAodHlwZW9mIG5vdyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBub3cgPSBub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9tZW50KG5vdykuc3RyaXBab25lKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUHJvZHVjZXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cclxuICAgIC8vIFNpZGUtZWZmZWN0OiBjaGFuZ2VzIHRoZSBsb2NhbGUgb2YgdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmh1bWFuaXplRHVyYXRpb24gPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gZHVyYXRpb24ubG9jYWxlKHRoaXMub3B0KCdsb2NhbGUnKSkuaHVtYW5pemUoKTtcclxuICAgIH07XHJcbiAgICAvLyB3aWxsIHJldHVybiBgbnVsbGAgaWYgaW52YWxpZCByYW5nZVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBhcnNlVW56b25lZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlSW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xyXG4gICAgICAgIGlmIChyYW5nZUlucHV0LnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5tb21lbnQocmFuZ2VJbnB1dC5zdGFydCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYW5nZUlucHV0LmVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLm1vbWVudChyYW5nZUlucHV0LmVuZCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3RhcnQgJiYgIWVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBlbmQuaXNCZWZvcmUoc3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQtRGF0ZSBVdGlsaXRpZXNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyXzEuZGVmYXVsdCh0aGlzKTtcclxuICAgICAgICB2YXIgcmF3U291cmNlcyA9IHRoaXMub3B0KCdldmVudFNvdXJjZXMnKSB8fCBbXTtcclxuICAgICAgICB2YXIgc2luZ2xlUmF3U291cmNlID0gdGhpcy5vcHQoJ2V2ZW50cycpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIGlmIChzaW5nbGVSYXdTb3VyY2UpIHtcclxuICAgICAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHNpbmdsZVJhd1NvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci5vbigncmVsZWFzZScsIGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ2V2ZW50c1Jlc2V0JywgZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIHJhd1NvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAocmF3U291cmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucGFyc2UocmF3U291cmNlLCBfdGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlci5hZGRTb3VyY2Uoc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlcXVlc3RFdmVudHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5yZXF1ZXN0RXZlbnRzKHN0YXJ0LCBlbmQsIHRoaXMub3B0KCd0aW1lem9uZScpLCAhdGhpcy5vcHQoJ2xhenlGZXRjaGluZycpKTtcclxuICAgIH07XHJcbiAgICAvLyBHZXQgYW4gZXZlbnQncyBub3JtYWxpemVkIGVuZCBkYXRlLiBJZiBub3QgcHJlc2VudCwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGRlZmF1bHRzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50RW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQuZW5kLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnQuYWxsRGF5LCBldmVudC5zdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cclxuICAgIC8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RGVmYXVsdEV2ZW50RW5kID0gZnVuY3Rpb24gKGFsbERheSwgem9uZWRTdGFydCkge1xyXG4gICAgICAgIHZhciBlbmQgPSB6b25lZFN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgaWYgKGFsbERheSkge1xyXG4gICAgICAgICAgICBlbmQuc3RyaXBUaW1lKCkuYWRkKHRoaXMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXRJc0FtYmlnVGltZXpvbmUoKSkge1xyXG4gICAgICAgICAgICBlbmQuc3RyaXBab25lKCk7IC8vIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgdHpvIHNob3VsZCBiZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5kO1xyXG4gICAgfTtcclxuICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlcmVuZGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmlldy5mbGFzaCgnZGlzcGxheWluZ0V2ZW50cycpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWZldGNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlZmV0Y2hBbGxTb3VyY2VzKCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckV2ZW50cyA9IGZ1bmN0aW9uIChldmVudElucHV0cywgaXNTdGlja3kpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50SW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnQoZXZlbnRJbnB1dHNbaV0sIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudElucHV0LCBpc1N0aWNreSkge1xyXG4gICAgICAgIGlmIChpc1N0aWNreSA9PT0gdm9pZCAwKSB7IGlzU3RpY2t5ID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIGV2ZW50SW5wdXQuc291cmNlIHx8IGV2ZW50TWFuYWdlci5zdGlja3lTb3VyY2UpO1xyXG4gICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuYWRkRXZlbnREZWYoZXZlbnREZWYsIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gbGVnYWN5UXVlcnkgb3BlcmF0ZXMgb24gbGVnYWN5IGV2ZW50IGluc3RhbmNlIG9iamVjdHNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbiAobGVnYWN5UXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGxlZ2FjeUluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZE1hcCA9IHt9O1xyXG4gICAgICAgIHZhciBldmVudERlZjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAobGVnYWN5UXVlcnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlQWxsRXZlbnREZWZzKCk7IC8vIHBlcnNpc3Q9dHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbGVnYWN5SW5zdGFuY2VzLnB1c2goZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxlZ2FjeUluc3RhbmNlcyA9IGZpbHRlckxlZ2FjeUV2ZW50SW5zdGFuY2VzKGxlZ2FjeUluc3RhbmNlcywgbGVnYWN5UXVlcnkpO1xyXG4gICAgICAgICAgICAvLyBjb21wdXRlIHVuaXF1ZSBJRHNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlZ2FjeUluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWYgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudERlZkJ5VWlkKGxlZ2FjeUluc3RhbmNlc1tpXS5faWQpO1xyXG4gICAgICAgICAgICAgICAgaWRNYXBbZXZlbnREZWYuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiBpZE1hcCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlbW92ZUV2ZW50RGVmc0J5SWQoaSk7IC8vIHBlcnNpc3Q9dHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGxlZ2FjeVF1ZXJ5IG9wZXJhdGVzIG9uIGxlZ2FjeSBldmVudCBpbnN0YW5jZSBvYmplY3RzXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY2xpZW50RXZlbnRzID0gZnVuY3Rpb24gKGxlZ2FjeVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGxlZ2FjeUV2ZW50SW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeUV2ZW50SW5zdGFuY2VzLnB1c2goZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyTGVnYWN5RXZlbnRJbnN0YW5jZXMobGVnYWN5RXZlbnRJbnN0YW5jZXMsIGxlZ2FjeVF1ZXJ5KTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50UHJvcHNBcnJheSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRQcm9wc0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXZlbnQoZXZlbnRQcm9wc0FycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVFdmVudCA9IGZ1bmN0aW9uIChldmVudFByb3BzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnREZWZCeVVpZChldmVudFByb3BzLl9pZCk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmIGluc3RhbmNlb2YgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UgPSBldmVudERlZi5idWlsZEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdC5jcmVhdGVGcm9tUmF3UHJvcHMoZXZlbnRJbnN0YW5jZSwgZXZlbnRQcm9wcywgLy8gcmF3IHByb3BzXHJcbiAgICAgICAgICAgIG51bGwgLy8gbGFyZ2VVbml0IC0tIHdobyB1c2VzIGl0P1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5tdXRhdGVFdmVudHNXaXRoSWQoZXZlbnREZWYuaWQsIGV2ZW50RGVmTXV0YXRpb24pOyAvLyB3aWxsIHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUHVibGljIEV2ZW50IFNvdXJjZXMgQVBJXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLm90aGVyU291cmNlcy5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuZ2V0U291cmNlQnlJZChFdmVudFNvdXJjZV8xLmRlZmF1bHQubm9ybWFsaXplSWQoaWQpKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYWRkRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSW5wdXQpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKHNvdXJjZUlucHV0LCB0aGlzKTtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVtb3ZlRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZU11bHRpUXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNvdXJjZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNvdXJjZU11bHRpUXVlcnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5yZW1vdmVBbGxTb3VyY2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2VzID0gZXZlbnRNYW5hZ2VyLm11bHRpUXVlcnlTb3VyY2VzKHNvdXJjZU11bHRpUXVlcnkpO1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlU291cmNlKHNvdXJjZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VRdWVyeSkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgc291cmNlcyA9IGV2ZW50TWFuYWdlci5xdWVyeVNvdXJjZXMoc291cmNlUXVlcnkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlU291cmNlKHNvdXJjZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWZldGNoRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZU11bHRpUXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBldmVudE1hbmFnZXIubXVsdGlRdWVyeVNvdXJjZXMoc291cmNlTXVsdGlRdWVyeSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZWZldGNoU291cmNlKHNvdXJjZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIC8vIG5vdCBmb3IgaW50ZXJuYWwgdXNlLiB1c2Ugb3B0aW9ucyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cclxuICAgIENhbGVuZGFyLmRlZmF1bHRzID0gb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzO1xyXG4gICAgQ2FsZW5kYXIuZW5nbGlzaERlZmF1bHRzID0gb3B0aW9uc18xLmVuZ2xpc2hEZWZhdWx0cztcclxuICAgIENhbGVuZGFyLnJ0bERlZmF1bHRzID0gb3B0aW9uc18xLnJ0bERlZmF1bHRzO1xyXG4gICAgcmV0dXJuIENhbGVuZGFyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDYWxlbmRhcjtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKENhbGVuZGFyKTtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhDYWxlbmRhcik7XHJcbmZ1bmN0aW9uIGZpbHRlckxlZ2FjeUV2ZW50SW5zdGFuY2VzKGxlZ2FjeUV2ZW50SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSkge1xyXG4gICAgaWYgKGxlZ2FjeVF1ZXJ5ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24obGVnYWN5UXVlcnkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2VzLmZpbHRlcihsZWdhY3lRdWVyeSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZWdhY3lRdWVyeSArPSAnJzsgLy8gbm9ybWFsaXplIHRvIHN0cmluZ1xyXG4gICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGxlZ2FjeUV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgLy8gc29mdCBjb21wYXJpc29uIGJlY2F1c2UgaWQgbm90IGJlIG5vcm1hbGl6ZWQgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZS5pZCA9PSBsZWdhY3lRdWVyeSB8fFxyXG4gICAgICAgICAgICAgICAgbGVnYWN5RXZlbnRJbnN0YW5jZS5faWQgPT09IGxlZ2FjeVF1ZXJ5OyAvLyBjYW4gc3BlY2lmeSBpbnRlcm5hbCBpZCwgYnV0IG11c3QgZXhhY3RseSBtYXRjaFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0ZVByb2ZpbGVHZW5lcmF0b3IoX3ZpZXcpIHtcclxuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XHJcbiAgICB9XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnRyaW1IaWRkZW5EYXlzKHVuem9uZWRSYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLm1zVG9VdGNNb21lbnQgPSBmdW5jdGlvbiAobXMsIGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuY2FsZW5kYXIubXNUb1V0Y01vbWVudChtcywgZm9yY2VBbGxEYXkpO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFByZXYgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIHByZXZEYXRlID0gY3VycmVudERhdGVQcm9maWxlLmRhdGUuY2xvbmUoKVxyXG4gICAgICAgICAgICAuc3RhcnRPZihjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdClcclxuICAgICAgICAgICAgLnN1YnRyYWN0KGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkTmV4dCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgbmV4dERhdGUgPSBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZS5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5zdGFydE9mKGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KVxyXG4gICAgICAgICAgICAuYWRkKGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXHJcbiAgICAvLyBmcm9tIGl0cyBwcmV2aW91cyB2YWx1ZS4gZGVjcmVtZW50ZWQgPSAtMSwgaW5jcmVtZW50ZWQgPSAxIChkZWZhdWx0KS5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCkge1xyXG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQgPT09IHZvaWQgMCkgeyBmb3JjZVRvVmFsaWQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpc0RhdGVBbGxEYXkgPSAhZGF0ZS5oYXNUaW1lKCk7XHJcbiAgICAgICAgdmFyIHZhbGlkVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBtaW5UaW1lID0gbnVsbDtcclxuICAgICAgICB2YXIgbWF4VGltZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRJbmZvO1xyXG4gICAgICAgIHZhciBpc1JhbmdlQWxsRGF5O1xyXG4gICAgICAgIHZhciByZW5kZXJVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgaXNWYWxpZDtcclxuICAgICAgICB2YWxpZFVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XHJcbiAgICAgICAgdmFsaWRVbnpvbmVkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkVW56b25lZFJhbmdlKTtcclxuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLm1zVG9VdGNNb21lbnQodmFsaWRVbnpvbmVkUmFuZ2UuY29uc3RyYWluRGF0ZShkYXRlKSwgLy8gcmV0dXJucyBNU1xyXG4gICAgICAgICAgICBpc0RhdGVBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KTtcclxuICAgICAgICByZW5kZXJVbnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UodGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby51bnpvbmVkUmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICByZW5kZXJVbnpvbmVkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gcmVuZGVyVW56b25lZFJhbmdlLmNsb25lKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wdCgnc2hvd05vbkN1cnJlbnREYXRlcycpKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IGFjdGl2ZVVuem9uZWRSYW5nZS5pbnRlcnNlY3QoY3VycmVudEluZm8udW56b25lZFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnbWluVGltZScpKTtcclxuICAgICAgICBtYXhUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtYXhUaW1lJykpO1xyXG4gICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlVW56b25lZFJhbmdlLCBtaW5UaW1lLCBtYXhUaW1lKTtcclxuICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2UgPSBhY3RpdmVVbnpvbmVkUmFuZ2UuaW50ZXJzZWN0KHZhbGlkVW56b25lZFJhbmdlKTsgLy8gbWlnaHQgcmV0dXJuIG51bGxcclxuICAgICAgICBpZiAoYWN0aXZlVW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLm1zVG9VdGNNb21lbnQoYWN0aXZlVW56b25lZFJhbmdlLmNvbnN0cmFpbkRhdGUoZGF0ZSksIC8vIHJldHVybnMgTVNcclxuICAgICAgICAgICAgaXNEYXRlQWxsRGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXHJcbiAgICAgICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXHJcbiAgICAgICAgaXNWYWxpZCA9IGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZS5pbnRlcnNlY3RzV2l0aCh2YWxpZFVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cclxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICB2YWxpZFVuem9uZWRSYW5nZTogdmFsaWRVbnpvbmVkUmFuZ2UsXHJcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cclxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXHJcbiAgICAgICAgICAgIGN1cnJlbnRVbnpvbmVkUmFuZ2U6IGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxyXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxyXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5OiBpc1JhbmdlQWxsRGF5LFxyXG4gICAgICAgICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBgbnVsbGAgaWYgbm8gZGF0ZXMgYWNjZXB0IGV2ZW50c1xyXG4gICAgICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2U6IGFjdGl2ZVVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cclxuICAgICAgICAgICAgLy8gaW5jbHVkZXMgbm90LWFjdGl2ZSBkYXlzIHRoYXQgbmVlZCBzb21lIHNvcnQgb2YgRE9NXHJcbiAgICAgICAgICAgIHJlbmRlclVuem9uZWRSYW5nZTogcmVuZGVyVW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBmaXJzdCB2aXNpYmxlIHRpbWUgb2YgYW55IGdpdmVuIGRheVxyXG4gICAgICAgICAgICBtaW5UaW1lOiBtaW5UaW1lLFxyXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBleGNsdXNpdmUgdmlzaWJsZSBlbmQgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XHJcbiAgICAgICAgICAgIG1heFRpbWU6IG1heFRpbWUsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXHJcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXHJcbiAgICAgICAgICAgIC8vIGhvdyBmYXIgdGhlIGN1cnJlbnQgZGF0ZSB3aWxsIG1vdmUgZm9yIGEgcHJldi9uZXh0IG9wZXJhdGlvblxyXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbilcclxuICAgICAgICAgICAgLy8gcGFzcyBhIGZhbGxiYWNrIChtaWdodCBiZSBudWxsKSBeXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXHJcbiAgICAvLyBJbmRpY2F0ZXMgdGhlIG1pbmltdW0vbWF4aW11bSBkYXRlcyB0byBkaXNwbGF5LlxyXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFZhbGlkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0VW56b25lZFJhbmdlT3B0aW9uKCd2YWxpZFJhbmdlJywgdGhpcy5fdmlldy5jYWxlbmRhci5nZXROb3coKSkgfHxcclxuICAgICAgICAgICAgbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoKTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXHJcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cclxuICAgIC8vIFNlZSBidWlsZCgpIGZvciBhIGRlc2NyaXB0aW9uIG9mIGBkaXJlY3Rpb25gLlxyXG4gICAgLy8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxyXG4gICAgLy8gVE9ETzogYWNjZXB0IGEgTVMtdGltZSBpbnN0ZWFkIG9mIGEgbW9tZW50IGBkYXRlYD9cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEN1cnJlbnRSYW5nZUluZm8gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHZpZXdTcGVjID0gdGhpcy5fdmlldy52aWV3U3BlYztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIHZhciB1bml0ID0gbnVsbDtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlID0gbnVsbDtcclxuICAgICAgICB2YXIgZGF5Q291bnQ7XHJcbiAgICAgICAgaWYgKHZpZXdTcGVjLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdmlld1NwZWMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHVuaXQgPSB2aWV3U3BlYy5kdXJhdGlvblVuaXQ7XHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5vcHQoJ2RheUNvdW50JykpKSB7XHJcbiAgICAgICAgICAgIHVuaXQgPSAnZGF5JztcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodW56b25lZFJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcclxuICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0KHVuem9uZWRSYW5nZS5nZXRTdGFydCgpLCB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcclxuICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0KGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIHVuaXQ6IHVuaXQsIHVuem9uZWRSYW5nZTogdW56b25lZFJhbmdlIH07XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmdldEZhbGxiYWNrRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IDEgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVVbnpvbmVkUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxyXG4gICAgLy8gbWluVGltZSBvciBtYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmFkanVzdEFjdGl2ZVJhbmdlID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSwgbWluVGltZSwgbWF4VGltZSkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBlbmQgPSB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXcudXNlc01pbk1heFRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKG1pblRpbWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKDApLmFkZChtaW5UaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4VGltZSA+IDI0ICogNjAgKiA2MCAqIDEwMDApIHtcclxuICAgICAgICAgICAgICAgIGVuZC50aW1lKG1heFRpbWUgLSAoMjQgKiA2MCAqIDYwICogMTAwMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gaXQgaXMgc3BlY2lmaWVkIGFzIGFuIGV4cGxpY2l0IGR1cmF0aW9uLlxyXG4gICAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGNvbXB1dGVHcmVhdGVzdFVuaXQgdmFsdWUgb2YgZHVyYXRpb24uXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCkge1xyXG4gICAgICAgIHZhciBhbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpO1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQ7XHJcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxyXG4gICAgICAgIGlmICghYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0KCdkYXRlSW5jcmVtZW50Jyk7XHJcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGVJbmNyZW1lbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkYXRlSW5jcmVtZW50SW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50RHVyYXRpb24gPCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHV0aWxfMS5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZGF0ZUluY3JlbWVudER1cmF0aW9uLCBkYXRlSW5jcmVtZW50SW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHVuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHZpZXcgZGlzcGxheXMgYSBzaW5nbGUgZGF5IG9yIHNtYWxsZXJcclxuICAgICAgICBpZiAoZHVyYXRpb24uYXMoJ2RheXMnKSA8PSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl92aWV3LmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl92aWV3LnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBkYXRlLmNsb25lKCkuc3RhcnRPZihhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZChkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHJlcyA9IG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXHJcbiAgICAgICAgaWYgKCF0aGlzLnRyaW1IaWRkZW5EYXlzKHJlcykpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuX3ZpZXcuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBhIGRheUNvdW50IGlzIHNwZWNpZmllZC5cclxuICAgIC8vIFRPRE86IGFjY2VwdCBhIE1TLXRpbWUgaW5zdGVhZCBvZiBhIG1vbWVudCBgZGF0ZWA/XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EYXlDb3VudCA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XHJcbiAgICAgICAgdmFyIGN1c3RvbUFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50Jyk7XHJcbiAgICAgICAgdmFyIHJ1bm5pbmdDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgaWYgKGN1c3RvbUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICBzdGFydC5zdGFydE9mKGN1c3RvbUFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0LnN0YXJ0T2YoJ2RheScpO1xyXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fdmlldy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgZW5kLmFkZCgxLCAnZGF5Jyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdmlldy5pc0hpZGRlbkRheShlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICBydW5uaW5nQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcclxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFVuem9uZWRSYW5nZSBhbmQgYWN0aXZlVW56b25lZFJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgdmlzaWJsZVVuem9uZWRSYW5nZSA9IHRoaXMuX3ZpZXcuZ2V0VW56b25lZFJhbmdlT3B0aW9uKCd2aXNpYmxlUmFuZ2UnLCB0aGlzLl92aWV3LmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoZGF0ZSkgLy8gY29ycmVjdCB6b25lLiBhbHNvIGdlbmVyYXRlcyBuZXcgb2JqIHRoYXQgYXZvaWRzIG11dGF0aW9uc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHZpc2libGVVbnpvbmVkUmFuZ2UgJiYgKHZpc2libGVVbnpvbmVkUmFuZ2Uuc3RhcnRNcyA9PSBudWxsIHx8IHZpc2libGVVbnpvbmVkUmFuZ2UuZW5kTXMgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aXNpYmxlVW56b25lZFJhbmdlO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcclxuICAgIC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cclxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRVbnpvbmVkUmFuZ2UuY2xvbmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXHJcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRGF0ZUluY3JlbWVudCA9IGZ1bmN0aW9uIChmYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdCgnZGF0ZUluY3JlbWVudCcpO1xyXG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XHJcbiAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnRJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBkYXlzOiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBFeHRlcm5hbERyb3BwaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXh0ZXJuYWxEcm9wcGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV4dGVybmFsRHJvcHBpbmcoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlOyAvLyBqcXVpLWRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQ/IGJvb2xlYW5cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IGltcGVtZW50czpcclxuICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgIC0gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgIC0gaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgIC0gcmVuZGVyRHJhZ1xyXG4gICAgICAtIHVucmVuZGVyRHJhZ1xyXG4gICAgKi9cclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuYmluZFRvRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuaGFuZGxlRHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgICBzb3J0c3RhcnQ6IHRoaXMuaGFuZGxlRHJhZ1N0YXJ0IC8vIGpxdWlcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS51bmJpbmRGcm9tRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgaXMgaW5pdGlhdGVkIGFueXdoZXJlIGluIHRoZSBET01cclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldiwgdWkpIHtcclxuICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgdmFyIGFjY2VwdDtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ2Ryb3BwYWJsZScpKSB7XHJcbiAgICAgICAgICAgIGVsID0gJCgodWkgPyB1aS5pdGVtIDogbnVsbCkgfHwgZXYudGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBkcmFnZ2VkIGVsZW1lbnQgcGFzc2VzIHRoZSBkcm9wQWNjZXB0IHNlbGVjdG9yIG9yIGZpbHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8gRllJLCB0aGUgZGVmYXVsdCBpcyBcIipcIiAobWF0Y2hlcyBhbGwpXHJcbiAgICAgICAgICAgIGFjY2VwdCA9IHRoaXMub3B0KCdkcm9wQWNjZXB0Jyk7XHJcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYWNjZXB0KSA/IGFjY2VwdC5jYWxsKGVsWzBdLCBlbCkgOiBlbC5pcyhhY2NlcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG9FeHRlcm5hbERyYWcoZWwsIGV2LCB1aSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBzdGFydHMgYW5kIGl0IG5lZWRzIHRvIGJlIG1vbml0b3JlZCBmb3IgZHJvcHBpbmdcclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmxpc3RlblRvRXh0ZXJuYWxEcmFnID0gZnVuY3Rpb24gKGVsLCBldiwgdWkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgbWV0YSA9IGdldERyYWdnZWRFbE1ldGEoZWwpOyAvLyBleHRyYSBkYXRhIGFib3V0IGV2ZW50IGRyb3AsIGluY2x1ZGluZyBwb3NzaWJsZSBldmVudCB0byBjcmVhdGVcclxuICAgICAgICB2YXIgc2luZ2xlRXZlbnREZWY7IC8vIGEgbnVsbCB2YWx1ZSBzaWduYWxzIGFuIHVuc3VjY2Vzc2Z1bCBkcmFnXHJcbiAgICAgICAgLy8gbGlzdGVuZXIgdGhhdCB0cmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciBkYXRlLWFzc29jaWF0ZWQgcGl4ZWwgcmVnaW9uc1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGl0Rm9vdHByaW50ID0gaGl0LmNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7IC8vIGhpdCBtaWdodCBub3QgYmVsb25nIHRvIHRoaXMgZ3JpZFxyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0Rm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYgPSBfdGhpcy5jb21wdXRlRXh0ZXJuYWxEcm9wKGhpdEZvb3RwcmludCwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZUV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBuZXcgRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdChzaW5nbGVFdmVudERlZi5idWlsZEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gbWV0YS5ldmVudFByb3BzID8gLy8gaXNFdmVudD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmlzRXh0ZXJuYWxJbnN0YW5jZUdyb3VwQWxsb3dlZChtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVFdmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXJEcmFnKC8vIGNhbGxlZCB3aXRob3V0IGEgc2VnIHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoY29tcG9uZW50LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZSwgdmlldy5jYWxlbmRhcikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZiA9IG51bGw7IC8vIHNpZ25hbCB1bnN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnVucmVuZGVyRHJhZygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV4dGVybmFsRHJvcChzaW5nbGVFdmVudERlZiwgQm9vbGVhbihtZXRhLmV2ZW50UHJvcHMpLCAvLyBpc0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbihtZXRhLnN0aWNrKSwgLy8gaXNTdGlja3lcclxuICAgICAgICAgICAgICAgICAgICBlbCwgZXYsIHVpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnREcmFnKGV2KTsgLy8gc3RhcnQgbGlzdGVuaW5nIGltbWVkaWF0ZWx5XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBoaXQgdG8gYmUgZHJvcHBlZCB1cG9uLCBhbmQgbWlzYyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUganF1aSBkcmFnIChndWFyYW50ZWVkIHRvIGJlIGEgcGxhaW4gb2JqZWN0KSxcclxuICAgIC8vIHJldHVybnMgdGhlIHpvbmVkIHN0YXJ0L2VuZCBkYXRlcyBmb3IgdGhlIGV2ZW50IHRoYXQgd291bGQgcmVzdWx0IGZyb20gdGhlIGh5cG90aGV0aWNhbCBkcm9wLiBlbmQgbWlnaHQgYmUgbnVsbC5cclxuICAgIC8vIFJldHVybmluZyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiBpbnZhbGlkIGRyb3AgaGl0LlxyXG4gICAgLy8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxyXG4gICAgLy8gQXNzdW1lcyBib3RoIGZvb3RwcmludHMgYXJlIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuY29tcHV0ZUV4dGVybmFsRHJvcCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIG1ldGEpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2Uuc3RhcnRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgZXZlbnREZWY7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICAvLyBpZiBkcm9wcGVkIG9uIGFuIGFsbC1kYXkgc3BhbiwgYW5kIGVsZW1lbnQncyBtZXRhZGF0YSBzcGVjaWZpZWQgYSB0aW1lLCBzZXQgaXRcclxuICAgICAgICAgICAgaWYgKG1ldGEuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKG1ldGEuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRhLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKG1ldGEuZHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudERlZiA9IFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZSgkLmV4dGVuZCh7fSwgbWV0YS5ldmVudFByb3BzLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICB9KSwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdChjYWxlbmRhcikpO1xyXG4gICAgICAgIHJldHVybiBldmVudERlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXh0ZXJuYWxEcm9wcGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXh0ZXJuYWxEcm9wcGluZztcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFeHRlcm5hbERyb3BwaW5nKTtcclxuLyogRXh0ZXJuYWwtRHJhZ2dpbmctRWxlbWVudCBEYXRhXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXF1aXJlIGFsbCBIVE1MNSBkYXRhLSogYXR0cmlidXRlcyB1c2VkIGJ5IEZ1bGxDYWxlbmRhciB0byBoYXZlIHRoaXMgcHJlZml4LlxyXG4vLyBBIHZhbHVlIG9mICcnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZXZlbnQuIEEgdmFsdWUgb2YgJ2ZjJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZjLWV2ZW50LlxyXG5leHBvcnRIb29rcy5kYXRhQXR0clByZWZpeCA9ICcnO1xyXG4vLyBHaXZlbiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgbWlnaHQgcmVwcmVzZW50IGEgZHJhZ2dlZCBGdWxsQ2FsZW5kYXIgZXZlbnQsIHJldHVybnMgYW4gaW50ZXJtZWRpYXRlIGRhdGEgc3RydWN0dXJlXHJcbi8vIHRvIGJlIHVzZWQgZm9yIEV2ZW50IE9iamVjdCBjcmVhdGlvbi5cclxuLy8gQSBkZWZpbmVkIGAuZXZlbnRQcm9wc2AsIGV2ZW4gd2hlbiBlbXB0eSwgaW5kaWNhdGVzIHRoYXQgYW4gZXZlbnQgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbmZ1bmN0aW9uIGdldERyYWdnZWRFbE1ldGEoZWwpIHtcclxuICAgIHZhciBwcmVmaXggPSBleHBvcnRIb29rcy5kYXRhQXR0clByZWZpeDtcclxuICAgIHZhciBldmVudFByb3BzOyAvLyBwcm9wZXJ0aWVzIGZvciBjcmVhdGluZyB0aGUgZXZlbnQsIG5vdCByZWxhdGVkIHRvIGRhdGUvdGltZVxyXG4gICAgdmFyIHN0YXJ0VGltZTsgLy8gYSBEdXJhdGlvblxyXG4gICAgdmFyIGR1cmF0aW9uO1xyXG4gICAgdmFyIHN0aWNrO1xyXG4gICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgIHByZWZpeCArPSAnLSc7XHJcbiAgICB9XHJcbiAgICBldmVudFByb3BzID0gZWwuZGF0YShwcmVmaXggKyAnZXZlbnQnKSB8fCBudWxsO1xyXG4gICAgaWYgKGV2ZW50UHJvcHMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UHJvcHMgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcyk7IC8vIG1ha2UgYSBjb3B5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudFByb3BzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBsdWNrIHNwZWNpYWwtY2FzZWQgZGF0ZS90aW1lIHByb3BlcnRpZXNcclxuICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgICAgICBkdXJhdGlvbiA9IGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgc3RpY2sgPSBldmVudFByb3BzLnN0aWNrO1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuc3RpY2s7XHJcbiAgICB9XHJcbiAgICAvLyBmYWxsYmFjayB0byBzdGFuZGFsb25lIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIGRhdGUvdGltZSBwcm9wZXJ0aWVzXHJcbiAgICBpZiAoc3RhcnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICdzdGFydCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RhcnRUaW1lID0gZWwuZGF0YShwcmVmaXggKyAndGltZScpO1xyXG4gICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSBlbC5kYXRhKHByZWZpeCArICdkdXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0aWNrID09IG51bGwpIHtcclxuICAgICAgICBzdGljayA9IGVsLmRhdGEocHJlZml4ICsgJ3N0aWNrJyk7XHJcbiAgICB9XHJcbiAgICAvLyBtYXNzYWdlIGludG8gY29ycmVjdCBkYXRhIHR5cGVzXHJcbiAgICBzdGFydFRpbWUgPSBzdGFydFRpbWUgIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihzdGFydFRpbWUpIDogbnVsbDtcclxuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbikgOiBudWxsO1xyXG4gICAgc3RpY2sgPSBCb29sZWFuKHN0aWNrKTtcclxuICAgIHJldHVybiB7IGV2ZW50UHJvcHM6IGV2ZW50UHJvcHMsIHN0YXJ0VGltZTogc3RhcnRUaW1lLCBkdXJhdGlvbjogZHVyYXRpb24sIHN0aWNrOiBzdGljayB9O1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIEV2ZW50UmVzaXppbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudFJlc2l6aW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBlbWVudHM6XHJcbiAgICAgIC0gYmluZFNlZ0hhbmRsZXJUb0VsXHJcbiAgICAgIC0gcHVibGljbHlUcmlnZ2VyXHJcbiAgICAgIC0gZGlmZkRhdGVzXHJcbiAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAtIGlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgICAtIGdldFNhZmVIaXRGb290cHJpbnRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudFJlc2l6aW5nKGNvbXBvbmVudCwgZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc1Jlc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IGV2ZW50UG9pbnRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuY2FuU3RhcnRSZXNpemUoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcsICQoZXYudGFyZ2V0KS5pcygnLmZjLXN0YXJ0LXJlc2l6ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zdGFydEludGVyYWN0aW9uKGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuY2FuU3RhcnRSZXNpemUoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcsICQoZXYudGFyZ2V0KS5pcygnLmZjLXN0YXJ0LXJlc2l6ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zdGFydEludGVyYWN0aW9uKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyIGFzIHRoZXkgcmVzaXplIGFuIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKHNlZywgaXNTdGFydCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IGNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZWwgPSBzZWcuZWw7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB2YXIgaXNEcmFnZ2luZztcclxuICAgICAgICB2YXIgcmVzaXplTXV0YXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllcy4gZmFsc3kgaWYgaW52YWxpZCByZXNpemVcclxuICAgICAgICAvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKmdyaWQncyogY29vcmRpbmF0ZSBtYXBcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBzdWJqZWN0RWw6IGVsLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZy5oYW5kbGVNb3VzZW91dChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1Jlc2l6ZVN0YXJ0KHNlZywgZXYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdIaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChvcmlnSGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdEZvb3RwcmludCAmJiBoaXRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IGlzU3RhcnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlRXZlbnRTdGFydFJlc2l6ZU11dGF0aW9uKG9yaWdIaXRGb290cHJpbnQsIGhpdEZvb3RwcmludCwgc2VnLmZvb3RwcmludCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlRXZlbnRFbmRSZXNpemVNdXRhdGlvbihvcmlnSGl0Rm9vdHByaW50LCBoaXRGb290cHJpbnQsIHNlZy5mb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRNYW5hZ2VyLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cChldmVudERlZi5pZCwgcmVzaXplTXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBjb21wb25lbnQuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzaXplTXV0YXRpb24uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2hhbmdlLiAoRllJLCBldmVudCBkYXRlcyBtaWdodCBoYXZlIHpvbmVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaGlkZUV2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlbmRlckV2ZW50UmVzaXplKGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoY29tcG9uZW50LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZSwgY2FsZW5kYXIpKSwgc2VnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJFdmVudFJlc2l6ZShzZWcpO1xyXG4gICAgICAgICAgICAgICAgdmlldy5zaG93RXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ1Jlc2l6ZVN0b3Aoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHJlLXNob3cgb3JpZ2luYWwsIHdpbGwgcmVyZW5kZXIgYWxsIGFueXdheXMuIGVzcCBpbXBvcnRhbnQgaWYgZXZlbnRSZW5kZXJXYWl0XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5yZXBvcnRFdmVudFJlc2l6ZShldmVudEluc3RhbmNlLCByZXNpemVNdXRhdGlvbiwgZWwsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBiZWZvcmUgZXZlbnQgc2VnbWVudCByZXNpemluZyBzdGFydHNcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLnNlZ1Jlc2l6ZVN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemVTdGFydCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgYWZ0ZXIgZXZlbnQgc2VnbWVudCByZXNpemluZyBzdG9wc1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuc2VnUmVzaXplU3RvcCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc1Jlc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBuZXcgZGF0ZS1pbmZvcm1hdGlvbiBmb3IgYW4gZXZlbnQgc2VnbWVudCBiZWluZyByZXNpemVkIGZyb20gaXRzIHN0YXJ0XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnRTdGFydFJlc2l6ZU11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQsIG9yaWdFdmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBvcmlnUmFuZ2UgPSBvcmlnRXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgc3RhcnREZWx0YSA9IHRoaXMuY29tcG9uZW50LmRpZmZEYXRlcyhlbmRGb290cHJpbnQudW56b25lZFJhbmdlLmdldFN0YXJ0KCksIHN0YXJ0Rm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpKTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIGlmIChvcmlnUmFuZ2UuZ2V0U3RhcnQoKS5hZGQoc3RhcnREZWx0YSkgPCBvcmlnUmFuZ2UuZ2V0RW5kKCkpIHtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24uc2V0U3RhcnREZWx0YShzdGFydERlbHRhKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uLnNldERhdGVNdXRhdGlvbihkYXRlTXV0YXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBlbmRcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmNvbXB1dGVFdmVudEVuZFJlc2l6ZU11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQsIG9yaWdFdmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBvcmlnUmFuZ2UgPSBvcmlnRXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgZW5kRGVsdGEgPSB0aGlzLmNvbXBvbmVudC5kaWZmRGF0ZXMoZW5kRm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRFbmQoKSwgc3RhcnRGb290cHJpbnQudW56b25lZFJhbmdlLmdldEVuZCgpKTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIGlmIChvcmlnUmFuZ2UuZ2V0RW5kKCkuYWRkKGVuZERlbHRhKSA+IG9yaWdSYW5nZS5nZXRTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbiA9IG5ldyBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uLnNldEVuZERlbHRhKGVuZERlbHRhKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uLnNldERhdGVNdXRhdGlvbihkYXRlTXV0YXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFJlc2l6aW5nO1xyXG59KEludGVyYWN0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFJlc2l6aW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XHJcbnZhciBEcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIE1vdXNlRm9sbG93ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ0KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIEV2ZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudERyYWdnaW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBsZW1lbnRzOlxyXG4gICAgICAtIGJpbmRTZWdIYW5kbGVyVG9FbFxyXG4gICAgICAtIHB1YmxpY2x5VHJpZ2dlclxyXG4gICAgICAtIGRpZmZEYXRlc1xyXG4gICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgLSBpc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudERyYWdnaW5nKGNvbXBvbmVudCwgZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IGV2ZW50UG9pbnRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25EZWxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdCgnZXZlbnRMb25nUHJlc3NEZWxheScpO1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gdGhpcy5vcHQoJ2xvbmdQcmVzc0RlbGF5Jyk7IC8vIGZhbGxiYWNrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxheTtcclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50LnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY2FuU3RhcnREcmFnKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREcmFnTGlzdGVuZXIoc2VnKS5zdGFydEludGVyYWN0aW9uKGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBkZWxheTogdGhpcy52aWV3LmlzRXZlbnREZWZTZWxlY3RlZChzZWcuZm9vdHByaW50LmV2ZW50RGVmKSA/IC8vIGFscmVhZHkgc2VsZWN0ZWQ/XHJcbiAgICAgICAgICAgICAgICAwIDogdGhpcy5nZXRTZWxlY3Rpb25EZWxheSgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY29tcG9uZW50LmNhblN0YXJ0RHJhZyhzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQuY2FuU3RhcnRTZWxlY3Rpb24oc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFNlbGVjdExpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBzZWcgaXNuJ3QgZHJhZ2dhYmxlLCBidXQgbGV0J3MgdXNlIGEgZ2VuZXJpYyBEcmFnTGlzdGVuZXJcclxuICAgIC8vIHNpbXBseSBmb3IgdGhlIGRlbGF5LCBzbyBpdCBjYW4gYmUgc2VsZWN0ZWQuXHJcbiAgICAvLyBIYXMgc2lkZSBlZmZlY3Qgb2Ygc2V0dGluZy91bnNldHRpbmcgYGRyYWdMaXN0ZW5lcmBcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmJ1aWxkU2VsZWN0TGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlOyAvLyBudWxsIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXZpZXcuaXNFdmVudERlZlNlbGVjdGVkKGV2ZW50RGVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNlbGVjdEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB0cmFjayB1c2VyLWRyYWdnaW5nIG9uIGFuIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cclxuICAgIC8vIEhhcyBzaWRlIGVmZmVjdCBvZiBzZXR0aW5nL3Vuc2V0dGluZyBgZHJhZ0xpc3RlbmVyYFxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBlbCA9IHNlZy5lbDtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlOyAvLyBudWxsIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgdmFyIGlzRHJhZ2dpbmc7XHJcbiAgICAgICAgdmFyIG1vdXNlRm9sbG93ZXI7IC8vIEEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCB3aWxsIG1vdmUgd2l0aCB0aGUgbW91c2VcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKnZpZXcncyogY29vcmRpbmF0ZSBtYXAuIEFsbG93cyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgYmV0d2VlbiBzdWJjb21wb25lbnRzXHJcbiAgICAgICAgLy8gb2YgdGhlIHZpZXcuXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQodmlldywge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIHN1YmplY3RFbDogZWwsXHJcbiAgICAgICAgICAgIHN1YmplY3RDZW50ZXI6IHRydWUsXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgc2VnLmNvbXBvbmVudCA9IGNvbXBvbmVudDsgLy8gZm9yIHJlbmRlckRyYWdcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIgPSBuZXcgTW91c2VGb2xsb3dlcl8xLmRlZmF1bHQoc2VnLmVsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYXNzOiAnZmMtZHJhZ2dpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsOiB2aWV3LmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGRyYWdMaXN0ZW5lci5pc1RvdWNoID8gbnVsbCA6IF90aGlzLm9wdCgnZHJhZ09wYWNpdHknKSxcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnREdXJhdGlvbjogX3RoaXMub3B0KCdkcmFnUmV2ZXJ0RHVyYXRpb24nKSxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDIgLy8gb25lIGFib3ZlIHRoZSAuZmMtdmlld1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLmhpZGUoKTsgLy8gZG9uJ3Qgc2hvdyB1bnRpbCB3ZSBrbm93IHRoaXMgaXMgYSByZWFsIGRyYWdcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc3RhcnQoZXYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXZpZXcuaXNFdmVudERlZlNlbGVjdGVkKGV2ZW50RGVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNlbGVjdEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZy5oYW5kbGVNb3VzZW91dChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ0RyYWdTdGFydChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIHZpZXcuaGlkZUV2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnRm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgaGl0IGNvdWxkIGJlIGZvcmNlZCAoRGF5R3JpZC5saW1pdClcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuaGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0hpdCA9IHNlZy5oaXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBoaXQgbWlnaHQgbm90IGJlbG9uZyB0byB0aGlzIGdyaWQsIHNvIHF1ZXJ5IG9yaWdpbiBncmlkXHJcbiAgICAgICAgICAgICAgICBvcmlnRm9vdHByaW50ID0gb3JpZ0hpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChvcmlnSGl0KTtcclxuICAgICAgICAgICAgICAgIGZvb3RwcmludCA9IGhpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdGb290cHJpbnQgJiYgZm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IF90aGlzLmNvbXB1dGVFdmVudERyb3BNdXRhdGlvbihvcmlnRm9vdHByaW50LCBmb290cHJpbnQsIGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRNYW5hZ2VyLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cChldmVudERlZi5pZCwgZXZlbnREZWZNdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdmFsaWQgZHJvcCBsb2NhdGlvbiwgaGF2ZSB0aGUgc3ViY2xhc3MgcmVuZGVyIGEgdmlzdWFsIGluZGljYXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChldmVudERlZk11dGF0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5yZW5kZXJEcmFnKC8vIHRydXRoeSBpZiByZW5kZXJlZCBzb21ldGhpbmdcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGNvbXBvbmVudC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UsIGNhbGVuZGFyKSksIHNlZywgZHJhZ0xpc3RlbmVyLmlzVG91Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5oaWRlKCk7IC8vIGlmIHRoZSBzdWJjbGFzcyBpcyBhbHJlYWR5IHVzaW5nIGEgbW9jayBldmVudCBcImhlbHBlclwiLCBoaWRlIG91ciBvd25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBvdGhlcndpc2UsIGhhdmUgdGhlIGhlbHBlciBmb2xsb3cgdGhlIG1vdXNlIChubyBzbmFwcGluZylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc09yaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0byBoYXZlIG1vdmVkIGhpdHMgdG8gYmUgYSB2YWxpZCBkcm9wXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmlldy51bnJlbmRlckRyYWcoc2VnKTsgLy8gdW5yZW5kZXIgd2hhdGV2ZXIgd2FzIGRvbmUgaW4gcmVuZGVyRHJhZ1xyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5zaG93KCk7IC8vIHNob3cgaW4gY2FzZSB3ZSBhcmUgbW92aW5nIG91dCBvZiBhbGwgaGl0c1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlZy5jb21wb25lbnQ7IC8vIHByZXZlbnQgc2lkZSBlZmZlY3RzXHJcbiAgICAgICAgICAgICAgICAvLyBkbyByZXZlcnQgYW5pbWF0aW9uIGlmIGhhc24ndCBjaGFuZ2VkLiBjYWxscyBhIGNhbGxiYWNrIHdoZW4gZmluaXNoZWQgKHdoZXRoZXIgYW5pbWF0aW9uIG9yIG5vdClcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc3RvcCghZXZlbnREZWZNdXRhdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJEcmFnKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ0RyYWdTdG9wKHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNob3dFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byByZS1zaG93IG9yaWdpbmFsLCB3aWxsIHJlcmVuZGVyIGFsbCBhbnl3YXlzLiBlc3AgaW1wb3J0YW50IGlmIGV2ZW50UmVuZGVyV2FpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV2ZW50RHJvcChldmVudEluc3RhbmNlLCBldmVudERlZk11dGF0aW9uLCBlbCwgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IGRyYWdnaW5nIHN0YXJ0c1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuc2VnRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RvcHNcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLnNlZ0RyYWdTdG9wID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnREcm9wTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCwgZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb24uc2V0RGF0ZU11dGF0aW9uKHRoaXMuY29tcHV0ZUV2ZW50RGF0ZU11dGF0aW9uKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQpKTtcclxuICAgICAgICByZXR1cm4gZXZlbnREZWZNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnREYXRlTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBkYXRlMCA9IHN0YXJ0Rm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBkYXRlMSA9IGVuZEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgY2xlYXJFbmQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZm9yY2VUaW1lZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkYXRlRGVsdGE7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICBpZiAoc3RhcnRGb290cHJpbnQuaXNBbGxEYXkgIT09IGVuZEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICBjbGVhckVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChlbmRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlQWxsRGF5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRhdGUwLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VUaW1lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZURlbHRhID0gdGhpcy5jb21wb25lbnQuZGlmZkRhdGVzKGRhdGUxLCBkYXRlMCk7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5jbGVhckVuZCA9IGNsZWFyRW5kO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5mb3JjZVRpbWVkID0gZm9yY2VUaW1lZDtcclxuICAgICAgICBkYXRlTXV0YXRpb24uZm9yY2VBbGxEYXkgPSBmb3JjZUFsbERheTtcclxuICAgICAgICBkYXRlTXV0YXRpb24uc2V0RGF0ZURlbHRhKGRhdGVEZWx0YSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGVNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREcmFnZ2luZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREcmFnZ2luZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgRGF0ZVNlbGVjdGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVTZWxlY3RpbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IG11c3QgaW1wbGVtZW50OlxyXG4gICAgICAtIGJpbmREYXRlSGFuZGxlclRvRWxcclxuICAgICAgLSBnZXRTYWZlSGl0Rm9vdHByaW50XHJcbiAgICAgIC0gcmVuZGVySGlnaGxpZ2h0XHJcbiAgICAgIC0gdW5yZW5kZXJIaWdobGlnaHRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBEYXRlU2VsZWN0aW5nKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBfdGhpcy5idWlsZERyYWdMaXN0ZW5lcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmdldERlbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMub3B0KCdzZWxlY3RMb25nUHJlc3NEZWxheScpO1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gdGhpcy5vcHQoJ2xvbmdQcmVzc0RlbGF5Jyk7IC8vIGZhbGxiYWNrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxheTtcclxuICAgIH07XHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0KCdzZWxlY3RhYmxlJykgJiYgIWNvbXBvbmVudC5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBfdGhpcy5vcHQoJ3NlbGVjdE1pbkRpc3RhbmNlJylcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmREYXRlSGFuZGxlclRvRWwoZWwsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ3NlbGVjdGFibGUnKSAmJiAhY29tcG9uZW50LnNob3VsZElnbm9yZVRvdWNoKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IF90aGlzLmdldERlbGF5KClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdXRpbF8xLnByZXZlbnRTZWxlY3Rpb24oZWwpO1xyXG4gICAgfTtcclxuICAgIC8vIENyZWF0ZXMgYSBsaXN0ZW5lciB0aGF0IHRyYWNrcyB0aGUgdXNlcidzIGRyYWcgYWNyb3NzIGRheSBlbGVtZW50cywgZm9yIGRheSBzZWxlY3RpbmcuXHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5idWlsZERyYWdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgc2VsZWN0aW9uRm9vdHByaW50OyAvLyBudWxsIGlmIGludmFsaWQgc2VsZWN0aW9uXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnVuc2VsZWN0KGV2KTsgLy8gc2luY2Ugd2UgY291bGQgYmUgcmVuZGVyaW5nIGEgbmV3IHNlbGVjdGlvbiwgd2Ugd2FudCB0byBjbGVhciBhbnkgb2xkIG9uZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnSGl0Rm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdEZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0hpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KG9yaWdIaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdIaXRGb290cHJpbnQgJiYgaGl0Rm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IF90aGlzLmNvbXB1dGVTZWxlY3Rpb24ob3JpZ0hpdEZvb3RwcmludCwgaGl0Rm9vdHByaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Gb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChzZWxlY3Rpb25Gb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25Gb290cHJpbnQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvb3RwcmludCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudW5yZW5kZXJTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0NhbmNlbGxlZCAmJiBzZWxlY3Rpb25Gb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gcmVuZGVyZWQuIGp1c3QgcmVwb3J0IGl0XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5yZXBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uRm9vdHByaW50LCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHRoZSBmaXJzdCBhbmQgbGFzdCBkYXRlLXNwYW5zIG9mIGEgc2VsZWN0aW9uLCByZXR1cm5zIGFub3RoZXIgZGF0ZS1zcGFuIG9iamVjdC5cclxuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIGFuZCBwcm92aWRlIGFkZGl0aW9uYWwgZGF0YSBpbiB0aGUgc3BhbiBvYmplY3QuIFdpbGwgYmUgcGFzc2VkIHRvIHJlbmRlclNlbGVjdGlvbkZvb3RwcmludCgpLlxyXG4gICAgLy8gV2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIHNlbGVjdGlvbiBpcyBpbnZhbGlkIGFuZCB0aGlzIHNob3VsZCBiZSBpbmRpY2F0ZWQgdG8gdGhlIHVzZXIuXHJcbiAgICAvLyBXaWxsIHJldHVybiBudWxsL3VuZGVmaW5lZCBpZiBhIHNlbGVjdGlvbiBpbnZhbGlkIGJ1dCBubyBlcnJvciBzaG91bGQgYmUgcmVwb3J0ZWQuXHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5jb21wdXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKGZvb3RwcmludDAsIGZvb3RwcmludDEpIHtcclxuICAgICAgICB2YXIgd2hvbGVGb290cHJpbnQgPSB0aGlzLmNvbXB1dGVTZWxlY3Rpb25Gb290cHJpbnQoZm9vdHByaW50MCwgZm9vdHByaW50MSk7XHJcbiAgICAgICAgaWYgKHdob2xlRm9vdHByaW50ICYmICF0aGlzLmlzU2VsZWN0aW9uRm9vdHByaW50QWxsb3dlZCh3aG9sZUZvb3RwcmludCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2hvbGVGb290cHJpbnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gdHdvIHNwYW5zLCBtdXN0IHJldHVybiB0aGUgY29tYmluYXRpb24gb2YgdGhlIHR3by5cclxuICAgIC8vIFRPRE86IGRvIHRoaXMgc2VwYXJhdGlvbiBvZiBjb25jZXJucyAoY29tYmluaW5nIFZTIHZhbGlkYXRpb24pIGZvciBldmVudCBkbmQvcmVzaXplIHRvby5cclxuICAgIC8vIEFzc3VtZXMgYm90aCBmb290cHJpbnRzIGFyZSBub24tb3Blbi1lbmRlZC5cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmNvbXB1dGVTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoZm9vdHByaW50MCwgZm9vdHByaW50MSkge1xyXG4gICAgICAgIHZhciBtcyA9IFtcclxuICAgICAgICAgICAgZm9vdHByaW50MC51bnpvbmVkUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MC51bnpvbmVkUmFuZ2UuZW5kTXMsXHJcbiAgICAgICAgICAgIGZvb3RwcmludDEudW56b25lZFJhbmdlLnN0YXJ0TXMsXHJcbiAgICAgICAgICAgIGZvb3RwcmludDEudW56b25lZFJhbmdlLmVuZE1zXHJcbiAgICAgICAgXTtcclxuICAgICAgICBtcy5zb3J0KHV0aWxfMS5jb21wYXJlTnVtYmVycyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KG1zWzBdLCBtc1szXSksIGZvb3RwcmludDAuaXNBbGxEYXkpO1xyXG4gICAgfTtcclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmlzU2VsZWN0aW9uRm9vdHByaW50QWxsb3dlZCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZGF0ZVByb2ZpbGUudmFsaWRVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSAmJlxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuY2FsZW5kYXIuY29uc3RyYWludHMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVTZWxlY3Rpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVTZWxlY3Rpbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxudmFyIFRpbWVHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNyk7XHJcbnZhciBEYXlHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxudmFyIEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUID0gNTtcclxudmFyIGFnZW5kYVRpbWVHcmlkTWV0aG9kcztcclxudmFyIGFnZW5kYURheUdyaWRNZXRob2RzO1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgYWxsIGFnZW5kYS1yZWxhdGVkIHZpZXdzLiBEaXNwbGF5cyBvbmUgbW9yZSBjb2x1bW5zIHdpdGggdGltZSBzbG90cyBydW5uaW5nIHZlcnRpY2FsbHkuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBJcyBhIG1hbmFnZXIgZm9yIHRoZSBUaW1lR3JpZCBzdWJjb21wb25lbnQgYW5kIHBvc3NpYmx5IHRoZSBEYXlHcmlkIHN1YmNvbXBvbmVudCAoaWYgYWxsRGF5U2xvdCBpcyBvbikuXHJcbi8vIFJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXHJcbnZhciBBZ2VuZGFWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQWdlbmRhVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFnZW5kYVZpZXcoY2FsZW5kYXIsIHZpZXdTcGVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsZW5kYXIsIHZpZXdTcGVjKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnVzZXNNaW5NYXhUaW1lID0gdHJ1ZTsgLy8gaW5kaWNhdGVzIHRoYXQgbWluVGltZS9tYXhUaW1lIGFmZmVjdHMgcmVuZGVyaW5nXHJcbiAgICAgICAgX3RoaXMudGltZUdyaWQgPSBfdGhpcy5pbnN0YW50aWF0ZVRpbWVHcmlkKCk7XHJcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMudGltZUdyaWQpO1xyXG4gICAgICAgIGlmIChfdGhpcy5vcHQoJ2FsbERheVNsb3QnKSkge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gX3RoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7IC8vIHRoZSBhbGwtZGF5IHN1YmNvbXBvbmVudCBvZiB0aGlzIHZpZXdcclxuICAgICAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuZGF5R3JpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gSW5zdGFudGlhdGVzIHRoZSBUaW1lR3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMudGltZUdyaWRDbGFzc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuaW5zdGFudGlhdGVUaW1lR3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGltZUdyaWQgPSBuZXcgdGhpcy50aW1lR3JpZENsYXNzKHRoaXMpO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMoYWdlbmRhVGltZUdyaWRNZXRob2RzLCB0aW1lR3JpZCk7XHJcbiAgICAgICAgcmV0dXJuIHRpbWVHcmlkO1xyXG4gICAgfTtcclxuICAgIC8vIEluc3RhbnRpYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG1pZ2h0IG5lZWQuIERyYXdzIGZyb20gdGhpcy5kYXlHcmlkQ2xhc3NcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmluc3RhbnRpYXRlRGF5R3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF5R3JpZCA9IG5ldyB0aGlzLmRheUdyaWRDbGFzcyh0aGlzKTtcclxuICAgICAgICB1dGlsXzEuY29weU93blByb3BzKGFnZW5kYURheUdyaWRNZXRob2RzLCBkYXlHcmlkKTtcclxuICAgICAgICByZXR1cm4gZGF5R3JpZDtcclxuICAgIH07XHJcbiAgICAvKiBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGltZUdyaWRXcmFwRWw7XHJcbiAgICAgICAgdmFyIHRpbWVHcmlkRWw7XHJcbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnZmMtYWdlbmRhLXZpZXcnKS5odG1sKHRoaXMucmVuZGVyU2tlbGV0b25IdG1sKCkpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XHJcbiAgICAgICAgdGltZUdyaWRXcmFwRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy10aW1lLWdyaWQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGltZUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy10aW1lLWdyaWRcIiAvPicpLmFwcGVuZFRvKHRpbWVHcmlkV3JhcEVsKTtcclxuICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZCh0aW1lR3JpZFdyYXBFbCk7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5oZWFkQ29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQuc2V0RWxlbWVudCh0aW1lR3JpZEVsKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KHRoaXMuZWwuZmluZCgnLmZjLWRheS1ncmlkJykpO1xyXG4gICAgICAgICAgICAvLyBoYXZlIHRoZSBkYXktZ3JpZCBleHRlbmQgaXQncyBjb29yZGluYXRlIGFyZWEgb3ZlciB0aGUgPGhyPiBkaXZpZGluZyB0aGUgdHdvIGdyaWRzXHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5ib3R0b21Db29yZFBhZGRpbmcgPSB0aGlzLmRheUdyaWQuZWwubmV4dCgnaHInKS5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cclxuICAgIC8vIFRoZSBkYXktZ3JpZCBhbmQgdGltZS1ncmlkIGNvbXBvbmVudHMgd2lsbCByZW5kZXIgaW5zaWRlIGNvbnRhaW5lcnMgZGVmaW5lZCBieSB0aGlzIEhUTUwuXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbkh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMub3B0KCdjb2x1bW5IZWFkZXInKSA/XHJcbiAgICAgICAgICAgICAgICAnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCI+Jm5ic3A7PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGF5R3JpZCA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCIvPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIvPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgICAnPC90Ym9keT4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JztcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gSFRNTCBhdHRyaWJ1dGUgc3RyaW5nIGZvciBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgYXhpcywgaWYgaXQgaXMga25vd25cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmF4aXNTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXhpc1dpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLmF4aXNXaWR0aCArICdweFwiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVHcmlkLmdldE5vd0luZGljYXRvclVuaXQoKTtcclxuICAgIH07XHJcbiAgICAvKiBEaW1lbnNpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQWRqdXN0cyB0aGUgdmVydGljYWwgZGltZW5zaW9ucyBvZiB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHZhciBldmVudExpbWl0O1xyXG4gICAgICAgIHZhciBzY3JvbGxlckhlaWdodDtcclxuICAgICAgICB2YXIgc2Nyb2xsYmFyV2lkdGhzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICAvLyBtYWtlIGFsbCBheGlzIGNlbGxzIGxpbmUgdXAsIGFuZCByZWNvcmQgdGhlIHdpZHRoIHNvIG5ld2x5IGNyZWF0ZWQgYXhpcyBjZWxscyB3aWxsIGhhdmUgaXRcclxuICAgICAgICB0aGlzLmF4aXNXaWR0aCA9IHV0aWxfMS5tYXRjaENlbGxXaWR0aHModGhpcy5lbC5maW5kKCcuZmMtYXhpcycpKTtcclxuICAgICAgICAvLyBoYWNrIHRvIGdpdmUgdGhlIHZpZXcgc29tZSBoZWlnaHQgcHJpb3IgdG8gdGltZUdyaWQncyBjb2x1bW5zIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gVE9ETzogc2VwYXJhdGUgc2V0dGluZyBoZWlnaHQgZnJvbSBzY3JvbGxlciBWUyB0aW1lR3JpZC5cclxuICAgICAgICBpZiAoIXRoaXMudGltZUdyaWQuY29sRWxzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBvZiBmYWtlIHJvdyBlbGVtZW50cyB0aGF0IG11c3QgY29tcGVuc2F0ZSB3aGVuIHNjcm9sbGVyIGhhcyBzY3JvbGxiYXJzXHJcbiAgICAgICAgdmFyIG5vU2Nyb2xsUm93RWxzID0gdGhpcy5lbC5maW5kKCcuZmMtcm93Om5vdCguZmMtc2Nyb2xsZXIgKiknKTtcclxuICAgICAgICAvLyByZXNldCBhbGwgZGltZW5zaW9ucyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYm90dG9tUnVsZUVsLmhpZGUoKTsgLy8gLnNob3coKSB3aWxsIGJlIGNhbGxlZCBsYXRlciBpZiB0aGlzIDxocj4gaXMgbmVjZXNzYXJ5XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpOyAvLyBzZXRzIGhlaWdodCB0byAnYXV0bycgYW5kIGNsZWFycyBvdmVyZmxvd1xyXG4gICAgICAgIHV0aWxfMS51bmNvbXBlbnNhdGVTY3JvbGwobm9TY3JvbGxSb3dFbHMpO1xyXG4gICAgICAgIC8vIGxpbWl0IG51bWJlciBvZiBldmVudHMgaW4gdGhlIGFsbC1kYXkgYXJlYVxyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8ga2lsbCB0aGUgXCJtb3JlXCIgcG9wb3ZlciBpZiBkaXNwbGF5ZWRcclxuICAgICAgICAgICAgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XHJcbiAgICAgICAgICAgIGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRMaW1pdCA9IEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUOyAvLyBtYWtlIHN1cmUgXCJhdXRvXCIgZ29lcyB0byBhIHJlYWwgbnVtYmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50TGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGhzID0gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgYWxsLWRheSBhbmQgaGVhZGVyIHJvd3MgbGluZXMgdXBcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5jb21wZW5zYXRlU2Nyb2xsKG5vU2Nyb2xsUm93RWxzLCBzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjaGFuZ2VkIHRleHQgZmxvdywgd2hpY2ggbWlnaHQgYWZmZWN0IGhlaWdodCwgc28gcmVjYWxjdWxhdGVcclxuICAgICAgICAgICAgICAgIC8vIGFuZCByZWFwcGx5IHRoZSBkZXNpcmVkIGhlaWdodCB0byB0aGUgc2Nyb2xsZXIuXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVzIHRoZSBzYW1lIHNjcm9sbGJhciB3aWR0aHNcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgc3BhY2UgYmVsb3cgdGhlIHNsYXRzLCBzaG93IHRoZSBob3Jpem9udGFsIHJ1bGUuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgd29uJ3QgY2F1c2UgYW55IG5ldyBvdmVyZmxvdywgYmVjYXVzZSBsb2NrT3ZlcmZsb3cgYWxyZWFkeSBjYWxsZWQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVHcmlkLmdldFRvdGFsU2xhdEhlaWdodCgpIDwgc2Nyb2xsZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZUdyaWQuYm90dG9tUnVsZUVsLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBnaXZlbiBhIGRlc2lyZWQgdG90YWwgaGVpZ2h0IG9mIHRoZSB2aWV3LCByZXR1cm5zIHdoYXQgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsZXIgc2hvdWxkIGJlXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsZXJIZWlnaHQgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdG90YWxIZWlnaHQgLVxyXG4gICAgICAgICAgICB1dGlsXzEuc3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXHJcbiAgICB9O1xyXG4gICAgLyogU2Nyb2xsXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGluaXRpYWwgcHJlLWNvbmZpZ3VyZWQgc2Nyb2xsIHN0YXRlIHByaW9yIHRvIGFsbG93aW5nIHRoZSB1c2VyIHRvIGNoYW5nZSBpdFxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY3JvbGxUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdzY3JvbGxUaW1lJykpO1xyXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLnRpbWVHcmlkLmNvbXB1dGVUaW1lVG9wKHNjcm9sbFRpbWUpO1xyXG4gICAgICAgIC8vIHpvb20gY2FuIGdpdmUgd2VpcmQgZmxvYXRpbmctcG9pbnQgdmFsdWVzLiByYXRoZXIgc2Nyb2xsIGEgbGl0dGxlIGJpdCBmdXJ0aGVyXHJcbiAgICAgICAgdG9wID0gTWF0aC5jZWlsKHRvcCk7XHJcbiAgICAgICAgaWYgKHRvcCkge1xyXG4gICAgICAgICAgICB0b3ArKzsgLy8gdG8gb3ZlcmNvbWUgdG9wIGJvcmRlciB0aGF0IHNsb3RzIGJleW9uZCB0aGUgZmlyc3QgaGF2ZS4gbG9va3MgYmV0dGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHRvcDogdG9wIH07XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucXVlcnlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxUb3AoKSB9O1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHNjcm9sbC50b3ApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBIaXQgQXJlYXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBmb3J3YXJkIGFsbCBoaXQtcmVsYXRlZCBtZXRob2QgY2FsbHMgdG8gdGhlIGdyaWRzIChkYXlHcmlkIG1pZ2h0IG5vdCBiZSBkZWZpbmVkKVxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIFRPRE86IGhpdC5jb21wb25lbnQgaXMgc2V0IGFzIGEgaGFjayB0byBpZGVudGlmeSB3aGVyZSB0aGUgaGl0IGNhbWUgZnJvbVxyXG4gICAgICAgIHJldHVybiBoaXQuY29tcG9uZW50LmdldEhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIFRPRE86IGhpdC5jb21wb25lbnQgaXMgc2V0IGFzIGEgaGFjayB0byBpZGVudGlmeSB3aGVyZSB0aGUgaGl0IGNhbWUgZnJvbVxyXG4gICAgICAgIHJldHVybiBoaXQuY29tcG9uZW50LmdldEhpdEVsKGhpdCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50UmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgZGF5RXZlbnRzUGF5bG9hZCA9IHt9O1xyXG4gICAgICAgIHZhciB0aW1lZEV2ZW50c1BheWxvYWQgPSB7fTtcclxuICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAvLyBzZXBhcmF0ZSB0aGUgZXZlbnRzIGludG8gYWxsLWRheSBhbmQgdGltZWRcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRzUGF5bG9hZFtpZF07XHJcbiAgICAgICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXAuZ2V0RXZlbnREZWYoKS5pc0FsbERheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlFdmVudHNQYXlsb2FkW2lkXSA9IGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRpbWVkRXZlbnRzUGF5bG9hZFtpZF0gPSBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5leGVjdXRlRXZlbnRSZW5kZXIodGltZWRFdmVudHNQYXlsb2FkKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5leGVjdXRlRXZlbnRSZW5kZXIoZGF5RXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIERyYWdnaW5nL1Jlc2l6aW5nIFJvdXRpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IGdyb3VwRXZlbnRGb290cHJpbnRzQnlBbGxEYXkoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICB2YXIgcmVuZGVyZWRIZWxwZXIgPSBmYWxzZTtcclxuICAgICAgICByZW5kZXJlZEhlbHBlciA9IHRoaXMudGltZUdyaWQucmVuZGVyRHJhZyhncm91cHMudGltZWQsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICByZW5kZXJlZEhlbHBlciA9IHRoaXMuZGF5R3JpZC5yZW5kZXJEcmFnKGdyb3Vwcy5hbGxEYXksIHNlZywgaXNUb3VjaCkgfHwgcmVuZGVyZWRIZWxwZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZEhlbHBlcjtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBncm91cHMgPSBncm91cEV2ZW50Rm9vdHByaW50c0J5QWxsRGF5KGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5yZW5kZXJFdmVudFJlc2l6ZShncm91cHMudGltZWQsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVuZGVyRXZlbnRSZXNpemUoZ3JvdXBzLmFsbERheSwgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogU2VsZWN0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFnZW5kYVZpZXc7XHJcbn0oVmlld18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQWdlbmRhVmlldztcclxuQWdlbmRhVmlldy5wcm90b3R5cGUudGltZUdyaWRDbGFzcyA9IFRpbWVHcmlkXzEuZGVmYXVsdDtcclxuQWdlbmRhVmlldy5wcm90b3R5cGUuZGF5R3JpZENsYXNzID0gRGF5R3JpZF8xLmRlZmF1bHQ7XHJcbi8vIFdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEFnZW5kYVZpZXcncyB0aW1lR3JpZFxyXG5hZ2VuZGFUaW1lR3JpZE1ldGhvZHMgPSB7XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXHJcbiAgICByZW5kZXJIZWFkSW50cm9IdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgd2Vla1N0YXJ0ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0aGlzLmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTtcclxuICAgICAgICB2YXIgd2Vla1RleHQ7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCd3ZWVrTnVtYmVycycpKSB7XHJcbiAgICAgICAgICAgIHdlZWtUZXh0ID0gd2Vla1N0YXJ0LmZvcm1hdCh0aGlzLm9wdCgnc21hbGxXZWVrRm9ybWF0JykpO1xyXG4gICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImZjLWF4aXMgZmMtd2Vlay1udW1iZXIgJyArIGNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgIHsgZGF0ZTogd2Vla1N0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiB0aGlzLmNvbENudCA+IDEgfSwgdXRpbF8xLmh0bWxFc2NhcGUod2Vla1RleHQpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGg+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPHRoIGNsYXNzPVwiZmMtYXhpcyAnICsgY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90aD4nO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYmcgb2YgdGhlIFRpbWVHcmlkIHNsb3QgYXJlYS4gTG9uZyB2ZXJ0aWNhbCBjb2x1bW4uXHJcbiAgICByZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgfSxcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cclxuICAgIC8vIEFmZmVjdHMgY29udGVudC1za2VsZXRvbiwgaGVscGVyLXNrZWxldG9uLCBoaWdobGlnaHQtc2tlbGV0b24gZm9yIGJvdGggdGhlIHRpbWUtZ3JpZCBhbmQgZGF5LWdyaWQuXHJcbiAgICByZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXNcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgIH1cclxufTtcclxuLy8gV2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQWdlbmRhVmlldydzIGRheUdyaWRcclxuYWdlbmRhRGF5R3JpZE1ldGhvZHMgPSB7XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYWxsLWRheSBjZWxsc1xyXG4gICAgcmVuZGVyQmdJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgdmlldy5nZXRBbGxEYXlIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgfSxcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cclxuICAgIC8vIEFmZmVjdHMgY29udGVudC1za2VsZXRvbiwgaGVscGVyLXNrZWxldG9uLCBoaWdobGlnaHQtc2tlbGV0b24gZm9yIGJvdGggdGhlIHRpbWUtZ3JpZCBhbmQgZGF5LWdyaWQuXHJcbiAgICByZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXNcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gZ3JvdXBFdmVudEZvb3RwcmludHNCeUFsbERheShldmVudEZvb3RwcmludHMpIHtcclxuICAgIHZhciBhbGxEYXkgPSBbXTtcclxuICAgIHZhciB0aW1lZCA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgYWxsRGF5LnB1c2goZXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRpbWVkLnB1c2goZXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhbGxEYXk6IGFsbERheSwgdGltZWQ6IHRpbWVkIH07XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxudmFyIERheVRhYmxlTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgVGltZUdyaWRFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Nik7XHJcbnZhciBUaW1lR3JpZEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Nyk7XHJcbnZhciBUaW1lR3JpZEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDgpO1xyXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBXZSBtaXhpbiBEYXlUYWJsZSwgZXZlbiB0aG91Z2ggdGhlcmUgaXMgb25seSBhIHNpbmdsZSByb3cgb2YgZGF5c1xyXG4vLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxyXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcclxudmFyIEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TID0gW1xyXG4gICAgeyBob3VyczogMSB9LFxyXG4gICAgeyBtaW51dGVzOiAzMCB9LFxyXG4gICAgeyBtaW51dGVzOiAxNSB9LFxyXG4gICAgeyBzZWNvbmRzOiAzMCB9LFxyXG4gICAgeyBzZWNvbmRzOiAxNSB9XHJcbl07XHJcbnZhciBUaW1lR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVHcmlkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZUdyaWQodmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucHJvY2Vzc09wdGlvbnMoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlQnlUaW1lcyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgc2Vnc1tpXS5jb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2Vnc1tpXS5kYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NbaV0uY29sID0gc2Vnc1tpXS5kYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIEhhbmRsaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnNsaWNlUmFuZ2VCeVRpbWVzID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHNlZ1JhbmdlO1xyXG4gICAgICAgIHZhciBkYXlJbmRleDtcclxuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCB0aGlzLmRheXNQZXJSb3c7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgc2VnUmFuZ2UgPSB1bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KHRoaXMuZGF5UmFuZ2VzW2RheUluZGV4XSk7XHJcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1zOiBzZWdSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1zOiBzZWdSYW5nZS5lbmRNcyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdSYW5nZS5pc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5pc0VuZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleDogZGF5SW5kZXhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8qIE9wdGlvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBQYXJzZXMgdmFyaW91cyBvcHRpb25zIGludG8gcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzbG90RHVyYXRpb24gPSB0aGlzLm9wdCgnc2xvdER1cmF0aW9uJyk7XHJcbiAgICAgICAgdmFyIHNuYXBEdXJhdGlvbiA9IHRoaXMub3B0KCdzbmFwRHVyYXRpb24nKTtcclxuICAgICAgICB2YXIgaW5wdXQ7XHJcbiAgICAgICAgc2xvdER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uID8gbW9tZW50LmR1cmF0aW9uKHNuYXBEdXJhdGlvbikgOiBzbG90RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbG90RHVyYXRpb24gPSBzbG90RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbmFwc1BlclNsb3QgPSBzbG90RHVyYXRpb24gLyBzbmFwRHVyYXRpb247IC8vIFRPRE86IGVuc3VyZSBhbiBpbnRlZ2VyIG11bHRpcGxlP1xyXG4gICAgICAgIC8vIG1pZ2h0IGJlIGFuIGFycmF5IHZhbHVlIChmb3IgVGltZWxpbmVWaWV3KS5cclxuICAgICAgICAvLyBpZiBzbywgZ2V0dGluZyB0aGUgbW9zdCBncmFudWxhciBlbnRyeSAodGhlIGxhc3Qgb25lIHByb2JhYmx5KS5cclxuICAgICAgICBpbnB1dCA9IHRoaXMub3B0KCdzbG90TGFiZWxGb3JtYXQnKTtcclxuICAgICAgICBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0ID0gaW5wdXQgfHxcclxuICAgICAgICAgICAgdGhpcy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpOyAvLyB0aGUgY29tcHV0ZWQgZGVmYXVsdFxyXG4gICAgICAgIGlucHV0ID0gdGhpcy5vcHQoJ3Nsb3RMYWJlbEludGVydmFsJyk7XHJcbiAgICAgICAgdGhpcy5sYWJlbEludGVydmFsID0gaW5wdXQgP1xyXG4gICAgICAgICAgICBtb21lbnQuZHVyYXRpb24oaW5wdXQpIDpcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlTGFiZWxJbnRlcnZhbChzbG90RHVyYXRpb24pO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlTGFiZWxJbnRlcnZhbCA9IGZ1bmN0aW9uIChzbG90RHVyYXRpb24pIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGFiZWxJbnRlcnZhbDtcclxuICAgICAgICB2YXIgc2xvdHNQZXJMYWJlbDtcclxuICAgICAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBzdG9jayBsYWJlbCBpbnRlcnZhbCB0aGF0IHJlc3VsdHMgaW4gbW9yZSB0aGFuIG9uZSBzbG90cy1wZXItbGFiZWxcclxuICAgICAgICBmb3IgKGkgPSBBR0VOREFfU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBsYWJlbEludGVydmFsID0gbW9tZW50LmR1cmF0aW9uKEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TW2ldKTtcclxuICAgICAgICAgICAgc2xvdHNQZXJMYWJlbCA9IHV0aWxfMS5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24obGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0ludChzbG90c1BlckxhYmVsKSAmJiBzbG90c1BlckxhYmVsID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbihzbG90RHVyYXRpb24pOyAvLyBmYWxsIGJhY2suIGNsb25lXHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXlUYWJsZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2xhdHMoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckNvbHVtbnMoKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyB0aGlzLnVucmVuZGVyU2xhdHMoKTsgLy8gZG9uJ3QgbmVlZCB0aGlzIGJlY2F1c2UgcmVwZWF0ZWQgLmh0bWwoKSBjYWxscyBjbGVhclxyXG4gICAgICAgIHRoaXMudW5yZW5kZXJDb2x1bW5zKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB0aGlzLmVsLmh0bWwoJzxkaXYgY2xhc3M9XCJmYy1iZ1wiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXNsYXRzXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiAvPicpO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUnVsZUVsID0gdGhpcy5lbC5maW5kKCdocicpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTbGF0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJz4gLmZjLXNsYXRzJylcclxuICAgICAgICAgICAgLmh0bWwoLy8gYXZvaWRzIG5lZWRpbmcgOjp1bnJlbmRlclNsYXRzKClcclxuICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTbGF0Um93SHRtbCgpICtcclxuICAgICAgICAgICAgJzwvdGFibGU+Jyk7XHJcbiAgICAgICAgdGhpcy5zbGF0RWxzID0gdGhpcy5zbGF0Q29udGFpbmVyRWwuZmluZCgndHInKTtcclxuICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLnNsYXRFbHMsXHJcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTbGF0Um93SHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IGNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciBpc1JUTCA9IHRoaXMuaXNSVEw7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciBzbG90VGltZSA9IG1vbWVudC5kdXJhdGlvbigrZGF0ZVByb2ZpbGUubWluVGltZSk7IC8vIHdpc2ggdGhlcmUgd2FzIC5jbG9uZSgpIGZvciBkdXJhdGlvbnNcclxuICAgICAgICB2YXIgc2xvdEl0ZXJhdG9yID0gbW9tZW50LmR1cmF0aW9uKDApO1xyXG4gICAgICAgIHZhciBzbG90RGF0ZTsgLy8gd2lsbCBiZSBvbiB0aGUgdmlldydzIGZpcnN0IGRheSwgYnV0IHdlIG9ubHkgY2FyZSBhYm91dCBpdHMgdGltZVxyXG4gICAgICAgIHZhciBpc0xhYmVsZWQ7XHJcbiAgICAgICAgdmFyIGF4aXNIdG1sO1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGltZSBmb3IgZWFjaCBzbG90XHJcbiAgICAgICAgd2hpbGUgKHNsb3RUaW1lIDwgZGF0ZVByb2ZpbGUubWF4VGltZSkge1xyXG4gICAgICAgICAgICBzbG90RGF0ZSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQoZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMpLnRpbWUoc2xvdFRpbWUpO1xyXG4gICAgICAgICAgICBpc0xhYmVsZWQgPSB1dGlsXzEuaXNJbnQodXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihzbG90SXRlcmF0b3IsIHRoaXMubGFiZWxJbnRlcnZhbCkpO1xyXG4gICAgICAgICAgICBheGlzSHRtbCA9XHJcbiAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtYXhpcyBmYy10aW1lICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzTGFiZWxlZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUoc2xvdERhdGUuZm9ybWF0KHRoaXMubGFiZWxGb3JtYXQpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgICAgIGh0bWwgKz1cclxuICAgICAgICAgICAgICAgICc8dHIgZGF0YS10aW1lPVwiJyArIHNsb3REYXRlLmZvcm1hdCgnSEg6bW06c3MnKSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpc0xhYmVsZWQgPyAnJyA6ICcgY2xhc3M9XCJmYy1taW5vclwiJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKCFpc1JUTCA/IGF4aXNIdG1sIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIvPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpc1JUTCA/IGF4aXNIdG1sIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgICAgICAgICBzbG90VGltZS5hZGQodGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBzbG90SXRlcmF0b3IuYWRkKHRoaXMuc2xvdER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdGhpcy5kYXlSYW5nZXMgPSB0aGlzLmRheURhdGVzLm1hcChmdW5jdGlvbiAoZGF5RGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF5RGF0ZS5jbG9uZSgpLmFkZChkYXRlUHJvZmlsZS5taW5UaW1lKSwgZGF5RGF0ZS5jbG9uZSgpLmFkZChkYXRlUHJvZmlsZS5tYXhUaW1lKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZENvbnRhaW5lckVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZENvbnRhaW5lckVsLmh0bWwodGhpcy5yZW5kZXJIZWFkSHRtbCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCc+IC5mYy1iZycpLmh0bWwoJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmdUckh0bWwoMCkgKyAvLyByb3c9MFxyXG4gICAgICAgICAgICAnPC90YWJsZT4nKTtcclxuICAgICAgICB0aGlzLmNvbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5jb2xFbHMsXHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ29udGVudFNrZWxldG9uKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQ29udGVudFNrZWxldG9uKCk7XHJcbiAgICB9O1xyXG4gICAgLyogQ29udGVudCBTa2VsZXRvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgdGhlIERPTSB0aGF0IHRoZSB2aWV3J3MgY29udGVudCB3aWxsIGxpdmUgaW5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJDb250ZW50U2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNlbGxIdG1sID0gJyc7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29sQ250OyBpKyspIHtcclxuICAgICAgICAgICAgY2VsbEh0bWwgKz1cclxuICAgICAgICAgICAgICAgICc8dGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LWNvbFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyIGZjLWhlbHBlci1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtaGlnaGxpZ2h0LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJ1c2luZXNzLWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBza2VsZXRvbkVsID0gdGhpcy5jb250ZW50U2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LXNrZWxldG9uXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGU+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArIGNlbGxIdG1sICsgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgdGhpcy5jb2xDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1jb250ZW50LWNvbCcpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGVscGVyLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1ldmVudC1jb250YWluZXI6bm90KC5mYy1oZWxwZXItY29udGFpbmVyKScpO1xyXG4gICAgICAgIHRoaXMuYmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1iZ2V2ZW50LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1idXNpbmVzcy1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmJvb2tlbmRDZWxscyhza2VsZXRvbkVsLmZpbmQoJ3RyJykpOyAvLyBUT0RPOiBkbyB0aGlzIG9uIHN0cmluZyBsZXZlbFxyXG4gICAgICAgIHRoaXMuZWwuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckNvbnRlbnRTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb250ZW50U2tlbGV0b25FbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb2xDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBlckNvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCByZXR1cm4gYW4gYXJyYXkgb2Ygc3ViLWFycmF5cywgZ3JvdXBlZCBieSBlYWNoIHNlZ21lbnQncyBjb2xcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5ncm91cFNlZ3NCeUNvbCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3NCeUNvbCA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3NCeUNvbC5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Vnc0J5Q29sO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHNlZ21lbnRzIGdyb3VwZWQgYnkgY29sdW1uLCBpbnNlcnQgdGhlIHNlZ21lbnRzJyBlbGVtZW50cyBpbnRvIGEgcGFyYWxsZWwgYXJyYXkgb2YgY29udGFpbmVyXHJcbiAgICAvLyBlbGVtZW50cywgZWFjaCBsaXZpbmcgd2l0aGluIGEgY29sdW1uLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmF0dGFjaFNlZ3NCeUNvbCA9IGZ1bmN0aW9uIChzZWdzQnlDb2wsIGNvbnRhaW5lckVscykge1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIHNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgc2VncyA9IHNlZ3NCeUNvbFtjb2xdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxzLmVxKGNvbCkuYXBwZW5kKHNlZ3NbaV0uZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0Tm93SW5kaWNhdG9yVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ21pbnV0ZSc7IC8vIHdpbGwgcmVmcmVzaCBvbiB0aGUgbWludXRlXHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgLy8gSEFDSzogaWYgZGF0ZSBjb2x1bW5zIG5vdCByZWFkeSBmb3Igc29tZSByZWFzb24gKHNjaGVkdWxlcilcclxuICAgICAgICBpZiAoIXRoaXMuY29sQ29udGFpbmVyRWxzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2VnIHN5c3RlbSBtaWdodCBiZSBvdmVya2lsbCwgYnV0IGl0IGhhbmRsZXMgc2NlbmFyaW8gd2hlcmUgbGluZSBuZWVkcyB0byBiZSByZW5kZXJlZFxyXG4gICAgICAgIC8vICBtb3JlIHRoYW4gb25jZSBiZWNhdXNlIG9mIGNvbHVtbnMgd2l0aCB0aGUgc2FtZSBkYXRlIChyZXNvdXJjZXMgY29sdW1ucyBmb3IgZXhhbXBsZSlcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KGRhdGUsIGRhdGUudmFsdWVPZigpICsgMSksIC8vIHByb3RlY3QgYWdhaW5zdCBudWxsIHJhbmdlXHJcbiAgICAgICAgZmFsc2UgLy8gYWxsLWRheVxyXG4gICAgICAgICkpO1xyXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKGRhdGUsIGRhdGUpO1xyXG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlbmRlciBsaW5lcyB3aXRoaW4gdGhlIGNvbHVtbnNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKCQoJzxkaXYgY2xhc3M9XCJmYy1ub3ctaW5kaWNhdG9yIGZjLW5vdy1pbmRpY2F0b3ItbGluZVwiPjwvZGl2PicpXHJcbiAgICAgICAgICAgICAgICAuY3NzKCd0b3AnLCB0b3ApXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy5jb2xDb250YWluZXJFbHMuZXEoc2Vnc1tpXS5jb2wpKVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbmRlciBhbiBhcnJvdyBvdmVyIHRoZSBheGlzXHJcbiAgICAgICAgaWYgKHNlZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKCQoJzxkaXYgY2xhc3M9XCJmYy1ub3ctaW5kaWNhdG9yIGZjLW5vdy1pbmRpY2F0b3ItYXJyb3dcIj48L2Rpdj4nKVxyXG4gICAgICAgICAgICAgICAgLmNzcygndG9wJywgdG9wKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWwuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24nKSlbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscyA9ICQobm9kZXMpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JFbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JFbHMucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogQ29vcmRpbmF0ZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgaWYgKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VnVmVydGljYWxzKFtdLmNvbmNhdCh0aGlzLmV2ZW50UmVuZGVyZXIuZ2V0U2VncygpLCB0aGlzLmJ1c2luZXNzU2VncyB8fCBbXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0VG90YWxTbGF0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNsYXRDb250YWluZXJFbC5vdXRlckhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBgbXNgIGNhbiBiZSBhIG1pbGxpc2Vjb25kIFVUQyB0aW1lIE9SIGEgVVRDIG1vbWVudC5cclxuICAgIC8vIEEgYHN0YXJ0T2ZEYXlEYXRlYCBtdXN0IGJlIGdpdmVuIGZvciBhdm9pZGluZyBhbWJpZ3VpdHkgb3ZlciBob3cgdG8gdHJlYXQgbWlkbmlnaHQuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZURhdGVUb3AgPSBmdW5jdGlvbiAobXMsIHN0YXJ0T2ZEYXlEYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVRpbWVUb3AobW9tZW50LmR1cmF0aW9uKG1zIC0gc3RhcnRPZkRheURhdGUuY2xvbmUoKS5zdHJpcFRpbWUoKSkpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIHRpbWUgKGEgRHVyYXRpb24pLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVUaW1lVG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5zbGF0RWxzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBzbGF0Q292ZXJhZ2UgPSAodGltZSAtIGRhdGVQcm9maWxlLm1pblRpbWUpIC8gdGhpcy5zbG90RHVyYXRpb247IC8vIGZsb2F0aW5nLXBvaW50IHZhbHVlIG9mICMgb2Ygc2xvdHMgY292ZXJlZFxyXG4gICAgICAgIHZhciBzbGF0SW5kZXg7XHJcbiAgICAgICAgdmFyIHNsYXRSZW1haW5kZXI7XHJcbiAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cclxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXHJcbiAgICAgICAgLy8gY29uc3RyYWluZWQgYmVjYXVzZSBtaW5UaW1lL21heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cclxuICAgICAgICBzbGF0Q292ZXJhZ2UgPSBNYXRoLm1heCgwLCBzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcclxuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XHJcbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBzbGF0cyAoKmV4Y2x1c2l2ZSosIHNvIGxlbi0xKVxyXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcclxuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xyXG4gICAgICAgIC8vIGhvdyBtdWNoIGZ1cnRoZXIgdGhyb3VnaCB0aGUgc2xhdEluZGV4IHNsYXQgKGZyb20gMC4wLTEuMCkgbXVzdCBiZSBjb3ZlcmVkIGluIGFkZGl0aW9uLlxyXG4gICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXHJcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcclxuICAgICAgICByZXR1cm4gdGhpcy5zbGF0Q29vcmRDYWNoZS5nZXRUb3BQb3NpdGlvbihzbGF0SW5kZXgpICtcclxuICAgICAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVmcmVzaGVzIHRoZSBDU1MgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBmb3IgZWFjaCBzZWdtZW50IGVsZW1lbnQuXHJcbiAgICAvLyBXb3JrcyB3aGVuIGNhbGxlZCBhZnRlciBpbml0aWFsIHJlbmRlciwgYWZ0ZXIgYSB3aW5kb3cgcmVzaXplL3pvb20gZm9yIGV4YW1wbGUuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudXBkYXRlU2VnVmVydGljYWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB0aGlzLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICAgICAgdGhpcy5hc3NpZ25TZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRm9yIGVhY2ggc2VnbWVudCBpbiBhbiBhcnJheSwgY29tcHV0ZXMgYW5kIGFzc2lnbnMgaXRzIHRvcCBhbmQgYm90dG9tIHByb3BlcnRpZXNcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlU2VnVmVydGljYWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgZXZlbnRNaW5IZWlnaHQgPSB0aGlzLm9wdCgnYWdlbmRhRXZlbnRNaW5IZWlnaHQnKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBkYXlEYXRlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIGRheURhdGUgPSB0aGlzLmRheURhdGVzW3NlZy5kYXlJbmRleF07XHJcbiAgICAgICAgICAgIHNlZy50b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydE1zLCBkYXlEYXRlKTtcclxuICAgICAgICAgICAgc2VnLmJvdHRvbSA9IE1hdGgubWF4KHNlZy50b3AgKyBldmVudE1pbkhlaWdodCwgdGhpcy5jb21wdXRlRGF0ZVRvcChzZWcuZW5kTXMsIGRheURhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhbHJlYWR5IGhhdmUgdGhlaXIgdG9wL2JvdHRvbSBwcm9wZXJ0aWVzIGNvbXB1dGVkLCBhcHBsaWVzIHRob3NlIHZhbHVlcyB0b1xyXG4gICAgLy8gdGhlIHNlZ21lbnRzJyBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5hc3NpZ25TZWdWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgc2VnLmVsLmNzcyh0aGlzLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBDU1MgcHJvcGVydGllcyBmb3IgdGhlIHRvcC9ib3R0b20gY29vcmRpbmF0ZXMgb2YgYSBzZWdtZW50IGVsZW1lbnRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvcDogc2VnLnRvcCxcclxuICAgICAgICAgICAgYm90dG9tOiAtc2VnLmJvdHRvbSAvLyBmbGlwcGVkIGJlY2F1c2UgbmVlZHMgdG8gYmUgc3BhY2UgYmV5b25kIGJvdHRvbSBlZGdlIG9mIGV2ZW50IGNvbnRhaW5lclxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyogSGl0IFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUuYnVpbGQoKTtcclxuICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgIC8vIE5PVEU6IGRvbid0IGNsZWFyIHNsYXRDb29yZENhY2hlIGJlY2F1c2Ugd2UgcmVseSBvbiBpdCBmb3IgY29tcHV0ZVRpbWVUb3BcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAobGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHNuYXBzUGVyU2xvdCA9IHRoaXMuc25hcHNQZXJTbG90O1xyXG4gICAgICAgIHZhciBjb2xDb29yZENhY2hlID0gdGhpcy5jb2xDb29yZENhY2hlO1xyXG4gICAgICAgIHZhciBzbGF0Q29vcmRDYWNoZSA9IHRoaXMuc2xhdENvb3JkQ2FjaGU7XHJcbiAgICAgICAgaWYgKGNvbENvb3JkQ2FjaGUuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgc2xhdENvb3JkQ2FjaGUuaXNUb3BJbkJvdW5kcyh0b3BPZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xJbmRleCA9IGNvbENvb3JkQ2FjaGUuZ2V0SG9yaXpvbnRhbEluZGV4KGxlZnRPZmZzZXQpO1xyXG4gICAgICAgICAgICB2YXIgc2xhdEluZGV4ID0gc2xhdENvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsYXRUb3AgPSBzbGF0Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQoc2xhdEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciBzbGF0SGVpZ2h0ID0gc2xhdENvb3JkQ2FjaGUuZ2V0SGVpZ2h0KHNsYXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydGlhbCA9ICh0b3BPZmZzZXQgLSBzbGF0VG9wKSAvIHNsYXRIZWlnaHQ7IC8vIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFNuYXBJbmRleCA9IE1hdGguZmxvb3IocGFydGlhbCAqIHNuYXBzUGVyU2xvdCk7IC8vIHRoZSBzbmFwICMgcmVsYXRpdmUgdG8gc3RhcnQgb2Ygc2xhdFxyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBJbmRleCA9IHNsYXRJbmRleCAqIHNuYXBzUGVyU2xvdCArIGxvY2FsU25hcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBUb3AgPSBzbGF0VG9wICsgKGxvY2FsU25hcEluZGV4IC8gc25hcHNQZXJTbG90KSAqIHNsYXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc25hcEJvdHRvbSA9IHNsYXRUb3AgKyAoKGxvY2FsU25hcEluZGV4ICsgMSkgLyBzbmFwc1BlclNsb3QpICogc2xhdEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2xJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBzbmFwOiBzbmFwSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbENvb3JkQ2FjaGUuZ2V0TGVmdE9mZnNldChjb2xJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3JkQ2FjaGUuZ2V0UmlnaHRPZmZzZXQoY29sSW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc25hcFRvcCxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHNuYXBCb3R0b21cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKDAsIGhpdC5jb2wpOyAvLyByb3c9MFxyXG4gICAgICAgIHZhciB0aW1lID0gdGhpcy5jb21wdXRlU25hcFRpbWUoaGl0LnNuYXApOyAvLyBwYXNzIGluIHRoZSBzbmFwLWluZGV4XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBzdGFydC50aW1lKHRpbWUpO1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuc25hcER1cmF0aW9uKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCksIGZhbHNlIC8vIGFsbC1kYXk/XHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIHJvdyBudW1iZXIgb2YgdGhlIGdyaWQsIHJlcHJlc2VudGluZyBhIFwic25hcFwiLCByZXR1cm5zIGEgdGltZSAoRHVyYXRpb24pIGZyb20gaXRzIHN0YXJ0LW9mLWRheVxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVTbmFwVGltZSA9IGZ1bmN0aW9uIChzbmFwSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHRoaXMuZGF0ZVByb2ZpbGUubWluVGltZSArIHRoaXMuc25hcER1cmF0aW9uICogc25hcEluZGV4KTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sRWxzLmVxKGhpdC5jb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyBkcmFnZ2VkIG92ZXIgdGhlIHNwZWNpZmllZCBkYXRlKHMpLlxyXG4gICAgLy8gQSByZXR1cm5lZCB2YWx1ZSBvZiBgdHJ1ZWAgc2lnbmFscyB0aGF0IGEgbW9jayBcImhlbHBlclwiIGV2ZW50IGhhcyBiZWVuIHJlbmRlcmVkLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2VnKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudEZvb3RwcmludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnJlbmRlckV2ZW50RHJhZ2dpbmdGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IGEgaGVscGVyIGhhcyBiZWVuIHJlbmRlcmVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyBkcmFnZ2VkXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVzaXplIFZpc3VhbGl6YXRpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgLyogU2VsZWN0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uLiBPdmVycmlkZXMgdGhlIGRlZmF1bHQsIHdoaWNoIHdhcyB0byBzaW1wbHkgcmVuZGVyIGEgaGlnaGxpZ2h0LlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ3NlbGVjdEhlbHBlcicpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyQ29tcG9uZW50Rm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWQ7XHJcbn0oSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZDtcclxuVGltZUdyaWQucHJvdG90eXBlLmV2ZW50UmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzID0gQnVzaW5lc3NIb3VyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuaGVscGVyUmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkSGVscGVyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuZmlsbFJlbmRlcmVyQ2xhc3MgPSBUaW1lR3JpZEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oVGltZUdyaWQpO1xyXG5EYXlUYWJsZU1peGluXzEuZGVmYXVsdC5taXhJbnRvKFRpbWVHcmlkKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIxKTtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlclVuem9uZWRSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5jYWxsKHRoaXMsIGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpOyAvLyBhbiBVbnpvbmVkUmFuZ2VcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLmVuZE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RhcnRPZignd2VlaycpO1xyXG4gICAgICAgICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XHJcbiAgICAgICAgICAgIGlmIChlbmQud2Vla2RheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuYWRkKDEsICd3ZWVrJykuc3RhcnRPZignd2VlaycpOyAvLyBleGNsdXNpdmVseSBtb3ZlIGJhY2t3YXJkc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XHJcbnZhciBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTMpO1xyXG4vKiBBIG1vbnRoIHZpZXcgd2l0aCBkYXkgY2VsbHMgcnVubmluZyBpbiByb3dzIChvbmUtcGVyLXdlZWspIGFuZCBjb2x1bW5zXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgTW9udGhWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW9udGhWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9udGhWaWV3KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBCYXNpY1ZpZXcgYmVoYXZpb3IgdG8gaGF2ZSBzcGVjaWFsIG11bHRpLXdlZWsgYXV0by1oZWlnaHQgbG9naWNcclxuICAgIE1vbnRoVmlldy5wcm90b3R5cGUuc2V0R3JpZEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgIC8vIGlmIGF1dG8sIG1ha2UgdGhlIGhlaWdodCBvZiBlYWNoIHJvdyB0aGUgaGVpZ2h0IHRoYXQgaXQgd291bGQgYmUgaWYgdGhlcmUgd2VyZSA2IHdlZWtzXHJcbiAgICAgICAgaWYgKGlzQXV0bykge1xyXG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5kYXlHcmlkLnJvd0NudCAvIDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHV0aWxfMS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgIWlzQXV0byk7IC8vIGlmIGF1dG8sIGRvbid0IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3NcclxuICAgIH07XHJcbiAgICBNb250aFZpZXcucHJvdG90eXBlLmlzRGF0ZUluT3RoZXJNb250aCA9IGZ1bmN0aW9uIChkYXRlLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRlLm1vbnRoKCkgIT09IG1vbWVudC51dGMoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5zdGFydE1zKS5tb250aCgpOyAvLyBUT0RPOiBvcHRpbWl6ZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBNb250aFZpZXc7XHJcbn0oQmFzaWNWaWV3XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNb250aFZpZXc7XHJcbk1vbnRoVmlldy5wcm90b3R5cGUuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxuXG5cbi8qKiovIH0pLFxuLyogMjMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbnZhciBMaXN0RXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTQpO1xyXG52YXIgTGlzdEV2ZW50UG9pbnRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjU1KTtcclxuLypcclxuUmVzcG9uc2libGUgZm9yIHRoZSBzY3JvbGxlciwgYW5kIGZvcndhcmRpbmcgZXZlbnQtcmVsYXRlZCBhY3Rpb25zIGludG8gdGhlIFwiZ3JpZFwiLlxyXG4qL1xyXG52YXIgTGlzdFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0VmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyLCB2aWV3U3BlYykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zZWdTZWxlY3RvciA9ICcuZmMtbGlzdC1pdGVtJzsgLy8gd2hpY2ggZWxlbWVudHMgYWNjZXB0IGV2ZW50IGFjdGlvbnNcclxuICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1saXN0LXZpZXcgJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ2xpc3RWaWV3JykpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5lbC5hcHBlbmRUbyh0aGlzLmVsKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbCA9IHRoaXMuc2Nyb2xsZXIuc2Nyb2xsRWw7IC8vIHNob3J0Y3V0XHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnVucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7IC8vIHdpbGwgcmVtb3ZlIHRoZSBHcmlkIHRvb1xyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xlYXIoKTsgLy8gc2V0cyBoZWlnaHQgdG8gJ2F1dG8nIGFuZCBjbGVhcnMgb3ZlcmZsb3dcclxuICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodCh0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGRheVN0YXJ0ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudChkYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHZpZXdFbmQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KGRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGRheURhdGVzID0gW107XHJcbiAgICAgICAgdmFyIGRheVJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChkYXlTdGFydCA8IHZpZXdFbmQpIHtcclxuICAgICAgICAgICAgZGF5RGF0ZXMucHVzaChkYXlTdGFydC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgZGF5UmFuZ2VzLnB1c2gobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF5U3RhcnQsIGRheVN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXknKSkpO1xyXG4gICAgICAgICAgICBkYXlTdGFydC5hZGQoMSwgJ2RheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRheURhdGVzID0gZGF5RGF0ZXM7XHJcbiAgICAgICAgdGhpcy5kYXlSYW5nZXMgPSBkYXlSYW5nZXM7XHJcbiAgICAgICAgLy8gYWxsIHJlYWwgcmVuZGVyaW5nIGhhcHBlbnMgaW4gRXZlbnRSZW5kZXJlclxyXG4gICAgfTtcclxuICAgIC8vIHNsaWNlcyBieSBkYXlcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoZm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIGRheVJhbmdlcyA9IHRoaXMuZGF5UmFuZ2VzO1xyXG4gICAgICAgIHZhciBkYXlJbmRleDtcclxuICAgICAgICB2YXIgc2VnUmFuZ2U7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IGRheVJhbmdlcy5sZW5ndGg7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgc2VnUmFuZ2UgPSBmb290cHJpbnQudW56b25lZFJhbmdlLmludGVyc2VjdChkYXlSYW5nZXNbZGF5SW5kZXhdKTtcclxuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNczogc2VnUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgICAgICAgICBlbmRNczogc2VnUmFuZ2UuZW5kTXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2UuaXNTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXg6IGRheUluZGV4XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3Qgd2hlbiBmb290cHJpbnQgd29uJ3QgZ28gZnVsbHkgaW50byB0aGUgbmV4dCBkYXksXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgbXV0YXRlIHRoZSBsYXRlc3Qgc2VnIHRvIHRoZSBiZSB0aGUgZW5kLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWcuaXNFbmQgJiYgIWZvb3RwcmludC5pc0FsbERheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4ICsgMSA8IGRheVJhbmdlcy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICBmb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zIDwgZGF5UmFuZ2VzW2RheUluZGV4ICsgMV0uc3RhcnRNcyArIHRoaXMubmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbmRNcyA9IGZvb3RwcmludC51bnpvbmVkUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyRW1wdHlNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsLmh0bWwoJzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5LXdyYXAyXCI+JyArIC8vIFRPRE86IHRyeSBsZXNzIHdyYXBzXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eS13cmFwMVwiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHlcIj4nICtcclxuICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5vcHQoJ25vRXZlbnRzTWVzc2FnZScpKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gcmVuZGVyIHRoZSBldmVudCBzZWdtZW50cyBpbiB0aGUgdmlld1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlclNlZ0xpc3QgPSBmdW5jdGlvbiAoYWxsU2Vncykge1xyXG4gICAgICAgIHZhciBzZWdzQnlEYXkgPSB0aGlzLmdyb3VwU2Vnc0J5RGF5KGFsbFNlZ3MpOyAvLyBzcGFyc2UgYXJyYXlcclxuICAgICAgICB2YXIgZGF5SW5kZXg7XHJcbiAgICAgICAgdmFyIGRheVNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRhYmxlRWwgPSAkKCc8dGFibGUgY2xhc3M9XCJmYy1saXN0LXRhYmxlICcgKyB0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd0YWJsZUxpc3QnKSArICdcIj48dGJvZHkvPjwvdGFibGU+Jyk7XHJcbiAgICAgICAgdmFyIHRib2R5RWwgPSB0YWJsZUVsLmZpbmQoJ3Rib2R5Jyk7XHJcbiAgICAgICAgZm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgc2Vnc0J5RGF5Lmxlbmd0aDsgZGF5SW5kZXgrKykge1xyXG4gICAgICAgICAgICBkYXlTZWdzID0gc2Vnc0J5RGF5W2RheUluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGRheVNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcclxuICAgICAgICAgICAgICAgIHRib2R5RWwuYXBwZW5kKHRoaXMuZGF5SGVhZGVySHRtbCh0aGlzLmRheURhdGVzW2RheUluZGV4XSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnNvcnRFdmVudFNlZ3MoZGF5U2Vncyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF5U2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRib2R5RWwuYXBwZW5kKGRheVNlZ3NbaV0uZWwpOyAvLyBhcHBlbmQgZXZlbnQgcm93XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKS5hcHBlbmQodGFibGVFbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmdyb3VwU2Vnc0J5RGF5ID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5RGF5ID0gW107IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdIHx8IChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSA9IFtdKSlcclxuICAgICAgICAgICAgICAgIC5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzQnlEYXk7XHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgZGF5IGhlYWRlcnMgdGhhdCBsaXZlIGFtb25nc3QgdGhlIGV2ZW50IHJvd3NcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5kYXlIZWFkZXJIdG1sID0gZnVuY3Rpb24gKGRheURhdGUpIHtcclxuICAgICAgICB2YXIgbWFpbkZvcm1hdCA9IHRoaXMub3B0KCdsaXN0RGF5Rm9ybWF0Jyk7XHJcbiAgICAgICAgdmFyIGFsdEZvcm1hdCA9IHRoaXMub3B0KCdsaXN0RGF5QWx0Rm9ybWF0Jyk7XHJcbiAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCJmYy1saXN0LWhlYWRpbmdcIiBkYXRhLWRhdGU9XCInICsgZGF5RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyAodGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygndGFibGVMaXN0SGVhZGluZycpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpKSArICdcIiBjb2xzcGFuPVwiM1wiPicgK1xyXG4gICAgICAgICAgICAobWFpbkZvcm1hdCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkR290b0FuY2hvckh0bWwoZGF5RGF0ZSwgeyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLW1haW4nIH0sIHV0aWxfMS5odG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KG1haW5Gb3JtYXQpKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChhbHRGb3JtYXQgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEdvdG9BbmNob3JIdG1sKGRheURhdGUsIHsgJ2NsYXNzJzogJ2ZjLWxpc3QtaGVhZGluZy1hbHQnIH0sIHV0aWxfMS5odG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KGFsdEZvcm1hdCkpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RWaWV3O1xyXG5MaXN0Vmlldy5wcm90b3R5cGUuZXZlbnRSZW5kZXJlckNsYXNzID0gTGlzdEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5MaXN0Vmlldy5wcm90b3R5cGUuZXZlbnRQb2ludGluZ0NsYXNzID0gTGlzdEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0O1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzEgKi8sXG4vKiAyMzIgKi8sXG4vKiAyMzMgKi8sXG4vKiAyMzQgKi8sXG4vKiAyMzUgKi8sXG4vKiAyMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgZXhwb3J0SG9va3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDYWxlbmRhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjApO1xyXG4vLyBmb3IgaW50ZW50aW9uYWwgc2lkZS1lZmZlY3RzXHJcbl9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNTYpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI1Nyk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNjEpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2Mik7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjYzKTtcclxuJC5mdWxsQ2FsZW5kYXIgPSBleHBvcnRIb29rcztcclxuJC5mbi5mdWxsQ2FsZW5kYXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3IgYSBwb3NzaWJsZSBtZXRob2QgY2FsbFxyXG4gICAgdmFyIHJlcyA9IHRoaXM7IC8vIHdoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiAodGhpcyBqUXVlcnkgb2JqZWN0IGJ5IGRlZmF1bHQpXHJcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIF9lbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAkKF9lbGVtZW50KTtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSBlbGVtZW50LmRhdGEoJ2Z1bGxDYWxlbmRhcicpOyAvLyBnZXQgdGhlIGV4aXN0aW5nIGNhbGVuZGFyIG9iamVjdCAoaWYgYW55KVxyXG4gICAgICAgIHZhciBzaW5nbGVSZXM7IC8vIHRoZSByZXR1cm5lZCB2YWx1ZSBvZiB0aGlzIHNpbmdsZSBtZXRob2QgY2FsbFxyXG4gICAgICAgIC8vIGEgbWV0aG9kIGNhbGxcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSAnZ2V0Q2FsZW5kYXInKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBjYWxlbmRhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjYWxlbmRhcikge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oJ0F0dGVtcHRpbmcgdG8gY2FsbCBhIEZ1bGxDYWxlbmRhciBtZXRob2Qgb24gYW4gZWxlbWVudCB3aXRoIG5vIGNhbGVuZGFyLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihjYWxlbmRhcltvcHRpb25zXSkpIHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZVJlcyA9IGNhbGVuZGFyW29wdGlvbnNdLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHNpbmdsZVJlczsgLy8gcmVjb3JkIHRoZSBmaXJzdCBtZXRob2QgY2FsbCByZXN1bHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oXCInXCIgKyBvcHRpb25zICsgXCInIGlzIGFuIHVua25vd24gRnVsbENhbGVuZGFyIG1ldGhvZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgIGNhbGVuZGFyID0gbmV3IENhbGVuZGFyXzEuZGVmYXVsdChlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgZWxlbWVudC5kYXRhKCdmdWxsQ2FsZW5kYXInLCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGNhbGVuZGFyLnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRIb29rcztcclxuXG5cbi8qKiovIH0pLFxuLyogMjM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgTW9kZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xyXG52YXIgQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLmJpbmRHbG9iYWxIYW5kbGVycygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2tlbGV0b24oKTtcclxuICAgICAgICB0aGlzLnNldCgnaXNJbkRvbScsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KCdpc0luRG9tJyk7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlclNrZWxldG9uKCk7XHJcbiAgICAgICAgdGhpcy51bmJpbmRHbG9iYWxIYW5kbGVycygpO1xyXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgLy8gTk9URTogZG9uJ3QgbnVsbC1vdXQgdGhpcy5lbCBpbiBjYXNlIHRoZSBWaWV3IHdhcyBkZXN0cm95ZWQgd2l0aGluIGFuIEFQSSBjYWxsYmFjay5cclxuICAgICAgICAvLyBXZSBkb24ndCBudWxsLW91dCB0aGUgVmlldydzIG90aGVyIGpRdWVyeSBlbGVtZW50IHJlZmVyZW5jZXMgdXBvbiBkZXN0cm95LFxyXG4gICAgICAgIC8vICBzbyB3ZSBzaG91bGRuJ3Qga2lsbCB0aGlzLmVsIGVpdGhlci5cclxuICAgIH07XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTk9URTogQ2FuJ3QgaGF2ZSBhIGByZW5kZXJgIG1ldGhvZC4gUmVhZCB0aGUgZGVwcmVjYXRpb24gbm90aWNlIGluIFZpZXc6OmV4ZWN1dGVEYXRlUmVuZGVyXHJcbiAgICAqL1xyXG4gICAgLy8gUmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSB2aWV3IGJlZm9yZSBhbnkgY29udGVudCBpcyByZW5kZXJlZFxyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgdmlld1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21wb25lbnQ7XHJcbn0oTW9kZWxfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbXBvbmVudDtcclxuXG5cbi8qKiovIH0pLFxuLyogMjM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSXRlcmF0b3IoaXRlbXMpIHtcclxuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXMgfHwgW107XHJcbiAgICB9XHJcbiAgICAvKiBDYWxscyBhIG1ldGhvZCBvbiBldmVyeSBpdGVtIHBhc3NpbmcgdGhlIGFyZ3VtZW50cyB0aHJvdWdoICovXHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUucHJveHlDYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtW21ldGhvZE5hbWVdLmFwcGx5KGl0ZW0sIGFyZ3MpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gSXRlcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEl0ZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBUb29sYmFyIHdpdGggYnV0dG9ucyBhbmQgdGl0bGVcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9vbGJhcihjYWxlbmRhciwgdG9vbGJhck9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmVsID0gbnVsbDsgLy8gbWlycm9ycyBsb2NhbCBgZWxgXHJcbiAgICAgICAgdGhpcy52aWV3c1dpdGhCdXR0b25zID0gW107XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSB0b29sYmFyT3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIG1ldGhvZCB0byB1cGRhdGUgdG9vbGJhci1zcGVjaWZpYyBvcHRpb25zLCBub3QgY2FsZW5kYXItd2lkZSBvcHRpb25zXHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5zZXRUb29sYmFyT3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdUb29sYmFyT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSBuZXdUb29sYmFyT3B0aW9ucztcclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIHdpbGwgcmVyZW5kZXJcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VjdGlvbnMgPSB0aGlzLnRvb2xiYXJPcHRpb25zLmxheW91dDtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgIGlmIChzZWN0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdG9vbGJhciBcIiArIHRoaXMudG9vbGJhck9wdGlvbnMuZXh0cmFDbGFzc2VzICsgXCInLz5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbC5lbXB0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ2xlZnQnKSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5yZW5kZXJTZWN0aW9uKCdyaWdodCcpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIG9wdGlvbnNNYW5hZ2VyID0gY2FsZW5kYXIub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdmFyIHZpZXdTcGVjTWFuYWdlciA9IGNhbGVuZGFyLnZpZXdTcGVjTWFuYWdlcjtcclxuICAgICAgICB2YXIgc2VjdGlvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLScgKyBwb3NpdGlvbiArICdcIi8+Jyk7XHJcbiAgICAgICAgdmFyIGJ1dHRvblN0ciA9IHRoaXMudG9vbGJhck9wdGlvbnMubGF5b3V0W3Bvc2l0aW9uXTtcclxuICAgICAgICB2YXIgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gb3B0aW9uc01hbmFnZXIuZ2V0KCdjdXN0b21CdXR0b25zJykgfHwge307XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IG9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xyXG4gICAgICAgIHZhciBjYWxlbmRhckJ1dHRvblRleHQgPSBvcHRpb25zTWFuYWdlci5nZXQoJ2J1dHRvblRleHQnKSB8fCB7fTtcclxuICAgICAgICBpZiAoYnV0dG9uU3RyKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChidXR0b25TdHIuc3BsaXQoJyAnKSwgZnVuY3Rpb24gKGksIGJ1dHRvbkdyb3VwU3RyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBDaGlsZHJlbiA9ICQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cEVsO1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChqLCBidXR0b25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbUJ1dHRvblByb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3U3BlYztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xpY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQ7IC8vIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbklubmVySHRtbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkFyaWFBdHRyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZCgkKCc8aDI+Jm5ic3A7PC9oMj4nKSk7IC8vIHdlIGFsd2F5cyB3YW50IGl0IHRvIHRha2UgdXAgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGJ1dHRvbkVsWzBdLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyhidXR0b25OYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJbYnV0dG9uTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyW2J1dHRvbk5hbWVdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBeIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdidXR0b24nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygnc3RhdGVEZWZhdWx0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbklubmVySHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKGJ1dHRvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5uZXJIdG1sID0gXCI8c3BhbiBjbGFzcz0nXCIgKyBidXR0b25JY29uICsgXCInPjwvc3Bhbj5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25BcmlhQXR0ciA9ICcgYXJpYS1sYWJlbD1cIicgKyBidXR0b25OYW1lICsgJ1wiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsID0gJCgvLyB0eXBlPVwiYnV0dG9uXCIgc28gdGhhdCBpdCBkb2Vzbid0IHN1Ym1pdCBhIGZvcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIicgKyBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPicgKyBidXR0b25Jbm5lckh0bWwgKyAnPC9idXR0b24+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2soZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgcHJvY2VzcyBjbGlja3MgZm9yIGRpc2FibGVkIGJ1dHRvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGNsaWNrIGFjdGlvbiwgaWYgdGhlIGJ1dHRvbiBiZWNvbWVzIHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBuZXZlciBoYXZlIGEgaG92ZXIgY2xhc3MsIHNvIHJlbW92ZSBpdCBub3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25FbC5oYXNDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVIb3ZlcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1vdXNlZG93bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlICpkb3duKiBlZmZlY3QgKG1vdXNlIHByZXNzZWQgaW4pLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgb24gYnV0dG9ucyB0aGF0IGFyZSBub3QgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURvd24nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tb3VzZXVwKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRvIHRoZSAqZG93biogZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRG93bicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhvdmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgKmhvdmVyKiBlZmZlY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBvbiBidXR0b25zIHRoYXQgYXJlIG5vdCB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlSG92ZXInKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kbyB0aGUgKmhvdmVyKiBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlSG92ZXInKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURvd24nKSk7IC8vIGlmIG1vdXNlbGVhdmUgaGFwcGVucyBiZWZvcmUgbW91c2V1cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoYnV0dG9uRWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbmx5QnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpcnN0KCkuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ2Nvcm5lckxlZnQnKSkuZW5kKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmxhc3QoKS5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnY29ybmVyUmlnaHQnKSkuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBDaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbCA9ICQoJzxkaXYvPicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09ubHlCdXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwRWwuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBncm91cEVsLmFwcGVuZChncm91cENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRWwuYXBwZW5kKGdyb3VwRWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkVsLmFwcGVuZChncm91cENoaWxkcmVuKTsgLy8gMSBvciAwIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VjdGlvbkVsO1xyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnVwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJ2gyJykudGV4dCh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuYWN0aXZhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5kZWFjdGl2YXRlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuZGlzYWJsZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmVuYWJsZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5nZXRWaWV3c1dpdGhCdXR0b25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzV2l0aEJ1dHRvbnM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRvb2xiYXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2xiYXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxudmFyIE1vZGVsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcclxudmFyIE9wdGlvbnNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoT3B0aW9uc01hbmFnZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBPcHRpb25zTWFuYWdlcihfY2FsZW5kYXIsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2NhbGVuZGFyID0gX2NhbGVuZGFyO1xyXG4gICAgICAgIF90aGlzLm92ZXJyaWRlcyA9ICQuZXh0ZW5kKHt9LCBvdmVycmlkZXMpOyAvLyBtYWtlIGEgY29weVxyXG4gICAgICAgIF90aGlzLmR5bmFtaWNPdmVycmlkZXMgPSB7fTtcclxuICAgICAgICBfdGhpcy5jb21wdXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbkNudCA9IDA7XHJcbiAgICAgICAgdmFyIG9wdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRPdmVycmlkZXMobmV3T3B0aW9uSGFzaCk7IC8vIHdpbGwgdHJpZ2dlciB0aGlzIG1vZGVsJ3Mgd2F0Y2hlcnNcclxuICAgICAgICBmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xyXG4gICAgICAgICAgICBvcHRpb25DbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHNpbmdsZSBvcHRpb24gY2hhbmdlLlxyXG4gICAgICAgIC8vIGlmIG9ubHkgb25lIG9wdGlvbiBjaGFuZ2UsIGBvcHRpb25OYW1lYCB3aWxsIGJlIGl0cyBuYW1lLlxyXG4gICAgICAgIGlmIChvcHRpb25DbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgPT09ICdoZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdjb250ZW50SGVpZ2h0JyB8fCBvcHRpb25OYW1lID09PSAnYXNwZWN0UmF0aW8nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci51cGRhdGVWaWV3U2l6ZSh0cnVlKTsgLy8gaXNSZXNpemU9dHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdkZWZhdWx0RGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY2FuJ3QgY2hhbmdlIGRhdGUgdGhpcyB3YXkuIHVzZSBnb3RvRGF0ZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHRoaXMgbW9kZWwgYWxyZWFkeSByZWFjdHMgdG8gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKC9eKGV2ZW50fHNlbGVjdCkoT3ZlcmxhcHxDb25zdHJhaW50fEFsbG93KSQvLnRlc3Qob3B0aW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG9lc24ndCBhZmZlY3QgcmVuZGVyaW5nLiBvbmx5IGludGVyYWN0aW9ucy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25OYW1lID09PSAndGltZXpvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3LmZsYXNoKCdpbml0aWFsRXZlbnRzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2F0Y2gtYWxsLiByZXJlbmRlciB0aGUgaGVhZGVyIGFuZCBmb290ZXIgYW5kIHJlYnVpbGQvcmVyZW5kZXIgdGhlIGN1cnJlbnQgdmlld1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlbmRlckhlYWRlcigpO1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlbmRlckZvb3RlcigpO1xyXG4gICAgICAgIC8vIGV2ZW4gbm9uLWN1cnJlbnQgdmlld3Mgd2lsbCBiZSBhZmZlY3RlZCBieSB0aGlzIG9wdGlvbiBjaGFuZ2UuIGRvIGJlZm9yZSByZXJlbmRlclxyXG4gICAgICAgIC8vIFRPRE86IGRldGFuZ2xlXHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIudmlld3NCeVR5cGUgPSB7fTtcclxuICAgICAgICB0aGlzLl9jYWxlbmRhci5yZWluaXRWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGZsYXR0ZW5lZCBvcHRpb25zIGhhc2ggZm9yIHRoZSBjYWxlbmRhciBhbmQgYXNzaWducyB0byBgdGhpcy5vcHRpb25zYC5cclxuICAgIC8vIEFzc3VtZXMgdGhpcy5vdmVycmlkZXMgYW5kIHRoaXMuZHluYW1pY092ZXJyaWRlcyBoYXZlIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC5cclxuICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsb2NhbGU7XHJcbiAgICAgICAgdmFyIGxvY2FsZURlZmF1bHRzO1xyXG4gICAgICAgIHZhciBpc1JUTDtcclxuICAgICAgICB2YXIgZGlyRGVmYXVsdHM7XHJcbiAgICAgICAgdmFyIHJhd09wdGlvbnM7XHJcbiAgICAgICAgbG9jYWxlID0gdXRpbF8xLmZpcnN0RGVmaW5lZCgvLyBleHBsaWNpdCBsb2NhbGUgb3B0aW9uIGdpdmVuP1xyXG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5sb2NhbGUsIHRoaXMub3ZlcnJpZGVzLmxvY2FsZSk7XHJcbiAgICAgICAgbG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVfMS5sb2NhbGVPcHRpb25IYXNoW2xvY2FsZV07XHJcbiAgICAgICAgaWYgKCFsb2NhbGVEZWZhdWx0cykge1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMubG9jYWxlO1xyXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZV8xLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXSB8fCB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNSVEwgPSB1dGlsXzEuZmlyc3REZWZpbmVkKC8vIGJhc2VkIG9uIG9wdGlvbnMgY29tcHV0ZWQgc28gZmFyLCBpcyBkaXJlY3Rpb24gUlRMP1xyXG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5pc1JUTCwgdGhpcy5vdmVycmlkZXMuaXNSVEwsIGxvY2FsZURlZmF1bHRzLmlzUlRMLCBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMuaXNSVEwpO1xyXG4gICAgICAgIGRpckRlZmF1bHRzID0gaXNSVEwgPyBvcHRpb25zXzEucnRsRGVmYXVsdHMgOiB7fTtcclxuICAgICAgICB0aGlzLmRpckRlZmF1bHRzID0gZGlyRGVmYXVsdHM7XHJcbiAgICAgICAgdGhpcy5sb2NhbGVEZWZhdWx0cyA9IGxvY2FsZURlZmF1bHRzO1xyXG4gICAgICAgIHJhd09wdGlvbnMgPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKFtcclxuICAgICAgICAgICAgb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzLFxyXG4gICAgICAgICAgICBkaXJEZWZhdWx0cyxcclxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIHRoaXMub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXNcclxuICAgICAgICBdKTtcclxuICAgICAgICBsb2NhbGVfMS5wb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMocmF3T3B0aW9ucyk7IC8vIGZpbGwgaW4gZ2FwcyB3aXRoIGNvbXB1dGVkIG9wdGlvbnNcclxuICAgICAgICB0aGlzLnJlc2V0KHJhd09wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIC8vIHN0b3JlcyB0aGUgbmV3IG9wdGlvbnMgaW50ZXJuYWxseSwgYnV0IGRvZXMgbm90IHJlcmVuZGVyIGFueXRoaW5nLlxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLnJlY29yZE92ZXJyaWRlcyA9IGZ1bmN0aW9uIChuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbk5hbWU7XHJcbiAgICAgICAgZm9yIChvcHRpb25OYW1lIGluIG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzW29wdGlvbk5hbWVdID0gbmV3T3B0aW9uSGFzaFtvcHRpb25OYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIudmlld1NwZWNNYW5hZ2VyLmNsZWFyQ2FjaGUoKTsgLy8gdGhlIGR5bmFtaWMgb3ZlcnJpZGUgaW52YWxpZGF0ZXMgdGhlIG9wdGlvbnMgaW4gdGhpcyBjYWNoZSwgc28ganVzdCBjbGVhciBpdFxyXG4gICAgICAgIHRoaXMuY29tcHV0ZSgpOyAvLyB0aGlzLm9wdGlvbnMgbmVlZHMgdG8gYmUgcmVjb21wdXRlZCBhZnRlciB0aGUgZHluYW1pYyBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBPcHRpb25zTWFuYWdlcjtcclxufShNb2RlbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3B0aW9uc01hbmFnZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxudmFyIFZpZXdTcGVjTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpZXdTcGVjTWFuYWdlcihvcHRpb25zTWFuYWdlciwgX2NhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlciA9IG9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyID0gX2NhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG4gICAgfVxyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmlld1NwZWNDYWNoZSA9IHt9O1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIGNyZWF0ZSBhIHZpZXcuIFdpbGwgdXNlIGEgY2FjaGUuXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmdldFZpZXdTcGVjID0gZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy52aWV3U3BlY0NhY2hlO1xyXG4gICAgICAgIHJldHVybiBjYWNoZVt2aWV3VHlwZV0gfHwgKGNhY2hlW3ZpZXdUeXBlXSA9IHRoaXMuYnVpbGRWaWV3U3BlYyh2aWV3VHlwZSkpO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cclxuICAgIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuZ2V0VW5pdFZpZXdTcGVjID0gZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICB2YXIgdmlld1R5cGVzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzcGVjO1xyXG4gICAgICAgIGlmICgkLmluQXJyYXkodW5pdCwgdXRpbF8xLnVuaXRzRGVzYykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIHB1dCB2aWV3cyB0aGF0IGhhdmUgYnV0dG9ucyBmaXJzdC4gdGhlcmUgd2lsbCBiZSBkdXBsaWNhdGVzLCBidXQgb2ggd2VsbFxyXG4gICAgICAgICAgICB2aWV3VHlwZXMgPSB0aGlzLl9jYWxlbmRhci5oZWFkZXIuZ2V0Vmlld3NXaXRoQnV0dG9ucygpOyAvLyBUT0RPOiBpbmNsdWRlIGZvb3RlciBhcyB3ZWxsP1xyXG4gICAgICAgICAgICAkLmVhY2goVmlld1JlZ2lzdHJ5XzEudmlld0hhc2gsIGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmlld1R5cGVzLnB1c2godmlld1R5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3BlYyA9IHRoaXMuZ2V0Vmlld1NwZWModmlld1R5cGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChzcGVjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIG9uIGhvdyB0byBjcmVhdGUgYSBnaXZlbiB2aWV3XHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWMgPSBmdW5jdGlvbiAocmVxdWVzdGVkVmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgdmlld092ZXJyaWRlcyA9IHRoaXMub3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLnZpZXdzIHx8IHt9O1xyXG4gICAgICAgIHZhciBzcGVjQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciBkZWZhdWx0c0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICB2YXIgb3ZlcnJpZGVzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciB2aWV3VHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xyXG4gICAgICAgIHZhciBzcGVjOyAvLyBmb3IgdGhlIHZpZXdcclxuICAgICAgICB2YXIgb3ZlcnJpZGVzOyAvLyBmb3IgdGhlIHZpZXdcclxuICAgICAgICB2YXIgZHVyYXRpb25JbnB1dDtcclxuICAgICAgICB2YXIgZHVyYXRpb247XHJcbiAgICAgICAgdmFyIHVuaXQ7XHJcbiAgICAgICAgLy8gaXRlcmF0ZSBmcm9tIHRoZSBzcGVjaWZpYyB2aWV3IGRlZmluaXRpb24gdG8gYSBtb3JlIGdlbmVyYWwgb25lIHVudGlsIHdlIGhpdCBhbiBhY3R1YWwgVmlldyBjbGFzc1xyXG4gICAgICAgIHdoaWxlICh2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICBzcGVjID0gVmlld1JlZ2lzdHJ5XzEudmlld0hhc2hbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICBvdmVycmlkZXMgPSB2aWV3T3ZlcnJpZGVzW3ZpZXdUeXBlXTtcclxuICAgICAgICAgICAgdmlld1R5cGUgPSBudWxsOyAvLyBjbGVhci4gbWlnaHQgcmVwb3B1bGF0ZSBmb3IgYW5vdGhlciBpdGVyYXRpb25cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0geyAnY2xhc3MnOiBzcGVjIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNDaGFpbi51bnNoaWZ0KHNwZWMpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdHNDaGFpbi51bnNoaWZ0KHNwZWMuZGVmYXVsdHMgfHwge30pO1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25JbnB1dCA9IGR1cmF0aW9uSW5wdXQgfHwgc3BlYy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgc3BlYy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlc0NoYWluLnVuc2hpZnQob3ZlcnJpZGVzKTsgLy8gdmlldy1zcGVjaWZpYyBvcHRpb24gaGFzaGVzIGhhdmUgb3B0aW9ucyBhdCB6ZXJvLWxldmVsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fCBvdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8IG92ZXJyaWRlcy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNwZWMgPSB1dGlsXzEubWVyZ2VQcm9wcyhzcGVjQ2hhaW4pO1xyXG4gICAgICAgIHNwZWMudHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xyXG4gICAgICAgIGlmICghc3BlY1snY2xhc3MnXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB0b3AtbGV2ZWwgYGR1cmF0aW9uYCBvcHRpb25cclxuICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMuZHVyYXRpb24gfHxcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5vdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbi52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSB1dGlsXzEuY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0KGR1cmF0aW9uLCBkdXJhdGlvbklucHV0KTtcclxuICAgICAgICAgICAgICAgIHNwZWMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHNwZWMuZHVyYXRpb25Vbml0ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIC8vIHZpZXcgaXMgYSBzaW5nbGUtdW5pdCBkdXJhdGlvbiwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXHJcbiAgICAgICAgICAgICAgICAvLyBpbmNvcnBvcmF0ZSBvcHRpb25zIGZvciB0aGlzLiBsb3dlc3QgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbi5hcyh1bml0KSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWMuc2luZ2xlVW5pdCA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzQ2hhaW4udW5zaGlmdCh2aWV3T3ZlcnJpZGVzW3VuaXRdIHx8IHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzcGVjLmRlZmF1bHRzID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhkZWZhdWx0c0NoYWluKTtcclxuICAgICAgICBzcGVjLm92ZXJyaWRlcyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMob3ZlcnJpZGVzQ2hhaW4pO1xyXG4gICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY09wdGlvbnMoc3BlYyk7XHJcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIHNwZWM7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGFuZCBhc3NpZ25zIGEgdmlldyBzcGVjJ3Mgb3B0aW9ucyBvYmplY3QgZnJvbSBpdHMgYWxyZWFkeS1hc3NpZ25lZCBkZWZhdWx0cyBhbmQgb3ZlcnJpZGVzXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWNPcHRpb25zID0gZnVuY3Rpb24gKHNwZWMpIHtcclxuICAgICAgICB2YXIgb3B0aW9uc01hbmFnZXIgPSB0aGlzLm9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHNwZWMub3B0aW9ucyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW1xyXG4gICAgICAgICAgICBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIHNwZWMuZGVmYXVsdHMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICBzcGVjLm92ZXJyaWRlcyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcyAvLyBkeW5hbWljYWxseSBzZXQgdmlhIHNldHRlci4gaGlnaGVzdCBwcmVjZWRlbmNlXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgbG9jYWxlXzEucG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zKHNwZWMub3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBidXR0b25UZXh0LXJlbGF0ZWQgb3B0aW9uc1xyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dCA9IGZ1bmN0aW9uIChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IHRoaXMub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgLy8gZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBhIHBvc3NpYmxlIGBidXR0b25UZXh0YCBoYXNoLCBsb29rdXAgdGhlIGJ1dHRvblRleHQgZm9yIHRoZVxyXG4gICAgICAgIC8vIHJlcXVlc3RlZCB2aWV3LCBmYWxsaW5nIGJhY2sgdG8gYSBnZW5lcmljIHVuaXQgZW50cnkgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXHJcbiAgICAgICAgZnVuY3Rpb24gcXVlcnlCdXR0b25UZXh0KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQgPSBvcHRpb25zLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0W3JlcXVlc3RlZFZpZXdUeXBlXSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gdmlldyBjYW4gZGVjaWRlIHRvIGxvb2sgdXAgYSBjZXJ0YWluIGtleVxyXG4gICAgICAgICAgICAgICAgKHNwZWMuYnV0dG9uVGV4dEtleSA/IGJ1dHRvblRleHRbc3BlYy5idXR0b25UZXh0S2V5XSA6IG51bGwpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBhIGtleSBsaWtlIFwibW9udGhcIlxyXG4gICAgICAgICAgICAgICAgKHNwZWMuc2luZ2xlVW5pdCA/IGJ1dHRvblRleHRbc3BlYy5zaW5nbGVVbml0XSA6IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eVxyXG4gICAgICAgIHNwZWMuYnV0dG9uVGV4dE92ZXJyaWRlID1cclxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMpIHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXHJcbiAgICAgICAgICAgICAgICBzcGVjLm92ZXJyaWRlcy5idXR0b25UZXh0OyAvLyBgYnV0dG9uVGV4dGAgZm9yIHZpZXctc3BlY2lmaWMgb3B0aW9ucyBpcyBhIHN0cmluZ1xyXG4gICAgICAgIC8vIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5LiBtaXJyb3JzIGJ1aWxkVmlld1NwZWNPcHRpb25zXHJcbiAgICAgICAgc3BlYy5idXR0b25UZXh0RGVmYXVsdCA9XHJcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5kaXJEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHNwZWMuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fCAvLyBhIHNpbmdsZSBzdHJpbmcuIGZyb20gVmlld1N1YmNsYXNzLmRlZmF1bHRzXHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc18xLmdsb2JhbERlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgKHNwZWMuZHVyYXRpb24gPyB0aGlzLl9jYWxlbmRhci5odW1hbml6ZUR1cmF0aW9uKHNwZWMuZHVyYXRpb24pIDogbnVsbCkgfHwgLy8gbGlrZSBcIjMgZGF5c1wiXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWaWV3VHlwZTsgLy8gZmFsbCBiYWNrIHRvIGdpdmVuIHZpZXcgbmFtZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3U3BlY01hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFZpZXdTcGVjTWFuYWdlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UGVyaW9kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Myk7XHJcbnZhciBBcnJheUV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgRXZlbnRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuc3RpY2t5U291cmNlID0gbmV3IEFycmF5RXZlbnRTb3VyY2VfMS5kZWZhdWx0KGNhbGVuZGFyKTtcclxuICAgICAgICB0aGlzLm90aGVyU291cmNlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lLCBmb3JjZSkge1xyXG4gICAgICAgIGlmIChmb3JjZSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5jdXJyZW50UGVyaW9kIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmN1cnJlbnRQZXJpb2QuaXNXaXRoaW5SYW5nZShzdGFydCwgZW5kKSB8fFxyXG4gICAgICAgICAgICB0aW1lem9uZSAhPT0gdGhpcy5jdXJyZW50UGVyaW9kLnRpbWV6b25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGVyaW9kKC8vIHdpbGwgY2hhbmdlIHRoaXMuY3VycmVudFBlcmlvZFxyXG4gICAgICAgICAgICBuZXcgRXZlbnRQZXJpb2RfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIHRpbWV6b25lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2Qud2hlblJlbGVhc2VkKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIEFkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkU291cmNlID0gZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5vdGhlclNvdXJjZXMucHVzaChldmVudFNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVxdWVzdFNvdXJjZShldmVudFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVTb3VyY2UgPSBmdW5jdGlvbiAoZG9vbWVkU291cmNlKSB7XHJcbiAgICAgICAgdXRpbF8xLnJlbW92ZUV4YWN0KHRoaXMub3RoZXJTb3VyY2VzLCBkb29tZWRTb3VyY2UpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGRvb21lZFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVBbGxTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub3RoZXJTb3VyY2VzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucHVyZ2VBbGxTb3VyY2VzKCk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIFJlZmV0Y2hpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlZmV0Y2hTb3VyY2UgPSBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVmZXRjaEFsbFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRQZXJpb2QgPSB0aGlzLmN1cnJlbnRQZXJpb2Q7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5mcmVlemUoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5wdXJnZUFsbFNvdXJjZXMoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgUXVlcnlpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0aWNreVNvdXJjZV0uY29uY2F0KHRoaXMub3RoZXJTb3VyY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBsaWtlIHF1ZXJ5U291cmNlcywgYnV0IGFjY2VwdHMgbXVsdHBsZSBtYXRjaCBjcml0ZXJpYSAobGlrZSBtdWx0aXBsZSBJRHMpXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLm11bHRpUXVlcnlTb3VyY2VzID0gZnVuY3Rpb24gKG1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgLy8gY29lcmNlIGludG8gYW4gYXJyYXlcclxuICAgICAgICBpZiAoIW1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCEkLmlzQXJyYXkobWF0Y2hJbnB1dHMpKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW21hdGNoSW5wdXRzXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nU291cmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlc29sdmUgcmF3IGlucHV0cyB0byByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3RzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hdGNoSW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1hdGNoaW5nU291cmNlcy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBtYXRjaGluZ1NvdXJjZXMsIHRoaXMucXVlcnlTb3VyY2VzKG1hdGNoSW5wdXRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGluZ1NvdXJjZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gbWF0Y2hJbnB1dCBjYW4gZWl0aGVyIGJ5IGEgcmVhbCBldmVudCBzb3VyY2Ugb2JqZWN0LCBhbiBJRCwgb3IgdGhlIGZ1bmN0aW9uL1VSTCBmb3IgdGhlIHNvdXJjZS5cclxuICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgc291cmNlIG9iamVjdHMuXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnF1ZXJ5U291cmNlcyA9IGZ1bmN0aW9uIChtYXRjaElucHV0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLm90aGVyU291cmNlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc291cmNlO1xyXG4gICAgICAgIC8vIGdpdmVuIGEgcHJvcGVyIGV2ZW50IHNvdXJjZSBvYmplY3RcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBtYXRjaElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NvdXJjZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gSUQgbWF0Y2hcclxuICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZUJ5SWQoRXZlbnRTb3VyY2VfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKG1hdGNoSW5wdXQpKTtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbc291cmNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGFyc2UgYXMgYW4gZXZlbnQgc291cmNlXHJcbiAgICAgICAgbWF0Y2hJbnB1dCA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShtYXRjaElucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICBpZiAobWF0Y2hJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1NvdXJjZXNFcXVpdmFsZW50KG1hdGNoSW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgSUQgYXNzdW1lZCB0byBhbHJlYWR5IGJlIG5vcm1hbGl6ZWRcclxuICAgICovXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gJC5ncmVwKHRoaXMub3RoZXJTb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UuaWQgJiYgc291cmNlLmlkID09PSBpZDtcclxuICAgICAgICB9KVswXTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudC1QZXJpb2RcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnNldFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmRQZXJpb2QodGhpcy5jdXJyZW50UGVyaW9kKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gZXZlbnRQZXJpb2Q7XHJcbiAgICAgICAgdGhpcy5iaW5kUGVyaW9kKGV2ZW50UGVyaW9kKTtcclxuICAgICAgICBldmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kUGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhldmVudFBlcmlvZCwgJ3JlbGVhc2UnLCBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKGV2ZW50UGVyaW9kKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBHZXR0aW5nL0FkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZCeVVpZCA9IGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnREZWZCeVVpZCh1aWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmLCBpc1N0aWNreSkge1xyXG4gICAgICAgIGlmIChpc1N0aWNreSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0aWNreVNvdXJjZS5hZGRFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmFkZEV2ZW50RGVmKGV2ZW50RGVmKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnRJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U291cmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlLnJlbW92ZUV2ZW50RGVmc0J5SWQoZXZlbnRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWZzQnlJZChldmVudElkKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50RGVmcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdldFNvdXJjZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICBldmVudFNvdXJjZS5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgTXV0YXRpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUubXV0YXRlRXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQsIGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzO1xyXG4gICAgICAgIHZhciB1bmRvRnVuY3MgPSBbXTtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBldmVudERlZnMgPSBjdXJyZW50UGVyaW9kLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkL3JlbW92ZSBlc3AgYmVjYXVzZSBpZCBtaWdodCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmNzLnB1c2goZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZXZlbnREZWYpKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuYWRkRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kb0Z1bmNzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5hZGRFdmVudERlZihldmVudERlZnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGNvcGllcyBhbmQgdGhlbiBtdXRhdGVzXHJcbiAgICAqL1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5idWlsZE11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCwgZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSB0aGlzLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZkNvcHk7XHJcbiAgICAgICAgdmFyIGFsbEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVmQ29weSA9IGV2ZW50RGVmc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAoZGVmQ29weSBpbnN0YW5jZW9mIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZGVmQ29weSk7XHJcbiAgICAgICAgICAgICAgICBhbGxJbnN0YW5jZXMucHVzaC5hcHBseShhbGxJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZGVmQ29weS5idWlsZEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoYWxsSW5zdGFuY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBGcmVlemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBtZXRob2RzIHRoYXQgc2ltcGx5IGZvcndhcmQgdG8gRXZlbnRQZXJpb2RcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlcygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQoZXZlbnREZWZJZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZChldmVudERlZklkKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudE1hbmFnZXI7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudE1hbmFnZXIpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50TWFuYWdlcik7XHJcbmZ1bmN0aW9uIGlzU291cmNlc0VxdWl2YWxlbnQoc291cmNlMCwgc291cmNlMSkge1xyXG4gICAgcmV0dXJuIHNvdXJjZTAuZ2V0UHJpbWl0aXZlKCkgPT09IHNvdXJjZTEuZ2V0UHJpbWl0aXZlKCk7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBFdmVudFBlcmlvZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UGVyaW9kKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ250ID0gMDtcclxuICAgICAgICB0aGlzLmZyZWV6ZURlcHRoID0gMDtcclxuICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLCBlbmQuY2xvbmUoKS5zdHJpcFpvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlJZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB7fTtcclxuICAgIH1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5pc1dpdGhpblJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyBUT0RPOiB1c2UgYSByYW5nZSB1dGlsIGZ1bmN0aW9uP1xyXG4gICAgICAgIHJldHVybiAhc3RhcnQuaXNCZWZvcmUodGhpcy5zdGFydCkgJiYgIWVuZC5pc0FmdGVyKHRoaXMuZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXF1ZXN0aW5nIGFuZCBQdXJnaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlcXVlc3RTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZXMpIHtcclxuICAgICAgICB0aGlzLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGhhdygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZXF1ZXN0U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7IHNvdXJjZTogc291cmNlLCBzdGF0dXM6ICdwZW5kaW5nJywgZXZlbnREZWZzOiBudWxsIH07XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgKz0gMTtcclxuICAgICAgICBzb3VyY2UuZmV0Y2godGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMudGltZXpvbmUpLnRoZW4oZnVuY3Rpb24gKGV2ZW50RGVmcykge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ldmVudERlZnMgPSBldmVudERlZnM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRFdmVudERlZnMoZXZlbnREZWZzKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnZmFpbGVkJztcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5wdXJnZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNCeVVpZFtzb3VyY2UudWlkXTtcclxuICAgICAgICBpZiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnY2FuY2VsbGVkJztcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmV2ZW50RGVmcy5mb3JFYWNoKHRoaXMucmVtb3ZlRXZlbnREZWYuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnB1cmdlQWxsU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdHNCeVVpZCA9IHRoaXMucmVxdWVzdHNCeVVpZDtcclxuICAgICAgICB2YXIgdWlkO1xyXG4gICAgICAgIHZhciByZXF1ZXN0O1xyXG4gICAgICAgIHZhciBjb21wbGV0ZWRDbnQgPSAwO1xyXG4gICAgICAgIGZvciAodWlkIGluIHJlcXVlc3RzQnlVaWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3RzQnlVaWRbdWlkXTtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAncGVuZGluZycpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ2NhbmNlbGxlZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgPSAwO1xyXG4gICAgICAgIGlmIChjb21wbGV0ZWRDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxFdmVudERlZnMoKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEZWZpbml0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZkJ5VWlkID0gZnVuY3Rpb24gKGV2ZW50RGVmVWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWZVaWRdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMuZXZlbnREZWZzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50RGVmcyA9IGZ1bmN0aW9uIChldmVudERlZnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5hZGRFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudERlZnNCeUlkID0gdGhpcy5ldmVudERlZnNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudERlZklkID0gZXZlbnREZWYuaWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gfHwgKGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gPSBbXSk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXModGhpcy51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50RGVmcy5wdXNoKGV2ZW50RGVmKTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5VWlkW2V2ZW50RGVmLnVpZF0gPSBldmVudERlZjtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2VzW2ldLCBldmVudERlZklkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpc0VtcHR5ID0gJC5pc0VtcHR5T2JqZWN0KHRoaXMuZXZlbnREZWZzQnlVaWQpO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5SWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0ge307XHJcbiAgICAgICAgaWYgKCFpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzQnlJZCA9IHRoaXMuZXZlbnREZWZzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWYudWlkXTtcclxuICAgICAgICBpZiAoZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIHV0aWxfMS5yZW1vdmVFeGFjdChldmVudERlZnMsIGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgaWYgKCFldmVudERlZnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IEluc3RhbmNlc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzLnB1c2guYXBwbHkoZXZlbnRJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXBzQnlJZFtpZF0uZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMuc2xpY2UoKTsgLy8gY2xvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgbWF0Y2hpbmdJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgZm9yIChpZCBpbiBldmVudEluc3RhbmNlR3JvdXBzQnlJZCkge1xyXG4gICAgICAgICAgICBpZiAoaWQgIT09IGV2ZW50RGVmSWQpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoaW5nSW5zdGFuY2VzLnB1c2guYXBwbHkobWF0Y2hpbmdJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbaWRdLmV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdIHx8XHJcbiAgICAgICAgICAgIChldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXSA9IG5ldyBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcy5wdXNoKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICB2YXIgcmVtb3ZlQ250O1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmVtb3ZlQ250ID0gdXRpbF8xLnJlbW92ZU1hdGNoaW5nKGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcywgZnVuY3Rpb24gKGN1cnJlbnRFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEV2ZW50SW5zdGFuY2UuZGVmID09PSBldmVudERlZjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVtb3ZlQ250KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZWxlYXNpbmcgYW5kIEZyZWV6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRyeVJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmZyZWV6ZURlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQrKztcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUud2hlblJlbGVhc2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZUNudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQucmVzb2x2ZSh0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub25lKCdyZWxlYXNlJywgb25SZXNvbHZlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5mcmVlemVEZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmZyZWV6ZURlcHRoKSAmJiB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ICYmICF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFBlcmlvZDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRQZXJpb2Q7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudFBlcmlvZCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG4vKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZWxlbWVudCBhbmQgbGV0cyBpdCB0cmFjayB0aGUgbW91c2UgYXMgaXQgbW92ZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBNb3VzZUZvbGxvd2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTW91c2VGb2xsb3dlcihzb3VyY2VFbCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNGb2xsb3dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyBkb2luZyB0aGUgcmV2ZXJ0IGFuaW1hdGlvbj9cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gc291cmNlRWw7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRFbCA9IG9wdGlvbnMucGFyZW50RWwgPyAkKG9wdGlvbnMucGFyZW50RWwpIDogc291cmNlRWwucGFyZW50KCk7IC8vIGRlZmF1bHQgdG8gc291cmNlRWwncyBwYXJlbnRcclxuICAgIH1cclxuICAgIC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdGFydCBmb2xsb3dpbmcgdGhlIG1vdXNlXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0ZvbGxvd2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRm9sbG93aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy55MCA9IHV0aWxfMS5nZXRFdlkoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLngwID0gdXRpbF8xLmdldEV2WChldik7XHJcbiAgICAgICAgICAgIHRoaXMudG9wRGVsdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnREZWx0YSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYXVzZXMgdGhlIGVsZW1lbnQgdG8gc3RvcCBmb2xsb3dpbmcgdGhlIG1vdXNlLiBJZiBzaG91bGRSZXZlcnQgaXMgdHJ1ZSwgd2lsbCBhbmltYXRlIGJhY2sgdG8gb3JpZ2luYWwgcG9zaXRpb24uXHJcbiAgICAvLyBgY2FsbGJhY2tgIGdldHMgaW52b2tlZCB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuIElmIG5vIGFuaW1hdGlvbiwgaXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseS5cclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoc2hvdWxkUmV2ZXJ0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJldmVydER1cmF0aW9uID0gdGhpcy5vcHRpb25zLnJldmVydER1cmF0aW9uO1xyXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBfdGhpcy50b3AwID0gX3RoaXMubGVmdDAgPSBudWxsOyAvLyByZXNldCBzdGF0ZSBmb3IgZnV0dXJlIHVwZGF0ZVBvc2l0aW9uIGNhbGxzXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGb2xsb3dpbmcgJiYgIXRoaXMuaXNBbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0ZvbGxvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXZlcnQgJiYgcmV2ZXJ0RHVyYXRpb24gJiYgIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wMCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQwXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHJldmVydER1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRyYWNraW5nIGVsZW1lbnQuIENyZWF0ZSBpdCBpZiBuZWNlc3NhcnlcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmdldEVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgaWYgKCFlbCkge1xyXG4gICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lKClcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbENsYXNzIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogdGhpcy5pc0hpZGRlbiA/ICdub25lJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc291cmNlRWwud2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zb3VyY2VFbC5oZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3B0aW9ucy5vcGFjaXR5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiB0aGlzLm9wdGlvbnMuekluZGV4XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxyXG4gICAgICAgICAgICBlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJyk7XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZFRvKHRoaXMucGFyZW50RWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVtb3ZlcyB0aGUgdHJhY2tpbmcgZWxlbWVudCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZSB0aGUgQ1NTIHBvc2l0aW9uIG9mIHRoZSB0cmFja2luZyBlbGVtZW50XHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlT2Zmc2V0O1xyXG4gICAgICAgIHZhciBvcmlnaW47XHJcbiAgICAgICAgdGhpcy5nZXRFbCgpOyAvLyBlbnN1cmUgdGhpcy5lbFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvcmlnaW4gaW5mbyB3YXMgY29tcHV0ZWRcclxuICAgICAgICBpZiAodGhpcy50b3AwID09IG51bGwpIHtcclxuICAgICAgICAgICAgc291cmNlT2Zmc2V0ID0gdGhpcy5zb3VyY2VFbC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy50b3AwID0gc291cmNlT2Zmc2V0LnRvcCAtIG9yaWdpbi50b3A7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdDAgPSBzb3VyY2VPZmZzZXQubGVmdCAtIG9yaWdpbi5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmNzcyh7XHJcbiAgICAgICAgICAgIHRvcDogdGhpcy50b3AwICsgdGhpcy50b3BEZWx0YSxcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5sZWZ0MCArIHRoaXMubGVmdERlbHRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2VcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRvcERlbHRhID0gdXRpbF8xLmdldEV2WShldikgLSB0aGlzLnkwO1xyXG4gICAgICAgIHRoaXMubGVmdERlbHRhID0gdXRpbF8xLmdldEV2WChldikgLSB0aGlzLngwO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRlbXBvcmFyaWx5IG1ha2VzIHRoZSB0cmFja2luZyBlbGVtZW50IGludmlzaWJsZS4gQ2FuIGJlIGNhbGxlZCBiZWZvcmUgZm9sbG93aW5nIHN0YXJ0c1xyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG93IHRoZSB0cmFja2luZyBlbGVtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHRlbXBvcmFyaWx5IGhpZGRlblxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRFbCgpLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vdXNlRm9sbG93ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vdXNlRm9sbG93ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW91c2VGb2xsb3dlcik7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBEYXRlQ2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXRlQ2xpY2tpbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IG11c3QgaW1wbGVtZW50OlxyXG4gICAgICAtIGJpbmREYXRlSGFuZGxlclRvRWxcclxuICAgICAgLSBnZXRTYWZlSGl0Rm9vdHByaW50XHJcbiAgICAgIC0gZ2V0SGl0RWxcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBEYXRlQ2xpY2tpbmcoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IF90aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF0ZUNsaWNraW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuc2hvdWxkSWdub3JlVG91Y2goKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyJ3MgZHJhZyBhY3Jvc3MgZGF5IGVsZW1lbnRzLCBmb3IgZGF5IGNsaWNraW5nLlxyXG4gICAgRGF0ZUNsaWNraW5nLnByb3RvdHlwZS5idWlsZERyYWdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgZGF5Q2xpY2tIaXQ7IC8vIG51bGwgaWYgaW52YWxpZCBkYXlDbGlja1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlDbGlja0hpdCA9IGRyYWdMaXN0ZW5lci5vcmlnSGl0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgZHJhZ2dlZCB0byBhbm90aGVyIGNlbGwgYXQgYW55IHBvaW50LCBpdCBjYW4gbm8gbG9uZ2VyIGJlIGEgZGF5Q2xpY2tcclxuICAgICAgICAgICAgICAgIGlmICghaXNPcmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF5Q2xpY2tIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRheUNsaWNrSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsbGVkICYmIGRheUNsaWNrSGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoZGF5Q2xpY2tIaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy50cmlnZ2VyRGF5Q2xpY2soY29tcG9uZW50Rm9vdHByaW50LCBjb21wb25lbnQuZ2V0SGl0RWwoZGF5Q2xpY2tIaXQpLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYmVjYXVzZSBkcmFnTGlzdGVuZXIgd29uJ3QgYmUgY2FsbGVkIHdpdGggYW55IHRpbWUgZGVsYXksIFwiZHJhZ2dpbmdcIiB3aWxsIGJlZ2luIGltbWVkaWF0ZWx5LFxyXG4gICAgICAgIC8vIHdoaWNoIHdpbGwga2lsbCBhbnkgdG91Y2htb3Zpbmcvc2Nyb2xsaW5nLiBQcmV2ZW50IHRoaXMuXHJcbiAgICAgICAgZHJhZ0xpc3RlbmVyLnNob3VsZENhbmNlbFRvdWNoU2Nyb2xsID0gZmFsc2U7XHJcbiAgICAgICAgZHJhZ0xpc3RlbmVyLnNjcm9sbEFsd2F5c0tpbGxzID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRlQ2xpY2tpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVDbGlja2luZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG4vKlxyXG5Pbmx5IGhhbmRsZXMgZm9yZWdyb3VuZCBzZWdzLlxyXG5Eb2VzIG5vdCBvd24gcmVuZGVyaW5nLiBVc2UgZm9yIGxvdy1sZXZlbCB1dGlsIG1ldGhvZHMgYnkgVGltZUdyaWQuXHJcbiovXHJcbnZhciBUaW1lR3JpZEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEV2ZW50UmVuZGVyZXIodGltZUdyaWQsIGZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRpbWVHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGltZUdyaWQgPSB0aW1lR3JpZDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLnRpbWVHcmlkLmZnQ29udGFpbmVyRWxzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBmb3JlZ3JvdW5kIHNlZ21lbnRzLCByZW5kZXIgYSBET00gZWxlbWVudCBmb3IgZWFjaCwgY29tcHV0ZXMgcG9zaXRpb24sXHJcbiAgICAvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzID0gZnVuY3Rpb24gKHNlZ3MsIGNvbnRhaW5lckVscykge1xyXG4gICAgICAgIHZhciBzZWdzQnlDb2w7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICBzZWdzQnlDb2wgPSB0aGlzLnRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy50aW1lR3JpZC5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmdTZWdDb29yZHMoc2Vnc0J5Q29sW2NvbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmF0dGFjaFNlZ3NCeUNvbChzZWdzQnlDb2wsIGNvbnRhaW5lckVscyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5mZ1NlZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5mZ1NlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgdGltZUZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnbm9NZXJpZGllbVRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjY6MzBcIiAobm8gQU0vUE0pXHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCBzZWdtZW50J3MgZGVmYXVsdCByZW5kZXJpbmdcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZmdTZWdIdG1sID0gZnVuY3Rpb24gKHNlZywgZGlzYWJsZVJlc2l6aW5nKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgY29tcG9uZW50Rm9vdHByaW50ID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGlzQWxsRGF5ID0gY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RGVmRHJhZ2dhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tU3RhcnQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIHNlZy5pc1N0YXJ0ICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21TdGFydChldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbUVuZCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzRW5kICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21FbmQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5nZXRTZWdDbGFzc2VzKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlRnJvbVN0YXJ0IHx8IGlzUmVzaXphYmxlRnJvbUVuZCk7XHJcbiAgICAgICAgdmFyIHNraW5Dc3MgPSB1dGlsXzEuY3NzVG9TdHIodGhpcy5nZXRTa2luQ3NzKGV2ZW50RGVmKSk7XHJcbiAgICAgICAgdmFyIHRpbWVUZXh0O1xyXG4gICAgICAgIHZhciBmdWxsVGltZVRleHQ7IC8vIG1vcmUgdmVyYm9zZSB0aW1lIHRleHQuIGZvciB0aGUgcHJpbnQgc3R5bGVzaGVldFxyXG4gICAgICAgIHZhciBzdGFydFRpbWVUZXh0OyAvLyBqdXN0IHRoZSBzdGFydCB0aW1lIHRleHRcclxuICAgICAgICBjbGFzc2VzLnVuc2hpZnQoJ2ZjLXRpbWUtZ3JpZC1ldmVudCcsICdmYy12LWV2ZW50Jyk7XHJcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGFwcGVhcnMgdG8gc3BhbiBtb3JlIHRoYW4gb25lIGRheS4uLlxyXG4gICAgICAgIGlmICh2aWV3LmlzTXVsdGlEYXlSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBkaXNwbGF5IHRpbWUgdGV4dCBvbiBzZWdtZW50cyB0aGF0IHJ1biBlbnRpcmVseSB0aHJvdWdoIGEgZGF5LlxyXG4gICAgICAgICAgICAvLyBUaGF0IHdvdWxkIGFwcGVhciBhcyBtaWRuaWdodC1taWRuaWdodCBhbmQgd291bGQgbG9vayBkdW1iLlxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRpc3BsYXkgdGhlIHRpbWUgdGV4dCBmb3IgdGhlICpzZWdtZW50J3MqIHRpbWVzIChsaWtlIDZwbS1taWRuaWdodCBvciBtaWRuaWdodC0xMGFtKVxyXG4gICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9uZWRTdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLnN0YXJ0TXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvbmVkRW5kID0gY2FsZW5kYXIubXNUb01vbWVudChzZWcuZW5kTXMpO1xyXG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXkpO1xyXG4gICAgICAgICAgICAgICAgZnVsbFRpbWVUZXh0ID0gdGhpcy5fZ2V0VGltZVRleHQoem9uZWRTdGFydCwgem9uZWRFbmQsIGlzQWxsRGF5LCAnTFQnKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXksIG51bGwsIGZhbHNlKTsgLy8gZGlzcGxheUVuZD1mYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgZnVsbFRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50LCAnTFQnKTtcclxuICAgICAgICAgICAgc3RhcnRUaW1lVGV4dCA9IHRoaXMuZ2V0VGltZVRleHQoc2VnLmZvb3RwcmludCwgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKHNraW5Dc3MgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAgICAgKHRpbWVUZXh0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtdGltZVwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBkYXRhLXN0YXJ0PVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKHN0YXJ0VGltZVRleHQpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBkYXRhLWZ1bGw9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZnVsbFRpbWVUZXh0KSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyB1dGlsXzEuaHRtbEVzY2FwZSh0aW1lVGV4dCkgKyAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChldmVudERlZi50aXRsZSA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdcIi8+JyArXHJcbiAgICAgICAgICAgIC8qIFRPRE86IHdyaXRlIENTUyBmb3IgdGhpc1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tU3RhcnQgP1xyXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAnJ1xyXG4gICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tRW5kID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiIC8+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC9hPic7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhcmUgYXNzdW1lZCB0byBhbGwgbGl2ZSBpbiB0aGUgKnNhbWUgY29sdW1uKixcclxuICAgIC8vIGNvbXB1dGUgdGhlaXIgdmVyaWNhbC9ob3Jpem9udGFsIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdG8gdGhlaXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUZnU2VnQ29vcmRzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7IC8vIGhvcml6b250YWxzIHJlbGllcyBvbiB0aGlzXHJcbiAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdIb3Jpem9udGFscyhzZWdzKTsgLy8gY29tcHV0ZSBob3Jpem9udGFsIGNvb3JkaW5hdGVzLCB6LWluZGV4J3MsIGFuZCByZW9yZGVyIHRoZSBhcnJheVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgICAgIHRoaXMuYXNzaWduRmdTZWdIb3Jpem9udGFscyhzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBzZWdtZW50cyB0aGF0IGFyZSBhbGwgaW4gdGhlIHNhbWUgY29sdW1uLCBzZXRzIHRoZSBiYWNrd2FyZENvb3JkIGFuZCBmb3J3YXJkQ29vcmQgb24gZWFjaC5cclxuICAgIC8vIE5PVEU6IEFsc28gcmVvcmRlcnMgdGhlIGdpdmVuIGFycmF5IGJ5IGRhdGUhXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVGZ1NlZ0hvcml6b250YWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzO1xyXG4gICAgICAgIHZhciBsZXZlbDA7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpOyAvLyBvcmRlciBieSBjZXJ0YWluIGNyaXRlcmlhXHJcbiAgICAgICAgbGV2ZWxzID0gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpO1xyXG4gICAgICAgIGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKTtcclxuICAgICAgICBpZiAoKGxldmVsMCA9IGxldmVsc1swXSkpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMobGV2ZWwwW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWwwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGxldmVsMFtpXSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsY3VsYXRlIHNlZy5mb3J3YXJkQ29vcmQgYW5kIHNlZy5iYWNrd2FyZENvb3JkIGZvciB0aGUgc2VnbWVudCwgd2hlcmUgYm90aCB2YWx1ZXMgcmFuZ2VcclxuICAgIC8vIGZyb20gMCB0byAxLiBJZiB0aGUgY2FsZW5kYXIgaXMgbGVmdC10by1yaWdodCwgdGhlIHNlZy5iYWNrd2FyZENvb3JkIG1hcHMgdG8gXCJsZWZ0XCIgYW5kXHJcbiAgICAvLyBzZWcuZm9yd2FyZENvb3JkIG1hcHMgdG8gXCJyaWdodFwiICh2aWEgcGVyY2VudGFnZSkuIFZpY2UtdmVyc2EgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIHNlZ21lbnQgbWlnaHQgYmUgcGFydCBvZiBhIFwic2VyaWVzXCIsIHdoaWNoIG1lYW5zIGNvbnNlY3V0aXZlIHNlZ21lbnRzIHdpdGggdGhlIHNhbWUgcHJlc3N1cmVcclxuICAgIC8vIHdobydzIHdpZHRoIGlzIHVua25vd24gdW50aWwgYW4gZWRnZSBoYXMgYmVlbiBoaXQuIGBzZXJpZXNCYWNrd2FyZFByZXNzdXJlYCBpcyB0aGUgbnVtYmVyIG9mXHJcbiAgICAvLyBzZWdtZW50cyBiZWhpbmQgdGhpcyBvbmUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzLCBhbmQgYHNlcmllc0JhY2t3YXJkQ29vcmRgIGlzIHRoZSBzdGFydGluZ1xyXG4gICAgLy8gY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3Qgc2VnbWVudCBpbiB0aGUgc2VyaWVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayA9IGZ1bmN0aW9uIChzZWcsIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUsIHNlcmllc0JhY2t3YXJkQ29vcmQpIHtcclxuICAgICAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZy5mb3J3YXJkQ29vcmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIWZvcndhcmRTZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGZvcndhcmQgc2VnbWVudHMsIHRoaXMgc2VnbWVudCBzaG91bGQgYnV0dCB1cCBhZ2FpbnN0IHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNvcnQgaGlnaGVzdCBwcmVzc3VyZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Rm9yd2FyZFNlZ3MoZm9yd2FyZFNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzZWdtZW50J3MgZm9yd2FyZENvb3JkIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBiYWNrd2FyZENvb3JkIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gaGlnaGVzdC1wcmVzc3VyZSBmb3J3YXJkIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzWzBdLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSwgc2VyaWVzQmFja3dhcmRDb29yZCk7XHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gZm9yd2FyZFNlZ3NbMF0uYmFja3dhcmRDb29yZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkQ29vcmQgZnJvbSB0aGUgZm9yd2FyZENvb3JkLiBjb25zaWRlciB0aGUgc2VyaWVzXHJcbiAgICAgICAgICAgIHNlZy5iYWNrd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZCAtXHJcbiAgICAgICAgICAgICAgICAoc2VnLmZvcndhcmRDb29yZCAtIHNlcmllc0JhY2t3YXJkQ29vcmQpIC8gLy8gYXZhaWxhYmxlIHdpZHRoIGZvciBzZXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAoc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEpOyAvLyAjIG9mIHNlZ21lbnRzIGluIHRoZSBzZXJpZXNcclxuICAgICAgICAgICAgLy8gdXNlIHRoaXMgc2VnbWVudCdzIGNvb3JkaW5hdGVzIHRvIGNvbXB1dGVkIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGVzcy1wcmVzc3VyaXplZFxyXG4gICAgICAgICAgICAvLyBmb3J3YXJkIHNlZ21lbnRzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhmb3J3YXJkU2Vnc1tpXSwgMCwgc2VnLmZvcndhcmRDb29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zb3J0Rm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoZm9yd2FyZFNlZ3MpIHtcclxuICAgICAgICBmb3J3YXJkU2Vncy5zb3J0KHV0aWxfMS5wcm94eSh0aGlzLCAnY29tcGFyZUZvcndhcmRTZWdzJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBmb3J3YXJkIHNlZ21lbnQgdG8gcmVseSBvbiBtb3JlIHdoZW4gY29tcHV0aW5nIGNvb3JkaW5hdGVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wYXJlRm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoc2VnMSwgc2VnMikge1xyXG4gICAgICAgIC8vIHB1dCBoaWdoZXItcHJlc3N1cmUgZmlyc3RcclxuICAgICAgICByZXR1cm4gc2VnMi5mb3J3YXJkUHJlc3N1cmUgLSBzZWcxLmZvcndhcmRQcmVzc3VyZSB8fFxyXG4gICAgICAgICAgICAvLyBwdXQgc2VnbWVudHMgdGhhdCBhcmUgY2xvc2VyIHRvIGluaXRpYWwgZWRnZSBmaXJzdCAoYW5kIGZhdm9yIG9uZXMgd2l0aCBubyBjb29yZHMgeWV0KVxyXG4gICAgICAgICAgICAoc2VnMS5iYWNrd2FyZENvb3JkIHx8IDApIC0gKHNlZzIuYmFja3dhcmRDb29yZCB8fCAwKSB8fFxyXG4gICAgICAgICAgICAvLyBkbyBub3JtYWwgc29ydGluZy4uLlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVFdmVudFNlZ3Moc2VnMSwgc2VnMik7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBoYWQgdGhlaXIgcG9zaXRpb24gY29vcmRpbmF0ZXMgY29tcHV0ZWQsXHJcbiAgICAvLyBhc3NpZ25zIHBvc2l0aW9uLXJlbGF0ZWQgQ1NTIHZhbHVlcyB0byB0aGVpciBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYXNzaWduRmdTZWdIb3Jpem9udGFscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3Moc2VnKSk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoZWlnaHQgaXMgc2hvcnQsIGFkZCBhIGNsYXNzTmFtZSBmb3IgYWx0ZXJuYXRlIHN0eWxpbmdcclxuICAgICAgICAgICAgaWYgKHNlZy5ib3R0b20gLSBzZWcudG9wIDwgMzApIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtc2hvcnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMvdmFsdWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW4gZXZlbnQgc2VnbWVudCBlbGVtZW50LlxyXG4gICAgLy8gQ29udGFpbnMgaW1wb3J0YW50IHBvc2l0aW9uaW5nLXJlbGF0ZWQgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGFueSBldmVudCBlbGVtZW50LCBjdXN0b21pemVkIG9yIG5vdC5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3MgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIHNob3VsZE92ZXJsYXAgPSB0aGlzLm9wdCgnc2xvdEV2ZW50T3ZlcmxhcCcpO1xyXG4gICAgICAgIHZhciBiYWNrd2FyZENvb3JkID0gc2VnLmJhY2t3YXJkQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgdmFyIGZvcndhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQ7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy50aW1lR3JpZC5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzKHNlZyk7IC8vIGdldCB0b3AvYm90dG9tIGZpcnN0XHJcbiAgICAgICAgdmFyIGlzUlRMID0gdGhpcy50aW1lR3JpZC5pc1JUTDtcclxuICAgICAgICB2YXIgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgIHZhciByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxyXG4gICAgICAgICAgICBmb3J3YXJkQ29vcmQgPSBNYXRoLm1pbigxLCBiYWNrd2FyZENvb3JkICsgKGZvcndhcmRDb29yZCAtIGJhY2t3YXJkQ29vcmQpICogMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JUTCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gMSAtIGZvcndhcmRDb29yZDtcclxuICAgICAgICAgICAgcmlnaHQgPSBiYWNrd2FyZENvb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IGJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gMSAtIGZvcndhcmRDb29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHMuekluZGV4ID0gc2VnLmxldmVsICsgMTsgLy8gY29udmVydCBmcm9tIDAtYmFzZSB0byAxLWJhc2VkXHJcbiAgICAgICAgcHJvcHMubGVmdCA9IGxlZnQgKiAxMDAgKyAnJSc7XHJcbiAgICAgICAgcHJvcHMucmlnaHQgPSByaWdodCAqIDEwMCArICclJztcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiBzZWcuZm9yd2FyZFByZXNzdXJlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cclxuICAgICAgICAgICAgcHJvcHNbaXNSVEwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnXSA9IDEwICogMjsgLy8gMTAgaXMgYSBndWVzc3RpbWF0ZSBvZiB0aGUgaWNvbidzIHdpZHRoXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRFdmVudFJlbmRlcmVyO1xyXG59KEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVHcmlkRXZlbnRSZW5kZXJlcjtcclxuLy8gQnVpbGRzIGFuIGFycmF5IG9mIHNlZ21lbnRzIFwibGV2ZWxzXCIuIFRoZSBmaXJzdCBsZXZlbCB3aWxsIGJlIHRoZSBsZWZ0bW9zdCB0aWVyIG9mIHNlZ21lbnRzIGlmIHRoZSBjYWxlbmRhciBpc1xyXG4vLyBsZWZ0LXRvLXJpZ2h0LCBvciB0aGUgcmlnaHRtb3N0IGlmIHRoZSBjYWxlbmRhciBpcyByaWdodC10by1sZWZ0LiBBc3N1bWVzIHRoZSBzZWdtZW50cyBhcmUgYWxyZWFkeSBvcmRlcmVkIGJ5IGRhdGUuXHJcbmZ1bmN0aW9uIGJ1aWxkU2xvdFNlZ0xldmVscyhzZWdzKSB7XHJcbiAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBzZWc7XHJcbiAgICB2YXIgajtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCB0aGUgbGV2ZWxzIGFuZCBzdG9wIG9uIHRoZSBmaXJzdCBsZXZlbCB3aGVyZSB0aGVyZSBhcmUgbm8gY29sbGlzaW9uc1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKCFjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNbal0pLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2VnLmxldmVsID0gajtcclxuICAgICAgICAobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZXZlbHM7XHJcbn1cclxuLy8gRm9yIGV2ZXJ5IHNlZ21lbnQsIGZpZ3VyZSBvdXQgdGhlIG90aGVyIHNlZ21lbnRzIHRoYXQgYXJlIGluIHN1YnNlcXVlbnRcclxuLy8gbGV2ZWxzIHRoYXQgYWxzbyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2UuIEFjY3VtdWxhdGUgaW4gc2VnLmZvcndhcmRTZWdzXHJcbmZ1bmN0aW9uIGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZXZlbDtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIHNlZztcclxuICAgIHZhciBrO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldmVsID0gbGV2ZWxzW2ldO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBzZWcgPSBsZXZlbFtqXTtcclxuICAgICAgICAgICAgc2VnLmZvcndhcmRTZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbGV2ZWxzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNba10sIHNlZy5mb3J3YXJkU2Vncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gRmlndXJlIG91dCB3aGljaCBwYXRoIGZvcndhcmQgKHZpYSBzZWcuZm9yd2FyZFNlZ3MpIHJlc3VsdHMgaW4gdGhlIGxvbmdlc3QgcGF0aCB1bnRpbFxyXG4vLyB0aGUgZnVydGhlc3QgZWRnZSBpcyByZWFjaGVkLiBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aCB3aWxsIGJlIHNlZy5mb3J3YXJkUHJlc3N1cmVcclxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMoc2VnKSB7XHJcbiAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICB2YXIgZm9yd2FyZFByZXNzdXJlID0gMDtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGZvcndhcmRTZWc7XHJcbiAgICBpZiAoc2VnLmZvcndhcmRQcmVzc3VyZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZvcndhcmRTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvcndhcmRTZWcgPSBmb3J3YXJkU2Vnc1tpXTtcclxuICAgICAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgY2hpbGQncyBtYXhpbXVtIGZvcndhcmQgcGF0aFxyXG4gICAgICAgICAgICBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhmb3J3YXJkU2VnKTtcclxuICAgICAgICAgICAgLy8gZWl0aGVyIHVzZSB0aGUgZXhpc3RpbmcgbWF4aW11bSwgb3IgdXNlIHRoZSBjaGlsZCdzIGZvcndhcmQgcHJlc3N1cmVcclxuICAgICAgICAgICAgLy8gcGx1cyBvbmUgKGZvciB0aGUgZm9yd2FyZFNlZyBpdHNlbGYpXHJcbiAgICAgICAgICAgIGZvcndhcmRQcmVzc3VyZSA9IE1hdGgubWF4KGZvcndhcmRQcmVzc3VyZSwgMSArIGZvcndhcmRTZWcuZm9yd2FyZFByZXNzdXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VnLmZvcndhcmRQcmVzc3VyZSA9IGZvcndhcmRQcmVzc3VyZTtcclxuICAgIH1cclxufVxyXG4vLyBGaW5kIGFsbCB0aGUgc2VnbWVudHMgaW4gYG90aGVyU2Vnc2AgdGhhdCB2ZXJ0aWNhbGx5IGNvbGxpZGUgd2l0aCBgc2VnYC5cclxuLy8gQXBwZW5kIGludG8gYW4gb3B0aW9uYWxseS1zdXBwbGllZCBgcmVzdWx0c2AgYXJyYXkgYW5kIHJldHVybi5cclxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgb3RoZXJTZWdzLCByZXN1bHRzKSB7XHJcbiAgICBpZiAocmVzdWx0cyA9PT0gdm9pZCAwKSB7IHJlc3VsdHMgPSBbXTsgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNTbG90U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzW2ldKSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gob3RoZXJTZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufVxyXG4vLyBEbyB0aGVzZSBzZWdtZW50cyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2U/XHJcbmZ1bmN0aW9uIGlzU2xvdFNlZ0NvbGxpc2lvbihzZWcxLCBzZWcyKSB7XHJcbiAgICByZXR1cm4gc2VnMS5ib3R0b20gPiBzZWcyLnRvcCAmJiBzZWcxLnRvcCA8IHNlZzIuYm90dG9tO1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG52YXIgVGltZUdyaWRIZWxwZXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVHcmlkSGVscGVyUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEhlbHBlclJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVHcmlkSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlck5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgc291cmNlRWw7XHJcbiAgICAgICAgLy8gVE9ETzogbm90IGdvb2QgdG8gY2FsbCBldmVudFJlbmRlcmVyIHRoaXMgd2F5XHJcbiAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzKHNlZ3MsIHRoaXMuY29tcG9uZW50LmhlbHBlckNvbnRhaW5lckVscyk7XHJcbiAgICAgICAgLy8gVHJ5IHRvIG1ha2UgdGhlIHNlZ21lbnQgdGhhdCBpcyBpbiB0aGUgc2FtZSByb3cgYXMgc291cmNlU2VnIGxvb2sgdGhlIHNhbWVcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlU2VnICYmIHNvdXJjZVNlZy5jb2wgPT09IHNlZy5jb2wpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUVsID0gc291cmNlU2VnLmVsO1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc291cmNlRWwuY3NzKCdsZWZ0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNvdXJjZUVsLmNzcygncmlnaHQnKSxcclxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLWxlZnQnOiBzb3VyY2VFbC5jc3MoJ21hcmdpbi1sZWZ0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1yaWdodCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLXJpZ2h0JylcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhlbHBlck5vZGVzLnB1c2goc2VnLmVsWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICQoaGVscGVyTm9kZXMpOyAvLyBtdXN0IHJldHVybiB0aGUgZWxlbWVudHMgcmVuZGVyZWRcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRIZWxwZXJSZW5kZXJlcjtcclxufShIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRIZWxwZXJSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcclxudmFyIFRpbWVHcmlkRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWRGaWxsUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEZpbGxSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgdGltZUdyaWQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgY29udGFpbmVyRWxzO1xyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgZWZmaWNpZW50IGxvb2t1cFxyXG4gICAgICAgIGlmICh0eXBlID09PSAnYmdFdmVudCcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWxzID0gdGltZUdyaWQuYmdDb250YWluZXJFbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5idXNpbmVzc0NvbnRhaW5lckVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2hpZ2hsaWdodCcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWxzID0gdGltZUdyaWQuaGlnaGxpZ2h0Q29udGFpbmVyRWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lR3JpZC51cGRhdGVTZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICAgICAgdGltZUdyaWQuYXR0YWNoU2Vnc0J5Q29sKHRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCBjb250YWluZXJFbHMpO1xyXG4gICAgICAgIHJldHVybiBzZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWcuZWxbMF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVHcmlkRmlsbFJlbmRlcmVyO1xyXG59KEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRGaWxsUmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBBIHJlY3Rhbmd1bGFyIHBhbmVsIHRoYXQgaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkIG92ZXIgb3RoZXIgY29udGVudFxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuT3B0aW9uczpcclxuICAtIGNsYXNzTmFtZSAoc3RyaW5nKVxyXG4gIC0gY29udGVudCAoSFRNTCBzdHJpbmcgb3IgalF1ZXJ5IGVsZW1lbnQgc2V0KVxyXG4gIC0gcGFyZW50RWxcclxuICAtIHRvcFxyXG4gIC0gbGVmdFxyXG4gIC0gcmlnaHQgKHRoZSB4IGNvb3JkIG9mIHdoZXJlIHRoZSByaWdodCBlZGdlIHNob3VsZCBiZS4gbm90IGEgXCJDU1NcIiByaWdodClcclxuICAtIGF1dG9IaWRlIChib29sZWFuKVxyXG4gIC0gc2hvdyAoY2FsbGJhY2spXHJcbiAgLSBoaWRlIChjYWxsYmFjaylcclxuKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIFBvcG92ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb3BvdmVyKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1hcmdpbiA9IDEwOyAvLyB0aGUgc3BhY2UgcmVxdWlyZWQgYmV0d2VlbiB0aGUgcG9wb3ZlciBhbmQgdGhlIGVkZ2VzIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8vIFNob3dzIHRoZSBwb3BvdmVyIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFJlbmRlcnMgaXQgaWYgbm90IGFscmVhZHlcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2hvdygpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEhpZGVzIHRoZSBwb3BvdmVyLCB0aHJvdWdoIENTUywgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCBmcm9tIHRoZSBET01cclxuICAgIFBvcG92ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaWRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENyZWF0ZXMgYHRoaXMuZWxgIGFuZCByZW5kZXJzIGNvbnRlbnQgaW5zaWRlIG9mIGl0XHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB0aGlzLmVsID0gJCgnPGRpdiBjbGFzcz1cImZjLXBvcG92ZXJcIi8+JylcclxuICAgICAgICAgICAgLmFkZENsYXNzKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKVxyXG4gICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gaW5pdGlhbGx5IHRvIHRoZSB0b3AgbGVmdCB0byBhdm9pZCBjcmVhdGluZyBzY3JvbGxiYXJzXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hcHBlbmQob3B0aW9ucy5jb250ZW50KVxyXG4gICAgICAgICAgICAuYXBwZW5kVG8ob3B0aW9ucy5wYXJlbnRFbCk7XHJcbiAgICAgICAgLy8gd2hlbiBhIGNsaWNrIGhhcHBlbnMgb24gYW55dGhpbmcgaW5zaWRlIHdpdGggYSAnZmMtY2xvc2UnIGNsYXNzTmFtZSwgaGlkZSB0aGUgcG9wb3ZlclxyXG4gICAgICAgIHRoaXMuZWwub24oJ2NsaWNrJywgJy5mYy1jbG9zZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9IaWRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nLCB0aGlzLmRvY3VtZW50TW91c2Vkb3duKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLmRvY3VtZW50TW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgISQoZXYudGFyZ2V0KS5jbG9zZXN0KHRoaXMuZWwpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlkZXMgYW5kIHVucmVnaXN0ZXJzIGFueSBoYW5kbGVyc1xyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nKTtcclxuICAgIH07XHJcbiAgICAvLyBQb3NpdGlvbnMgdGhlIHBvcG92ZXIgb3B0aW1hbGx5LCB1c2luZyB0aGUgdG9wL2xlZnQvcmlnaHQgb3B0aW9uc1xyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMuZWwub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5lbC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZWwub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICB2YXIgd2luZG93RWwgPSAkKHdpbmRvdyk7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0RWwgPSB1dGlsXzEuZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWwpO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydFRvcDtcclxuICAgICAgICB2YXIgdmlld3BvcnRMZWZ0O1xyXG4gICAgICAgIHZhciB2aWV3cG9ydE9mZnNldDtcclxuICAgICAgICB2YXIgdG9wOyAvLyB0aGUgXCJwb3NpdGlvblwiIChub3QgXCJvZmZzZXRcIikgdmFsdWVzIGZvciB0aGUgcG9wb3ZlclxyXG4gICAgICAgIHZhciBsZWZ0OyAvL1xyXG4gICAgICAgIC8vIGNvbXB1dGUgdG9wIGFuZCBsZWZ0XHJcbiAgICAgICAgdG9wID0gb3B0aW9ucy50b3AgfHwgMDtcclxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBvcHRpb25zLnJpZ2h0IC0gd2lkdGg7IC8vIGRlcml2ZSB0aGUgbGVmdCB2YWx1ZSBmcm9tIHRoZSByaWdodCB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aWV3cG9ydEVsLmlzKHdpbmRvdykgfHwgdmlld3BvcnRFbC5pcyhkb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgdmlld3BvcnRFbCA9IHdpbmRvd0VsO1xyXG4gICAgICAgICAgICB2aWV3cG9ydFRvcCA9IDA7IC8vIHRoZSB3aW5kb3cgaXMgYWx3YXlzIGF0IHRoZSB0b3AgbGVmdFxyXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSAwOyAvLyAoYW5kIC5vZmZzZXQoKSB3b24ndCB3b3JrIGlmIGNhbGxlZCBoZXJlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmlld3BvcnRPZmZzZXQgPSB2aWV3cG9ydEVsLm9mZnNldCgpO1xyXG4gICAgICAgICAgICB2aWV3cG9ydFRvcCA9IHZpZXdwb3J0T2Zmc2V0LnRvcDtcclxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gdmlld3BvcnRPZmZzZXQubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHdpbmRvdyBpcyBzY3JvbGxlZCwgaXQgY2F1c2VzIHRoZSB2aXNpYmxlIGFyZWEgdG8gYmUgZnVydGhlciBkb3duXHJcbiAgICAgICAgdmlld3BvcnRUb3AgKz0gd2luZG93RWwuc2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgdmlld3BvcnRMZWZ0ICs9IHdpbmRvd0VsLnNjcm9sbExlZnQoKTtcclxuICAgICAgICAvLyBjb25zdHJhaW4gdG8gdGhlIHZpZXcgcG9ydC4gaWYgY29uc3RyYWluZWQgYnkgdHdvIGVkZ2VzLCBnaXZlIHByZWNlZGVuY2UgdG8gdG9wL2xlZnRcclxuICAgICAgICBpZiAob3B0aW9ucy52aWV3cG9ydENvbnN0cmFpbiAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4odG9wLCB2aWV3cG9ydFRvcCArIHZpZXdwb3J0RWwub3V0ZXJIZWlnaHQoKSAtIGhlaWdodCAtIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCB2aWV3cG9ydFRvcCArIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIHZpZXdwb3J0TGVmdCArIHZpZXdwb3J0RWwub3V0ZXJXaWR0aCgpIC0gd2lkdGggLSB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCB2aWV3cG9ydExlZnQgKyB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWwuY3NzKHtcclxuICAgICAgICAgICAgdG9wOiB0b3AgLSBvcmlnaW4udG9wLFxyXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb3JpZ2luLmxlZnRcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxyXG4gICAgLy8gQXJndW1lbnRzIGJleW9uZCB0aGUgZmlyc3QgYG5hbWVgIGFyZSBmb3J3YXJkZWQgb24uXHJcbiAgICAvLyBUT0RPOiBiZXR0ZXIgY29kZSByZXVzZSBmb3IgdGhpcy4gUmVwZWF0IGNvZGVcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9wb3ZlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUG9wb3ZlcjtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhQb3BvdmVyKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcbi8qIEV2ZW50LXJlbmRlcmluZyBtZXRob2RzIGZvciB0aGUgRGF5R3JpZCBjbGFzc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIERheUdyaWRFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkRXZlbnRSZW5kZXJlcihkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZCA9IGRheUdyaWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIHRpbWVkIGJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgZXZlbnRSYW5nZXMgPSAkLmdyZXAoZXZlbnRSYW5nZXMsIGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFJhbmdlLmV2ZW50RGVmLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXJCZ1Jhbmdlcy5jYWxsKHRoaXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSBnaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzID0gdGhpcy5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xyXG4gICAgICAgIC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cclxuICAgICAgICB0aGlzLmRheUdyaWQucm93RWxzLmVhY2goZnVuY3Rpb24gKGksIHJvd05vZGUpIHtcclxuICAgICAgICAgICAgJChyb3dOb2RlKS5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiA+IHRhYmxlJykuYXBwZW5kKHJvd1N0cnVjdHNbaV0udGJvZHlFbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50c1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzIHx8IFtdO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3Q7XHJcbiAgICAgICAgd2hpbGUgKChyb3dTdHJ1Y3QgPSByb3dTdHJ1Y3RzLnBvcCgpKSkge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QudGJvZHlFbC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3dTdHJ1Y3RzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBVc2VzIHRoZSBnaXZlbiBldmVudHMgYXJyYXkgdG8gZ2VuZXJhdGUgPHRib2R5PiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b24uXHJcbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJvd1N0cnVjdCBvYmplY3RzIChzZWUgdGhlIGJvdHRvbSBvZiBgcmVuZGVyU2VnUm93YCkuXHJcbiAgICAvLyBQUkVDT05ESVRJT046IGVhY2ggc2VnbWVudCBzaG91ZCBhbHJlYWR5IGhhdmUgYSByZW5kZXJlZCBhbmQgYXNzaWduZWQgYC5lbGBcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWdSb3dzO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgc2VnUm93cyA9IHRoaXMuZ3JvdXBTZWdSb3dzKHNlZ3MpOyAvLyBncm91cCBpbnRvIG5lc3RlZCBhcnJheXNcclxuICAgICAgICAvLyBpdGVyYXRlIGVhY2ggcm93IG9mIHNlZ21lbnQgZ3JvdXBpbmdzXHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBzZWdSb3dzLmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93U3RydWN0cy5wdXNoKHRoaXMucmVuZGVyU2VnUm93KHJvdywgc2VnUm93c1tyb3ddKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3dTdHJ1Y3RzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgcm93ICMgYW5kIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFsbCBpbiB0aGUgc2FtZSByb3csIHJlbmRlciBhIDx0Ym9keT4gZWxlbWVudCwgYSBza2VsZXRvbiB0aGF0IGNvbnRhaW5zXHJcbiAgICAvLyB0aGUgc2VnbWVudHMuIFJldHVybnMgb2JqZWN0IHdpdGggYSBidW5jaCBvZiBpbnRlcm5hbCBkYXRhIGFib3V0IGhvdyB0aGUgcmVuZGVyIHdhcyBjYWxjdWxhdGVkLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgcm93U2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1JvdyA9IGZ1bmN0aW9uIChyb3csIHJvd1NlZ3MpIHtcclxuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5kYXlHcmlkLmNvbENudDtcclxuICAgICAgICB2YXIgc2VnTGV2ZWxzID0gdGhpcy5idWlsZFNlZ0xldmVscyhyb3dTZWdzKTsgLy8gZ3JvdXAgaW50byBzdWItYXJyYXlzIG9mIGxldmVsc1xyXG4gICAgICAgIHZhciBsZXZlbENudCA9IE1hdGgubWF4KDEsIHNlZ0xldmVscy5sZW5ndGgpOyAvLyBlbnN1cmUgYXQgbGVhc3Qgb25lIGxldmVsXHJcbiAgICAgICAgdmFyIHRib2R5ID0gJCgnPHRib2R5Lz4nKTtcclxuICAgICAgICB2YXIgc2VnTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3Igd2hpY2ggc2VnbWVudHMgYXJlIHJlbmRlcmVkIGludG8gd2hpY2ggbGV2ZWwrY29sIGNlbGxzXHJcbiAgICAgICAgdmFyIGNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciBhbGwgPHRkPiBlbGVtZW50cyBvZiB0aGUgbGV2ZWwrY29sIG1hdHJpeFxyXG4gICAgICAgIHZhciBsb25lQ2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIDx0ZD4gZWxlbWVudHMgdGhhdCBvbmx5IHRha2UgdXAgYSBzaW5nbGUgY29sdW1uXHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGxldmVsU2VncztcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIHZhciB0cjtcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciB0ZDtcclxuICAgICAgICAvLyBwb3B1bGF0ZXMgZW1wdHkgY2VsbHMgZnJvbSB0aGUgY3VycmVudCBjb2x1bW4gKGBjb2xgKSB0byBgZW5kQ29sYFxyXG4gICAgICAgIGZ1bmN0aW9uIGVtcHR5Q2VsbHNVbnRpbChlbmRDb2wpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdyYWIgYSBjZWxsIGZyb20gdGhlIGxldmVsIGFib3ZlIGFuZCBleHRlbmQgaXRzIHJvd3NwYW4uIG90aGVyd2lzZSwgY3JlYXRlIGEgZnJlc2ggY2VsbFxyXG4gICAgICAgICAgICAgICAgdGQgPSAobG9uZUNlbGxNYXRyaXhbaSAtIDFdIHx8IFtdKVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYXR0cigncm93c3BhbicsIHBhcnNlSW50KHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxLCAxMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRkID0gJCgnPHRkLz4nKTtcclxuICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmQodGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICBsb25lQ2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXZlbFNlZ3MgPSBzZWdMZXZlbHNbaV07XHJcbiAgICAgICAgICAgIGNvbCA9IDA7XHJcbiAgICAgICAgICAgIHRyID0gJCgnPHRyLz4nKTtcclxuICAgICAgICAgICAgc2VnTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBjZWxsTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBsb25lQ2VsbE1hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgLy8gbGV2ZWxDbnQgbWlnaHQgYmUgMSBldmVuIHRob3VnaCB0aGVyZSBhcmUgbm8gYWN0dWFsIGxldmVscy4gcHJvdGVjdCBhZ2FpbnN0IHRoaXMuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2luZ2xlIGVtcHR5IHJvdyBpcyB1c2VmdWwgZm9yIHN0eWxpbmcuXHJcbiAgICAgICAgICAgIGlmIChsZXZlbFNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbFNlZ3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3Nbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb250YWluZXIgdGhhdCBvY2N1cGllcyBvciBtb3JlIGNvbHVtbnMuIGFwcGVuZCB0aGUgZXZlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICB0ZCA9ICQoJzx0ZCBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiLz4nKS5hcHBlbmQoc2VnLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnLmxlZnRDb2wgIT09IHNlZy5yaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5hdHRyKCdjb2xzcGFuJywgc2VnLnJpZ2h0Q29sIC0gc2VnLmxlZnRDb2wgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01hdHJpeFtpXVtjb2xdID0gc2VnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKHRkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgcm93XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5ib29rZW5kQ2VsbHModHIpO1xyXG4gICAgICAgICAgICB0Ym9keS5hcHBlbmQodHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgdGJvZHlFbDogdGJvZHksXHJcbiAgICAgICAgICAgIGNlbGxNYXRyaXg6IGNlbGxNYXRyaXgsXHJcbiAgICAgICAgICAgIHNlZ01hdHJpeDogc2VnTWF0cml4LFxyXG4gICAgICAgICAgICBzZWdMZXZlbHM6IHNlZ0xldmVscyxcclxuICAgICAgICAgICAgc2Vnczogcm93U2Vnc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gU3RhY2tzIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgd2hpY2ggYXJlIGFsbCBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdywgaW50byBzdWJhcnJheXMgb2YgdmVydGljYWwgbGV2ZWxzLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgc2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnTGV2ZWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICAvLyBHaXZlIHByZWZlcmVuY2UgdG8gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGNyaXRlcmlhLCBzbyB0aGV5IGhhdmVcclxuICAgICAgICAvLyBhIGNoYW5jZSB0byBiZSBjbG9zZXIgdG8gdGhlIHRvcC5cclxuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGUgdG9wbW9zdCwgdW50aWwgdGhlIHNlZ21lbnQgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgc2VnbWVudHNcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0RheVNlZ0NvbGxpc2lvbihzZWcsIGxldmVsc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBgamAgbm93IGhvbGRzIHRoZSBkZXNpcmVkIHN1YnJvdyBpbmRleFxyXG4gICAgICAgICAgICBzZWcubGV2ZWwgPSBqO1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGxldmVsIGFycmF5IGlmIG5lZWRlZCBhbmQgYXBwZW5kIHNlZ21lbnRcclxuICAgICAgICAgICAgKGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yZGVyIHNlZ21lbnRzIGxlZnQtdG8tcmlnaHQuIHZlcnkgaW1wb3J0YW50IGlmIGNhbGVuZGFyIGlzIFJUTFxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV2ZWxzW2pdLnNvcnQoY29tcGFyZURheVNlZ0NvbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGV2ZWxzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3Mgcm93XHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ3JvdXBTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2VnUm93cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRheUdyaWQucm93Q250OyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93cy5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93c1tzZWdzW2ldLnJvd10ucHVzaChzZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ1Jvd3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnZXh0cmFTbWFsbFRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjZwXCIgb3IgXCI2OjMwcFwiXHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheUdyaWQuY29sQ250ID09PSAxOyAvLyB3ZSdsbCBsaWtlbHkgaGF2ZSBzcGFjZSBpZiB0aGVyZSdzIG9ubHkgb25lIGRheVxyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCB0byBiZSB1c2VkIGZvciB0aGUgZGVmYXVsdCBlbGVtZW50IGZvciBhbiBpbmRpdmlkdWFsIHNlZ21lbnRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBpc0FsbERheSA9IHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5O1xyXG4gICAgICAgIHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERlZkRyYWdnYWJsZShldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gIWRpc2FibGVSZXNpemluZyAmJiBpc0FsbERheSAmJlxyXG4gICAgICAgICAgICBzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGlzQWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0U2VnQ2xhc3NlcyhzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZUZyb21TdGFydCB8fCBpc1Jlc2l6YWJsZUZyb21FbmQpO1xyXG4gICAgICAgIHZhciBza2luQ3NzID0gdXRpbF8xLmNzc1RvU3RyKHRoaXMuZ2V0U2tpbkNzcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciB0aW1lSHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciB0aW1lVGV4dDtcclxuICAgICAgICB2YXIgdGl0bGVIdG1sO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LWdyaWQtZXZlbnQnLCAnZmMtaC1ldmVudCcpO1xyXG4gICAgICAgIC8vIE9ubHkgZGlzcGxheSBhIHRpbWVkIGV2ZW50cyB0aW1lIGlmIGl0IGlzIHRoZSBzdGFydGluZyBzZWdtZW50XHJcbiAgICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgaWYgKHRpbWVUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9ICc8c3BhbiBjbGFzcz1cImZjLXRpbWVcIj4nICsgdXRpbF8xLmh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpdGxlSHRtbCA9XHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAodXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpIHx8ICcmbmJzcDsnKSArIC8vIHdlIGFsd2F5cyB3YW50IG9uZSBsaW5lIG9mIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nO1xyXG4gICAgICAgIHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKHNraW5Dc3MgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGF5R3JpZC5pc1JUTCA/XHJcbiAgICAgICAgICAgICAgICB0aXRsZUh0bWwgKyAnICcgKyB0aW1lSHRtbCA6IC8vIHB1dCBhIG5hdHVyYWwgc3BhY2UgaW4gYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgdGltZUh0bWwgKyAnICcgKyB0aXRsZUh0bWwgLy9cclxuICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChpc1Jlc2l6YWJsZUZyb21FbmQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L2E+JztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZEV2ZW50UmVuZGVyZXI7XHJcbn0oRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEV2ZW50UmVuZGVyZXI7XHJcbi8vIENvbXB1dGVzIHdoZXRoZXIgdHdvIHNlZ21lbnRzJyBjb2x1bW5zIGNvbGxpZGUuIFRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LlxyXG5mdW5jdGlvbiBpc0RheVNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vncykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3RoZXJTZWc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgb3RoZXJTZWcgPSBvdGhlclNlZ3NbaV07XHJcbiAgICAgICAgaWYgKG90aGVyU2VnLmxlZnRDb2wgPD0gc2VnLnJpZ2h0Q29sICYmXHJcbiAgICAgICAgICAgIG90aGVyU2VnLnJpZ2h0Q29sID49IHNlZy5sZWZ0Q29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIGxlZnRtb3N0IGV2ZW50XHJcbmZ1bmN0aW9uIGNvbXBhcmVEYXlTZWdDb2xzKGEsIGIpIHtcclxuICAgIHJldHVybiBhLmxlZnRDb2wgLSBiLmxlZnRDb2w7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbnZhciBEYXlHcmlkSGVscGVyUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkSGVscGVyUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkSGVscGVyUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUmVuZGVycyBhIG1vY2sgXCJoZWxwZXJcIiBldmVudC4gYHNvdXJjZVNlZ2AgaXMgdGhlIGFzc29jaWF0ZWQgaW50ZXJuYWwgc2VnbWVudCBvYmplY3QuIEl0IGNhbiBiZSBudWxsLlxyXG4gICAgRGF5R3JpZEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIHNvdXJjZVNlZykge1xyXG4gICAgICAgIHZhciBoZWxwZXJOb2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzO1xyXG4gICAgICAgIC8vIFRPRE86IG5vdCBnb29kIHRvIGNhbGwgZXZlbnRSZW5kZXJlciB0aGlzIHdheVxyXG4gICAgICAgIHJvd1N0cnVjdHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyU2VnUm93cyhzZWdzKTtcclxuICAgICAgICAvLyBpbmplY3QgZWFjaCBuZXcgZXZlbnQgc2tlbGV0b24gaW50byBlYWNoIGFzc29jaWF0ZWQgcm93XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucm93RWxzLmVhY2goZnVuY3Rpb24gKHJvdywgcm93Tm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcm93RWwgPSAkKHJvd05vZGUpOyAvLyB0aGUgLmZjLXJvd1xyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1oZWxwZXItc2tlbGV0b25cIj48dGFibGUvPjwvZGl2PicpOyAvLyB3aWxsIGJlIGFic29sdXRlbHkgcG9zaXRpb25lZFxyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25Ub3BFbDtcclxuICAgICAgICAgICAgdmFyIHNrZWxldG9uVG9wO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmlnaW5hbCBzZWdtZW50LCBtYXRjaCB0aGUgdG9wIHBvc2l0aW9uLiBPdGhlcndpc2UsIHB1dCBpdCBhdCB0aGUgcm93J3MgdG9wIGxldmVsXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLnJvdyA9PT0gcm93KSB7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvblRvcCA9IHNvdXJjZVNlZy5lbC5wb3NpdGlvbigpLnRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0Ym9keScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFza2VsZXRvblRvcEVsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0YWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25Ub3AgPSBza2VsZXRvblRvcEVsLnBvc2l0aW9uKCkudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNrZWxldG9uRWwuY3NzKCd0b3AnLCBza2VsZXRvblRvcClcclxuICAgICAgICAgICAgICAgIC5maW5kKCd0YWJsZScpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHJvd1N0cnVjdHNbcm93XS50Ym9keUVsKTtcclxuICAgICAgICAgICAgcm93RWwuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgICAgICAgICBoZWxwZXJOb2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAkKGhlbHBlck5vZGVzKTsgLy8gbXVzdCByZXR1cm4gdGhlIGVsZW1lbnRzIHJlbmRlcmVkXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWRIZWxwZXJSZW5kZXJlcjtcclxufShIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEhlbHBlclJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XHJcbnZhciBEYXlHcmlkRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZEZpbGxSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWRGaWxsUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZmlsbFNlZ1RhZyA9ICd0ZCc7IC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRhZyBuYW1lXHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF5R3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBza2VsZXRvbkVsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNrZWxldG9uRWwgPSB0aGlzLnJlbmRlckZpbGxSb3codHlwZSwgc2VnKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucm93RWxzLmVxKHNlZy5yb3cpLmFwcGVuZChza2VsZXRvbkVsKTtcclxuICAgICAgICAgICAgbm9kZXMucHVzaChza2VsZXRvbkVsWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSByb3cgb2YgYSBmaWxsLiBSZXF1aXJlcyB0aGUgc2VnJ3MgZWwgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGaWxsUm93ID0gZnVuY3Rpb24gKHR5cGUsIHNlZykge1xyXG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbXBvbmVudC5jb2xDbnQ7XHJcbiAgICAgICAgdmFyIHN0YXJ0Q29sID0gc2VnLmxlZnRDb2w7XHJcbiAgICAgICAgdmFyIGVuZENvbCA9IHNlZy5yaWdodENvbCArIDE7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcclxuICAgICAgICB2YXIgc2tlbGV0b25FbDtcclxuICAgICAgICB2YXIgdHJFbDtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdiZ2V2ZW50JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy0nICsgY2xhc3NOYW1lICsgJy1za2VsZXRvblwiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlPjx0ci8+PC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgICAgIHRyRWwgPSBza2VsZXRvbkVsLmZpbmQoJ3RyJyk7XHJcbiAgICAgICAgaWYgKHN0YXJ0Q29sID4gMCkge1xyXG4gICAgICAgICAgICB0ckVsLmFwcGVuZCgnPHRkIGNvbHNwYW49XCInICsgc3RhcnRDb2wgKyAnXCIvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ckVsLmFwcGVuZChzZWcuZWwuYXR0cignY29sc3BhbicsIGVuZENvbCAtIHN0YXJ0Q29sKSk7XHJcbiAgICAgICAgaWYgKGVuZENvbCA8IGNvbENudCkge1xyXG4gICAgICAgICAgICB0ckVsLmFwcGVuZCgnPHRkIGNvbHNwYW49XCInICsgKGNvbENudCAtIGVuZENvbCkgKyAnXCIvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5ib29rZW5kQ2VsbHModHJFbCk7XHJcbiAgICAgICAgcmV0dXJuIHNrZWxldG9uRWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWRGaWxsUmVuZGVyZXI7XHJcbn0oRmlsbFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkRmlsbFJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjgpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmVuZGVyVW56b25lZFJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICB2YXIgZW5kID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHJvd0NudDtcclxuICAgICAgICAvLyBlbnN1cmUgNiB3ZWVrc1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnZml4ZWRXZWVrQ291bnQnKSkge1xyXG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xyXG4gICAgICAgICAgICBlbmQuZGlmZihzdGFydCwgJ3dlZWtzJywgdHJ1ZSkgLy8gZG9udFJvdW5kPXRydWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZW5kLmFkZCg2IC0gcm93Q250LCAnd2Vla3MnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufShCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxudmFyIExpc3RFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXN0RXZlbnRSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBMaXN0RXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBpZiAoIXNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlbmRlckVtcHR5TWVzc2FnZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyU2VnTGlzdChzZWdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCByb3dcclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdGhlbWUgPSBjYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnQgPSBzZWcuZm9vdHByaW50O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50Rm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRGb290cHJpbnQgPSBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIHVybCA9IGV2ZW50RGVmLnVybDtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFsnZmMtbGlzdC1pdGVtJ10uY29uY2F0KHRoaXMuZ2V0Q2xhc3NlcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciBiZ0NvbG9yID0gdGhpcy5nZXRCZ0NvbG9yKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgdGltZUh0bWw7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICB0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2aWV3LmlzTXVsdGlEYXlSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKHRoaXMuX2dldFRpbWVUZXh0KGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLnN0YXJ0TXMpLCBjYWxlbmRhci5tc1RvTW9tZW50KHNlZy5lbmRNcyksIGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGltZUh0bWwgPSB2aWV3LmdldEFsbERheUh0bWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgbm9ybWFsIHRpbWUgdGV4dCBmb3IgdGhlICpldmVudCdzKiB0aW1lc1xyXG4gICAgICAgICAgICB0aW1lSHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKHRoaXMuZ2V0VGltZVRleHQoZXZlbnRGb290cHJpbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWhhcy11cmwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgP1xyXG4gICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS10aW1lICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICh0aW1lSHRtbCB8fCAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS1tYXJrZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLWV2ZW50LWRvdFwiJyArXHJcbiAgICAgICAgICAgIChiZ0NvbG9yID9cclxuICAgICAgICAgICAgICAgICcgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBiZ0NvbG9yICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPjwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tdGl0bGUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8YScgKyAodXJsID8gJyBocmVmPVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKHVybCkgKyAnXCInIDogJycpICsgJz4nICtcclxuICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpICtcclxuICAgICAgICAgICAgJzwvYT4nICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgLy8gbGlrZSBcIjQ6MDBhbVwiXHJcbiAgICBMaXN0RXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ21lZGl1bVRpbWVGb3JtYXQnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdEV2ZW50UmVuZGVyZXI7XHJcbn0oRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdEV2ZW50UmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgRXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XHJcbnZhciBMaXN0RXZlbnRQb2ludGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKExpc3RFdmVudFBvaW50aW5nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlzdEV2ZW50UG9pbnRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yIGV2ZW50cyB3aXRoIGEgdXJsLCB0aGUgd2hvbGUgPHRyPiBzaG91bGQgYmUgY2xpY2thYmxlLFxyXG4gICAgLy8gYnV0IGl0J3MgaW1wb3NzaWJsZSB0byB3cmFwIHdpdGggYW4gPGE+IHRhZy4gc2ltdWxhdGUgdGhpcy5cclxuICAgIExpc3RFdmVudFBvaW50aW5nLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIHVybDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgc2VnLCBldik7IC8vIG1pZ2h0IHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uXHJcbiAgICAgICAgLy8gbm90IGNsaWNraW5nIG9uIG9yIHdpdGhpbiBhbiA8YT4gd2l0aCBhbiBocmVmXHJcbiAgICAgICAgaWYgKCEkKGV2LnRhcmdldCkuY2xvc2VzdCgnYVtocmVmXScpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB1cmwgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmLnVybDtcclxuICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsOyAvLyBzaW11bGF0ZSBsaW5rIGNsaWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RFdmVudFBvaW50aW5nO1xyXG59KEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RFdmVudFBvaW50aW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XHJcbnZhciBGdW5jRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE1KTtcclxudmFyIEpzb25GZWVkRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE2KTtcclxuRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnJlZ2lzdGVyQ2xhc3MoQXJyYXlFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5FdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucmVnaXN0ZXJDbGFzcyhGdW5jRXZlbnRTb3VyY2VfMS5kZWZhdWx0KTtcclxuRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnJlZ2lzdGVyQ2xhc3MoSnNvbkZlZWRFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVGhlbWVSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XHJcbnZhciBTdGFuZGFyZFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMyk7XHJcbnZhciBKcXVlcnlVaVRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNCk7XHJcbnZhciBCb290c3RyYXAzVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjU4KTtcclxudmFyIEJvb3RzdHJhcDRUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTkpO1xyXG5UaGVtZVJlZ2lzdHJ5XzEuZGVmaW5lVGhlbWVTeXN0ZW0oJ3N0YW5kYXJkJywgU3RhbmRhcmRUaGVtZV8xLmRlZmF1bHQpO1xyXG5UaGVtZVJlZ2lzdHJ5XzEuZGVmaW5lVGhlbWVTeXN0ZW0oJ2pxdWVyeS11aScsIEpxdWVyeVVpVGhlbWVfMS5kZWZhdWx0KTtcclxuVGhlbWVSZWdpc3RyeV8xLmRlZmluZVRoZW1lU3lzdGVtKCdib290c3RyYXAzJywgQm9vdHN0cmFwM1RoZW1lXzEuZGVmYXVsdCk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbSgnYm9vdHN0cmFwNCcsIEJvb3RzdHJhcDRUaGVtZV8xLmRlZmF1bHQpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBCb290c3RyYXAzVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCb290c3RyYXAzVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCb290c3RyYXAzVGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJvb3RzdHJhcDNUaGVtZTtcclxufShUaGVtZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm9vdHN0cmFwM1RoZW1lO1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICdmYy1ib290c3RyYXAzJyxcclxuICAgIHRhYmxlR3JpZDogJ3RhYmxlLWJvcmRlcmVkJyxcclxuICAgIHRhYmxlTGlzdDogJ3RhYmxlJyxcclxuICAgIHRhYmxlTGlzdEhlYWRpbmc6ICdhY3RpdmUnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdidG4tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnYnRuIGJ0bi1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdkaXNhYmxlZCcsXHJcbiAgICB0b2RheTogJ2FsZXJ0IGFsZXJ0LWluZm8nLFxyXG4gICAgcG9wb3ZlcjogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ3BhbmVsLWhlYWRpbmcnLFxyXG4gICAgcG9wb3ZlckNvbnRlbnQ6ICdwYW5lbC1ib2R5JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICAvLyBmb3IgbGVmdC9yaWdodCBib3JkZXIgY29sb3Igd2hlbiBib3JkZXIgaXMgaW5zZXQgZnJvbSBlZGdlcyAoYWxsLWRheSBpbiBhZ2VuZGEgdmlldylcclxuICAgIC8vIGF2b2lkIGBwYW5lbGAgY2xhc3MgYi9jIGRvbid0IHdhbnQgbWFyZ2lucy9yYWRpdXMuIG9ubHkgYm9yZGVyIGNvbG9yLlxyXG4gICAgaGVhZGVyUm93OiAncGFuZWwtZGVmYXVsdCcsXHJcbiAgICBkYXlSb3c6ICdwYW5lbC1kZWZhdWx0JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICdwYW5lbCBwYW5lbC1kZWZhdWx0J1xyXG59O1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnZ2x5cGhpY29uJztcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcclxuICAgIGNsb3NlOiAnZ2x5cGhpY29uLXJlbW92ZScsXHJcbiAgICBwcmV2OiAnZ2x5cGhpY29uLWNoZXZyb24tbGVmdCcsXHJcbiAgICBuZXh0OiAnZ2x5cGhpY29uLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgcHJldlllYXI6ICdnbHlwaGljb24tYmFja3dhcmQnLFxyXG4gICAgbmV4dFllYXI6ICdnbHlwaGljb24tZm9yd2FyZCdcclxufTtcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYm9vdHN0cmFwR2x5cGhpY29ucyc7XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2Jvb3RzdHJhcEdseXBoaWNvbic7XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2dseXBoaWNvbi0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBCb290c3RyYXA0VGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCb290c3RyYXA0VGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCb290c3RyYXA0VGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJvb3RzdHJhcDRUaGVtZTtcclxufShUaGVtZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm9vdHN0cmFwNFRoZW1lO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICdmYy1ib290c3RyYXA0JyxcclxuICAgIHRhYmxlR3JpZDogJ3RhYmxlLWJvcmRlcmVkJyxcclxuICAgIHRhYmxlTGlzdDogJ3RhYmxlJyxcclxuICAgIHRhYmxlTGlzdEhlYWRpbmc6ICd0YWJsZS1hY3RpdmUnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdidG4tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnYnRuIGJ0bi1wcmltYXJ5JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdkaXNhYmxlZCcsXHJcbiAgICB0b2RheTogJ2FsZXJ0IGFsZXJ0LWluZm8nLFxyXG4gICAgcG9wb3ZlcjogJ2NhcmQgY2FyZC1wcmltYXJ5JyxcclxuICAgIHBvcG92ZXJIZWFkZXI6ICdjYXJkLWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ2NhcmQtYm9keScsXHJcbiAgICAvLyBkYXkgZ3JpZFxyXG4gICAgLy8gZm9yIGxlZnQvcmlnaHQgYm9yZGVyIGNvbG9yIHdoZW4gYm9yZGVyIGlzIGluc2V0IGZyb20gZWRnZXMgKGFsbC1kYXkgaW4gYWdlbmRhIHZpZXcpXHJcbiAgICAvLyBhdm9pZCBgdGFibGVgIGNsYXNzIGIvYyBkb24ndCB3YW50IG1hcmdpbnMvcGFkZGluZy9zdHJ1Y3R1cmUuIG9ubHkgYm9yZGVyIGNvbG9yLlxyXG4gICAgaGVhZGVyUm93OiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgZGF5Um93OiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ2NhcmQgY2FyZC1wcmltYXJ5J1xyXG59O1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnZmEnO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICdmYS10aW1lcycsXHJcbiAgICBwcmV2OiAnZmEtY2hldnJvbi1sZWZ0JyxcclxuICAgIG5leHQ6ICdmYS1jaGV2cm9uLXJpZ2h0JyxcclxuICAgIHByZXZZZWFyOiAnZmEtYW5nbGUtZG91YmxlLWxlZnQnLFxyXG4gICAgbmV4dFllYXI6ICdmYS1hbmdsZS1kb3VibGUtcmlnaHQnXHJcbn07XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2Jvb3RzdHJhcEZvbnRBd2Vzb21lJztcclxuQm9vdHN0cmFwNFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnYm9vdHN0cmFwRm9udEF3ZXNvbWUnO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICdmYS0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVmlld1JlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XHJcbnZhciBNb250aFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI5KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnYmFzaWMnLCB7XHJcbiAgICAnY2xhc3MnOiBCYXNpY1ZpZXdfMS5kZWZhdWx0XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdiYXNpY0RheScsIHtcclxuICAgIHR5cGU6ICdiYXNpYycsXHJcbiAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2Jhc2ljV2VlaycsIHtcclxuICAgIHR5cGU6ICdiYXNpYycsXHJcbiAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdtb250aCcsIHtcclxuICAgICdjbGFzcyc6IE1vbnRoVmlld18xLmRlZmF1bHQsXHJcbiAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWVcclxuICAgIH1cclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgQWdlbmRhVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjYpO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdhZ2VuZGEnLCB7XHJcbiAgICAnY2xhc3MnOiBBZ2VuZGFWaWV3XzEuZGVmYXVsdCxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgYWxsRGF5U2xvdDogdHJ1ZSxcclxuICAgICAgICBzbG90RHVyYXRpb246ICcwMDozMDowMCcsXHJcbiAgICAgICAgc2xvdEV2ZW50T3ZlcmxhcDogdHJ1ZSAvLyBhIGJhZCBuYW1lLiBjb25mdXNlZCB3aXRoIG92ZXJsYXAvY29uc3RyYWludCBzeXN0ZW1cclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2FnZW5kYURheScsIHtcclxuICAgIHR5cGU6ICdhZ2VuZGEnLFxyXG4gICAgZHVyYXRpb246IHsgZGF5czogMSB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdhZ2VuZGFXZWVrJywge1xyXG4gICAgdHlwZTogJ2FnZW5kYScsXHJcbiAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9XHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVmlld1JlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIExpc3RWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMCk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3QnLCB7XHJcbiAgICAnY2xhc3MnOiBMaXN0Vmlld18xLmRlZmF1bHQsXHJcbiAgICBidXR0b25UZXh0S2V5OiAnbGlzdCcsXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGJ1dHRvblRleHQ6ICdsaXN0JyxcclxuICAgICAgICBsaXN0RGF5Rm9ybWF0OiAnTEwnLFxyXG4gICAgICAgIG5vRXZlbnRzTWVzc2FnZTogJ05vIGV2ZW50cyB0byBkaXNwbGF5J1xyXG4gICAgfVxyXG59KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnbGlzdERheScsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0V2VlaycsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlGb3JtYXQ6ICdkZGRkJyxcclxuICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiAnTEwnXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0TW9udGgnLCB7XHJcbiAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICBkdXJhdGlvbjogeyBtb250aDogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0WWVhcicsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IHllYXI6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUFsdEZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgfVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyIsInZhciBtYXAgPSB7XG5cdFwiLi9hZlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYWYuanNcIixcblx0XCIuL2FmLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hZi5qc1wiLFxuXHRcIi4vYXJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLmpzXCIsXG5cdFwiLi9hci1kelwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItZHouanNcIixcblx0XCIuL2FyLWR6LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1kei5qc1wiLFxuXHRcIi4vYXIta3dcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWt3LmpzXCIsXG5cdFwiLi9hci1rdy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIta3cuanNcIixcblx0XCIuL2FyLWx5XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1seS5qc1wiLFxuXHRcIi4vYXItbHkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWx5LmpzXCIsXG5cdFwiLi9hci1tYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItbWEuanNcIixcblx0XCIuL2FyLW1hLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1tYS5qc1wiLFxuXHRcIi4vYXItc2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXNhLmpzXCIsXG5cdFwiLi9hci1zYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItc2EuanNcIixcblx0XCIuL2FyLXRuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci10bi5qc1wiLFxuXHRcIi4vYXItdG4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXRuLmpzXCIsXG5cdFwiLi9hci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIuanNcIixcblx0XCIuL2F6XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hei5qc1wiLFxuXHRcIi4vYXouanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2F6LmpzXCIsXG5cdFwiLi9iZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmUuanNcIixcblx0XCIuL2JlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iZS5qc1wiLFxuXHRcIi4vYmdcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzXCIsXG5cdFwiLi9iZy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmcuanNcIixcblx0XCIuL2JtXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibS5qc1wiLFxuXHRcIi4vYm0uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JtLmpzXCIsXG5cdFwiLi9iblwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm4uanNcIixcblx0XCIuL2JuLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibi5qc1wiLFxuXHRcIi4vYm9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzXCIsXG5cdFwiLi9iby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm8uanNcIixcblx0XCIuL2JyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ici5qc1wiLFxuXHRcIi4vYnIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JyLmpzXCIsXG5cdFwiLi9ic1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnMuanNcIixcblx0XCIuL2JzLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9icy5qc1wiLFxuXHRcIi4vY2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NhLmpzXCIsXG5cdFwiLi9jYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY2EuanNcIixcblx0XCIuL2NzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jcy5qc1wiLFxuXHRcIi4vY3MuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NzLmpzXCIsXG5cdFwiLi9jdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3YuanNcIixcblx0XCIuL2N2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jdi5qc1wiLFxuXHRcIi4vY3lcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N5LmpzXCIsXG5cdFwiLi9jeS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3kuanNcIixcblx0XCIuL2RhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kYS5qc1wiLFxuXHRcIi4vZGEuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RhLmpzXCIsXG5cdFwiLi9kZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUuanNcIixcblx0XCIuL2RlLWF0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1hdC5qc1wiLFxuXHRcIi4vZGUtYXQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWF0LmpzXCIsXG5cdFwiLi9kZS1jaFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtY2guanNcIixcblx0XCIuL2RlLWNoLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1jaC5qc1wiLFxuXHRcIi4vZGUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLmpzXCIsXG5cdFwiLi9kdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZHYuanNcIixcblx0XCIuL2R2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kdi5qc1wiLFxuXHRcIi4vZWxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VsLmpzXCIsXG5cdFwiLi9lbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZWwuanNcIixcblx0XCIuL2VuLWF1XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1hdS5qc1wiLFxuXHRcIi4vZW4tYXUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWF1LmpzXCIsXG5cdFwiLi9lbi1jYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tY2EuanNcIixcblx0XCIuL2VuLWNhLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1jYS5qc1wiLFxuXHRcIi4vZW4tZ2JcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWdiLmpzXCIsXG5cdFwiLi9lbi1nYi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tZ2IuanNcIixcblx0XCIuL2VuLWllXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pZS5qc1wiLFxuXHRcIi4vZW4taWUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWllLmpzXCIsXG5cdFwiLi9lbi1pbFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4taWwuanNcIixcblx0XCIuL2VuLWlsLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pbC5qc1wiLFxuXHRcIi4vZW4tbnpcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLW56LmpzXCIsXG5cdFwiLi9lbi1uei5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tbnouanNcIixcblx0XCIuL2VvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lby5qc1wiLFxuXHRcIi4vZW8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VvLmpzXCIsXG5cdFwiLi9lc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMuanNcIixcblx0XCIuL2VzLWRvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy1kby5qc1wiLFxuXHRcIi4vZXMtZG8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLWRvLmpzXCIsXG5cdFwiLi9lcy11c1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtdXMuanNcIixcblx0XCIuL2VzLXVzLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy11cy5qc1wiLFxuXHRcIi4vZXMuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLmpzXCIsXG5cdFwiLi9ldFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXQuanNcIixcblx0XCIuL2V0LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldC5qc1wiLFxuXHRcIi4vZXVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V1LmpzXCIsXG5cdFwiLi9ldS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXUuanNcIixcblx0XCIuL2ZhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mYS5qc1wiLFxuXHRcIi4vZmEuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZhLmpzXCIsXG5cdFwiLi9maVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZmkuanNcIixcblx0XCIuL2ZpLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9maS5qc1wiLFxuXHRcIi4vZm9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZvLmpzXCIsXG5cdFwiLi9mby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZm8uanNcIixcblx0XCIuL2ZyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qc1wiLFxuXHRcIi4vZnItY2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNhLmpzXCIsXG5cdFwiLi9mci1jYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2EuanNcIixcblx0XCIuL2ZyLWNoXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci1jaC5qc1wiLFxuXHRcIi4vZnItY2guanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNoLmpzXCIsXG5cdFwiLi9mci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnIuanNcIixcblx0XCIuL2Z5XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9meS5qc1wiLFxuXHRcIi4vZnkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2Z5LmpzXCIsXG5cdFwiLi9nZFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2QuanNcIixcblx0XCIuL2dkLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nZC5qc1wiLFxuXHRcIi4vZ2xcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dsLmpzXCIsXG5cdFwiLi9nbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2wuanNcIixcblx0XCIuL2dvbS1sYXRuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nb20tbGF0bi5qc1wiLFxuXHRcIi4vZ29tLWxhdG4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dvbS1sYXRuLmpzXCIsXG5cdFwiLi9ndVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ3UuanNcIixcblx0XCIuL2d1LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ndS5qc1wiLFxuXHRcIi4vaGVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hlLmpzXCIsXG5cdFwiLi9oZS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaGUuanNcIixcblx0XCIuL2hpXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oaS5qc1wiLFxuXHRcIi4vaGkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hpLmpzXCIsXG5cdFwiLi9oclwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHIuanNcIixcblx0XCIuL2hyLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oci5qc1wiLFxuXHRcIi4vaHVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h1LmpzXCIsXG5cdFwiLi9odS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHUuanNcIixcblx0XCIuL2h5LWFtXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oeS1hbS5qc1wiLFxuXHRcIi4vaHktYW0uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzXCIsXG5cdFwiLi9pZFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaWQuanNcIixcblx0XCIuL2lkLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pZC5qc1wiLFxuXHRcIi4vaXNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lzLmpzXCIsXG5cdFwiLi9pcy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaXMuanNcIixcblx0XCIuL2l0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pdC5qc1wiLFxuXHRcIi4vaXQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzXCIsXG5cdFwiLi9qYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvamEuanNcIixcblx0XCIuL2phLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qYS5qc1wiLFxuXHRcIi4vanZcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2p2LmpzXCIsXG5cdFwiLi9qdi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvanYuanNcIixcblx0XCIuL2thXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rYS5qc1wiLFxuXHRcIi4va2EuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2thLmpzXCIsXG5cdFwiLi9ra1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva2suanNcIixcblx0XCIuL2trLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ray5qc1wiLFxuXHRcIi4va21cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ttLmpzXCIsXG5cdFwiLi9rbS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva20uanNcIixcblx0XCIuL2tuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbi5qc1wiLFxuXHRcIi4va24uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tuLmpzXCIsXG5cdFwiLi9rb1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva28uanNcIixcblx0XCIuL2tvLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rby5qc1wiLFxuXHRcIi4va3VcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2t1LmpzXCIsXG5cdFwiLi9rdS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva3UuanNcIixcblx0XCIuL2t5XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9reS5qc1wiLFxuXHRcIi4va3kuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2t5LmpzXCIsXG5cdFwiLi9sYlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbGIuanNcIixcblx0XCIuL2xiLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sYi5qc1wiLFxuXHRcIi4vbG9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xvLmpzXCIsXG5cdFwiLi9sby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbG8uanNcIixcblx0XCIuL2x0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdC5qc1wiLFxuXHRcIi4vbHQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x0LmpzXCIsXG5cdFwiLi9sdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHYuanNcIixcblx0XCIuL2x2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdi5qc1wiLFxuXHRcIi4vbWVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21lLmpzXCIsXG5cdFwiLi9tZS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWUuanNcIixcblx0XCIuL21pXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9taS5qc1wiLFxuXHRcIi4vbWkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21pLmpzXCIsXG5cdFwiLi9ta1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWsuanNcIixcblx0XCIuL21rLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tay5qc1wiLFxuXHRcIi4vbWxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21sLmpzXCIsXG5cdFwiLi9tbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWwuanNcIixcblx0XCIuL21uXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tbi5qc1wiLFxuXHRcIi4vbW4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21uLmpzXCIsXG5cdFwiLi9tclwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXIuanNcIixcblx0XCIuL21yLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tci5qc1wiLFxuXHRcIi4vbXNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzXCIsXG5cdFwiLi9tcy1teVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXMtbXkuanNcIixcblx0XCIuL21zLW15LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy1teS5qc1wiLFxuXHRcIi4vbXMuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzXCIsXG5cdFwiLi9tdFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXQuanNcIixcblx0XCIuL210LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tdC5qc1wiLFxuXHRcIi4vbXlcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL215LmpzXCIsXG5cdFwiLi9teS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXkuanNcIixcblx0XCIuL25iXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uYi5qc1wiLFxuXHRcIi4vbmIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25iLmpzXCIsXG5cdFwiLi9uZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmUuanNcIixcblx0XCIuL25lLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uZS5qc1wiLFxuXHRcIi4vbmxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLmpzXCIsXG5cdFwiLi9ubC1iZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwtYmUuanNcIixcblx0XCIuL25sLWJlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC1iZS5qc1wiLFxuXHRcIi4vbmwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLmpzXCIsXG5cdFwiLi9ublwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbm4uanNcIixcblx0XCIuL25uLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubi5qc1wiLFxuXHRcIi4vcGEtaW5cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BhLWluLmpzXCIsXG5cdFwiLi9wYS1pbi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGEtaW4uanNcIixcblx0XCIuL3BsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wbC5qc1wiLFxuXHRcIi4vcGwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BsLmpzXCIsXG5cdFwiLi9wdFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQuanNcIixcblx0XCIuL3B0LWJyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC1ici5qc1wiLFxuXHRcIi4vcHQtYnIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LWJyLmpzXCIsXG5cdFwiLi9wdC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQuanNcIixcblx0XCIuL3JvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9yby5qc1wiLFxuXHRcIi4vcm8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3JvLmpzXCIsXG5cdFwiLi9ydVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcnUuanNcIixcblx0XCIuL3J1LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ydS5qc1wiLFxuXHRcIi4vc2RcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NkLmpzXCIsXG5cdFwiLi9zZC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2QuanNcIixcblx0XCIuL3NlXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZS5qc1wiLFxuXHRcIi4vc2UuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzXCIsXG5cdFwiLi9zaVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2kuanNcIixcblx0XCIuL3NpLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zaS5qc1wiLFxuXHRcIi4vc2tcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NrLmpzXCIsXG5cdFwiLi9zay5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2suanNcIixcblx0XCIuL3NsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zbC5qc1wiLFxuXHRcIi4vc2wuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NsLmpzXCIsXG5cdFwiLi9zcVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3EuanNcIixcblx0XCIuL3NxLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcS5qc1wiLFxuXHRcIi4vc3JcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLmpzXCIsXG5cdFwiLi9zci1jeXJsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci1jeXJsLmpzXCIsXG5cdFwiLi9zci1jeXJsLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci1jeXJsLmpzXCIsXG5cdFwiLi9zci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3IuanNcIixcblx0XCIuL3NzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcy5qc1wiLFxuXHRcIi4vc3MuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NzLmpzXCIsXG5cdFwiLi9zdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3YuanNcIixcblx0XCIuL3N2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdi5qc1wiLFxuXHRcIi4vc3dcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3N3LmpzXCIsXG5cdFwiLi9zdy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3cuanNcIixcblx0XCIuL3RhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90YS5qc1wiLFxuXHRcIi4vdGEuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RhLmpzXCIsXG5cdFwiLi90ZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGUuanNcIixcblx0XCIuL3RlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZS5qc1wiLFxuXHRcIi4vdGV0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZXQuanNcIixcblx0XCIuL3RldC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGV0LmpzXCIsXG5cdFwiLi90Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGcuanNcIixcblx0XCIuL3RnLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90Zy5qc1wiLFxuXHRcIi4vdGhcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RoLmpzXCIsXG5cdFwiLi90aC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGguanNcIixcblx0XCIuL3RsLXBoXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bC1waC5qc1wiLFxuXHRcIi4vdGwtcGguanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsLXBoLmpzXCIsXG5cdFwiLi90bGhcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsaC5qc1wiLFxuXHRcIi4vdGxoLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bGguanNcIixcblx0XCIuL3RyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ci5qc1wiLFxuXHRcIi4vdHIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RyLmpzXCIsXG5cdFwiLi90emxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bC5qc1wiLFxuXHRcIi4vdHpsLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanNcIixcblx0XCIuL3R6bVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLmpzXCIsXG5cdFwiLi90em0tbGF0blwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLWxhdG4uanNcIixcblx0XCIuL3R6bS1sYXRuLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0tbGF0bi5qc1wiLFxuXHRcIi4vdHptLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0uanNcIixcblx0XCIuL3VnLWNuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91Zy1jbi5qc1wiLFxuXHRcIi4vdWctY24uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VnLWNuLmpzXCIsXG5cdFwiLi91a1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdWsuanNcIixcblx0XCIuL3VrLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ay5qc1wiLFxuXHRcIi4vdXJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzXCIsXG5cdFwiLi91ci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXIuanNcIixcblx0XCIuL3V6XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei5qc1wiLFxuXHRcIi4vdXotbGF0blwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXotbGF0bi5qc1wiLFxuXHRcIi4vdXotbGF0bi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXotbGF0bi5qc1wiLFxuXHRcIi4vdXouanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LmpzXCIsXG5cdFwiLi92aVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdmkuanNcIixcblx0XCIuL3ZpLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS92aS5qc1wiLFxuXHRcIi4veC1wc2V1ZG9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3gtcHNldWRvLmpzXCIsXG5cdFwiLi94LXBzZXVkby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveC1wc2V1ZG8uanNcIixcblx0XCIuL3lvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS95by5qc1wiLFxuXHRcIi4veW8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3lvLmpzXCIsXG5cdFwiLi96aC1jblwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtY24uanNcIixcblx0XCIuL3poLWNuLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1jbi5qc1wiLFxuXHRcIi4vemgtaGtcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWhrLmpzXCIsXG5cdFwiLi96aC1oay5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtaGsuanNcIixcblx0XCIuL3poLXR3XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC10dy5qc1wiLFxuXHRcIi4vemgtdHcuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLXR3LmpzXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIHsgLy8gY2hlY2sgZm9yIG51bWJlciBvciBzdHJpbmdcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIGlkO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZSBzeW5jIHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qJFwiOyIsImltcG9ydCAnZnVsbGNhbGVuZGFyJztcclxuaW1wb3J0ICcuL19jYWxlbmRhci5zY3NzJztcclxuXHJcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XHJcblxyXG4vKipcclxuICogQSBjYWxlbmRhciB3aXRoIGNvdXJzZSBldmVudHMgaW4gaXQuXHJcbiAqXHJcbiAqIFJlcGxhY2VzIGRpdi5jbC1jYWxlbmRhclxyXG4gKlxyXG4gKiBUaGUgZGl2IGNvbnRhaW5zIEpTT04gZm9yIHRoZSBldmVudHMgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBsaWtlIHRoaXM6XHJcbiAqIHt0aXRsZTogJ1N0ZXAgMScsIHN0YXJ0OiAnMjAxOC0wNS0xNycsIHVybDogJy9zdGVwMSd9LFxyXG4gKiBAY29uc3RydWN0b3JcclxuKi9cclxuY29uc3QgQ2FsZW5kYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgc2VsID0gJ2Rpdi5jbC1jYWxlbmRhcic7XHJcbiAgICBTaXRlLlNpdGUucmVhZHkoKCkgPT4ge1xyXG4gICAgICAgIGxldCBjYWxlbmRhcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbCk7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8Y2FsZW5kYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjYWxlbmRhciA9IGNhbGVuZGFyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGxldCBldmVudHMgPSBKU09OLnBhcnNlKGNhbGVuZGFyLnRleHRDb250ZW50KTtcclxuICAgICAgICAgICAgY2FsZW5kYXIudGV4dENvbnRlbnQgPSAnJztcclxuXHJcbiAgICAgICAgICAgICQoY2FsZW5kYXIpLmZ1bGxDYWxlbmRhcih7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnJyxcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6ICd0aXRsZScsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICdwcmV2LG5leHQgdG9kYXknXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXZlbnRMaW1pdDogdHJ1ZSwgLy8gYWxsb3cgXCJtb3JlXCIgbGluayB3aGVuIHRvbyBtYW55IGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHNcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGNhbGVuZGFyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAkKGNhbGVuZGFyKS5mdWxsQ2FsZW5kYXIoJ3JlbmRlcicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5uZXcgQ2FsZW5kYXIoKTtcclxuXHJcbiIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL19jYWxlbmRhci5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjRhOGY5NTlhXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP3NvdXJjZU1hcCEuL19jYWxlbmRhci5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/c291cmNlTWFwIS4vX2NhbGVuZGFyLnNjc3NcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=